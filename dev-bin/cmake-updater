#!/bin/bash
# Copyright Â© 2025 Eser KUBALI <lxldev.contact@gmail.com>
# SPDX-License-Identifier: GPL-3.0-or-later
#
# This file is part of vglog-filter and is licensed under
# the GNU General Public License v3.0 or later.
# See the LICENSE file in the project root for details.
#
# CMake updater for vglog-filter
# Handles updating CMakeLists.txt version fields

set -euo pipefail

# Source utilities
SCRIPT_DIR="$(dirname "$(realpath "$0")")"
source "$SCRIPT_DIR/version-utils"

# --- CMake version field detection -------------------------------------------
detect_cmake_version_format() {
    local cmake_file="$1"
    
    if [[ ! -f "$cmake_file" ]]; then
        printf '%s' "none"
        return
    fi
    
    if grep -Eq '^[[:space:]]*project\([^)]*VERSION[[:space:]]+\$\{[^}]+\}' "$cmake_file"; then
        printf '%s' "variable"
    elif grep -Eq '^[[:space:]]*project\([^)]*VERSION[[:space:]]+[0-9]+\.[0-9]+\.[0-9]+' "$cmake_file"; then
        printf '%s' "inline"
    elif grep -Eq '^[[:space:]]*set[[:space:]]*\([[:space:]]*PROJECT_VERSION[[:space:]]+"?[0-9]+\.[0-9]+\.[0-9]+' "$cmake_file"; then
        printf '%s' "set"
    else
        printf '%s' "none"
    fi
}

# --- CMake version update functions ------------------------------------------
update_cmake_variable_format() {
    local cmake_file="$1"
    local new_version="$2"
    
    # For variable format, no update needed since CMakeLists.txt reads from VERSION file
    printf '%s\n' "${GREEN}CMakeLists.txt uses VERSION file variable (no update needed)${RESET}" >&2
    return 0
}

update_cmake_inline_format() {
    local cmake_file="$1"
    local new_version="$2"
    
    local before after
    before="$(_hash_file "$cmake_file")"
    
    sed -E -i "s/(^[[:space:]]*project\([^)]*VERSION[[:space:]]+)[0-9]+\.[0-9]+\.[0-9]+/\1${new_version}/" "$cmake_file"
    
    after="$(_hash_file "$cmake_file")"
    if [[ -n "$before" && -n "$after" && "$before" != "$after" ]]; then
        printf '%s\n' "${GREEN}Updated CMakeLists.txt to ${new_version}${RESET}" >&2
        git add -- "$cmake_file"
        return 0
    else
        warn "No changes made to CMakeLists.txt"
        return 1
    fi
}

update_cmake_set_format() {
    local cmake_file="$1"
    local new_version="$2"
    
    local before after
    before="$(_hash_file "$cmake_file")"
    
    sed -E -i "s/(^[[:space:]]*set[[:space:]]*\([[:space:]]*PROJECT_VERSION[[:space:]]+\"?)[0-9]+\.[0-9]+\.[0-9]+/\1${new_version}/" "$cmake_file"
    
    after="$(_hash_file "$cmake_file")"
    if [[ -n "$before" && -n "$after" && "$before" != "$after" ]]; then
        printf '%s\n' "${GREEN}Updated CMakeLists.txt to ${new_version}${RESET}" >&2
        git add -- "$cmake_file"
        return 0
    else
        warn "No changes made to CMakeLists.txt"
        return 1
    fi
}

# --- Main CMake update function ----------------------------------------------
update_cmake_version() {
    local cmake_file="$1"
    local new_version="$2"
    
    if [[ "$new_version" == *-* ]]; then
        warn "Skipping CMakeLists.txt update for pre-release"
        return 0
    fi
    
    if [[ ! -f "$cmake_file" ]]; then
        return 0
    fi
    
    local format
    format=$(detect_cmake_version_format "$cmake_file")
    
    case "$format" in
        "variable")
            update_cmake_variable_format "$cmake_file" "$new_version"
            ;;
        "inline")
            update_cmake_inline_format "$cmake_file" "$new_version"
            ;;
        "set")
            update_cmake_set_format "$cmake_file" "$new_version"
            ;;
        "none")
            warn "CMakeLists.txt present but no recognizable version field"
            return 0
            ;;
        *)
            warn "Unknown CMake version format"
            return 1
            ;;
    esac
}

# --- Dry run simulation ------------------------------------------------------
simulate_cmake_update() {
    local cmake_file="$1"
    local new_version="$2"
    
    if [[ "$new_version" == *-* ]]; then
        printf '%s\n' "${YELLOW}DRY RUN: Would skip CMakeLists update (pre-release)${RESET}" >&2
        return 0
    fi
    
    if [[ ! -f "$cmake_file" ]]; then
        printf '%s\n' "${YELLOW}DRY RUN: Would skip CMakeLists (file not found)${RESET}" >&2
        return 0
    fi
    
    local format
    format=$(detect_cmake_version_format "$cmake_file")
    
    case "$format" in
        "variable")
            printf '%s\n' "${YELLOW}DRY RUN: Would skip CMakeLists.txt update (uses VERSION file variable)${RESET}" >&2
            ;;
        "inline"|"set")
            printf '%s\n' "${YELLOW}DRY RUN: Would update CMakeLists.txt to $new_version${RESET}" >&2
            ;;
        "none")
            printf '%s\n' "${YELLOW}DRY RUN: Would skip CMakeLists.txt update (no recognizable version field)${RESET}" >&2
            ;;
        *)
            printf '%s\n' "${YELLOW}DRY RUN: Would skip CMakeLists.txt update (unknown format)${RESET}" >&2
            ;;
    esac
}

# --- CMake validation --------------------------------------------------------
validate_cmake_file() {
    local cmake_file="$1"
    
    if [[ ! -f "$cmake_file" ]]; then
        return 1
    fi
    
    # Basic CMake syntax check
    if ! grep -q '^[[:space:]]*project(' "$cmake_file"; then
        warn "CMakeLists.txt does not contain a project() declaration"
        return 1
    fi
    
    return 0
}

# --- CMake version extraction ------------------------------------------------
extract_cmake_version() {
    local cmake_file="$1"
    
    if [[ ! -f "$cmake_file" ]]; then
        return 1
    fi
    
    local format
    format=$(detect_cmake_version_format "$cmake_file")
    
    case "$format" in
        "inline")
            grep -E '^[[:space:]]*project\([^)]*VERSION[[:space:]]+[0-9]+\.[0-9]+\.[0-9]+' "$cmake_file" | \
                sed -E 's/.*VERSION[[:space:]]+([0-9]+\.[0-9]+\.[0-9]+).*/\1/'
            ;;
        "set")
            grep -E '^[[:space:]]*set[[:space:]]*\([[:space:]]*PROJECT_VERSION[[:space:]]+"?[0-9]+\.[0-9]+\.[0-9]+' "$cmake_file" | \
                sed -E 's/.*PROJECT_VERSION[[:space:]]+"?([0-9]+\.[0-9]+\.[0-9]+).*/\1/'
            ;;
        "variable")
            # For variable format, we can't extract the version from CMakeLists.txt
            return 1
            ;;
        *)
            return 1
            ;;
    esac
}

# --- CMake backup and restore ------------------------------------------------
backup_cmake_file() {
    local cmake_file="$1"
    local backup_dir="$2"
    
    if [[ ! -f "$cmake_file" ]]; then
        return 1
    fi
    
    mkdir -p "$backup_dir"
    local backup_file="$backup_dir/CMakeLists.txt.backup.$(date +%Y%m%d_%H%M%S)"
    cp "$cmake_file" "$backup_file"
    printf '%s' "$backup_file"
}

restore_cmake_file() {
    local backup_file="$1"
    local cmake_file="$2"
    
    if [[ ! -f "$backup_file" ]]; then
        return 1
    fi
    
    cp "$backup_file" "$cmake_file"
    success "Restored CMakeLists.txt from backup"
}

# --- Main CMake operations function -----------------------------------------
perform_cmake_operations() {
    local cmake_file="$1"
    local new_version="$2"
    local update_cmake="$3"
    local dry_run="$4"
    
    if [[ "$update_cmake" != "true" ]]; then
        warn "Skipped CMakeLists.txt update (--no-cmake)"
        return 0
    fi
    
    if [[ "$dry_run" == "true" ]]; then
        simulate_cmake_update "$cmake_file" "$new_version"
        return 0
    fi
    
    update_cmake_version "$cmake_file" "$new_version"
}

# --- Standalone usage --------------------------------------------------------
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    # Initialize colors
    init_colors "${NO_COLOR:-false}"
    
    case "${1:-}" in
        "update")
            if [[ $# -lt 3 ]]; then
                die "Usage: $0 update <cmake_file> <new_version>"
            fi
            update_cmake_version "$2" "$3"
            ;;
        "detect")
            if [[ $# -lt 2 ]]; then
                die "Usage: $0 detect <cmake_file>"
            fi
            format=$(detect_cmake_version_format "$2")
            printf '%s\n' "$format"
            ;;
        "extract")
            if [[ $# -lt 2 ]]; then
                die "Usage: $0 extract <cmake_file>"
            fi
            extract_cmake_version "$2"
            ;;
        "validate")
            if [[ $# -lt 2 ]]; then
                die "Usage: $0 validate <cmake_file>"
            fi
            if validate_cmake_file "$2"; then
                success "CMakeLists.txt is valid"
            else
                die "CMakeLists.txt validation failed"
            fi
            ;;
        "simulate")
            if [[ $# -lt 3 ]]; then
                die "Usage: $0 simulate <cmake_file> <new_version>"
            fi
            simulate_cmake_update "$2" "$3"
            ;;
        *)
            cat << EOF
Usage: $0 <command> [args...]

Commands:
  update <cmake_file> <new_version>     Update CMakeLists.txt version
  detect <cmake_file>                   Detect CMake version format
  extract <cmake_file>                  Extract current version from CMakeLists.txt
  validate <cmake_file>                 Validate CMakeLists.txt
  simulate <cmake_file> <new_version>   Simulate update (dry run)

Examples:
  $0 update CMakeLists.txt 1.0.1
  $0 detect CMakeLists.txt
  $0 extract CMakeLists.txt
  $0 validate CMakeLists.txt
  $0 simulate CMakeLists.txt 1.0.1
EOF
            exit 1
            ;;
    esac
fi 