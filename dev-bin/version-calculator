#!/bin/bash
# Copyright Â© 2025 Eser KUBALI <lxldev.contact@gmail.com>
# SPDX-License-Identifier: GPL-3.0-or-later
#
# This file is part of vglog-filter and is licensed under
# the GNU General Public License v3.0 or later.
# See the LICENSE file in the project root for details.
#
# Version Calculator
# Calculates next version based on LOC-based delta system and bonus points

set -Eeuo pipefail
IFS=$'\n\t'
export LC_ALL=C

show_help() {
    cat << EOF
Version Calculator

Usage: $(basename "$0") [options]

Options:
  --current-version <ver>  Current version (e.g., 1.2.3)
  --bump-type <type>       Bump type: major, minor, patch
  --loc <number>           Lines of code changed
  --bonus <number>         Bonus points to add
  --machine                Output machine-readable key=value format
  --json                   Output machine-readable JSON
  --help, -h               Show this help

Examples:
  $(basename "$0") --current-version 1.2.3 --bump-type minor --loc 500
  $(basename "$0") --current-version 1.2.3 --bump-type major --bonus 10 --machine
  $(basename "$0") --current-version 1.2.3 --bump-type patch --loc 100 --json
EOF
}

# Parse arguments
CURRENT_VERSION=""
BUMP_TYPE=""
LOC=0
BONUS=0
MACHINE_OUTPUT=false
JSON_OUTPUT=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --current-version)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --current-version requires a value\n' >&2; exit 1; }
            CURRENT_VERSION="$2"; shift 2;;
        --bump-type)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --bump-type requires a value\n' >&2; exit 1; }
            BUMP_TYPE="$2"; shift 2;;
        --loc)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --loc requires a value\n' >&2; exit 1; }
            LOC="$2"; shift 2;;
        --bonus)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --bonus requires a value\n' >&2; exit 1; }
            BONUS="$2"; shift 2;;
        --machine) MACHINE_OUTPUT=true; shift;;
        --json) JSON_OUTPUT=true; shift;;
        --help|-h) show_help; exit 0;;
        *) printf 'Error: Unknown option: %s\n' "$1" >&2; show_help; exit 1;;
    esac
done

# Validate required arguments
if [[ -z "$CURRENT_VERSION" ]]; then
    printf 'Error: --current-version is required\n' >&2
    exit 1
fi

if [[ -z "$BUMP_TYPE" ]]; then
    printf 'Error: --bump-type is required\n' >&2
    exit 1
fi

# Validate bump type
case "$BUMP_TYPE" in
    major|minor|patch) ;;
    *) printf 'Error: --bump-type must be major, minor, or patch\n' >&2; exit 1;;
esac

# Validate numeric inputs
if [[ ! "$LOC" =~ ^[0-9]+$ ]]; then
    printf 'Error: --loc must be a non-negative integer\n' >&2
    exit 1
fi

if [[ ! "$BONUS" =~ ^[0-9]+$ ]]; then
    printf 'Error: --bonus must be a non-negative integer\n' >&2
    exit 1
fi

# Constants for the versioning system
MAIN_VERSION_MOD=1000

# Calculate LOC-based delta for version increments
calculate_loc_delta() {
    local bump_type="$1"
    local loc="$2"
    
    # Base delta calculation based on bump type and LOC
    local base_delta=0
    case "$bump_type" in
        patch)
            # VERSION_PATCH_DELTA=1*(1+LOC/250)
            base_delta=$(awk "BEGIN {printf \"%.0f\", 1 * (1 + $loc / 250)}" 2>/dev/null || echo "1")
            ;;
        minor)
            # VERSION_MINOR_DELTA=5*(1+LOC/500)
            base_delta=$(awk "BEGIN {printf \"%.0f\", 5 * (1 + $loc / 500)}" 2>/dev/null || echo "5")
            ;;
        major)
            # VERSION_MAJOR_DELTA=10*(1+LOC/1000)
            base_delta=$(awk "BEGIN {printf \"%.0f\", 10 * (1 + $loc / 1000)}" 2>/dev/null || echo "10")
            ;;
        *)
            base_delta=1
            ;;
    esac
    
    # Ensure minimum base_delta of 1
    if [[ "$base_delta" -lt 1 ]]; then
        base_delta=1
    fi
    
    printf '%d' "$base_delta"
}

# Calculate bonus multiplier based on LOC and version type
calculate_bonus_multiplier() {
    local bump_type="$1"
    local loc="$2"
    
    # Apply bonus additions multiplying with LOC gain: (1+LOC/L)
    # where L=250, 500 or 1000 according to version change type
    local loc_divisor=0
    case "$bump_type" in
        patch) loc_divisor=250 ;;
        minor) loc_divisor=500 ;;
        major) loc_divisor=1000 ;;
        *) loc_divisor=250 ;;
    esac
    
    local multiplier=$(awk "BEGIN {printf \"%.2f\", 1 + $loc / $loc_divisor}" 2>/dev/null || echo "1.0")
    printf '%s' "$multiplier"
}

# Calculate next version with mathematical rollover system
calculate_next_version() {
    local current_version="$1"
    local bump_type="$2"
    local loc="$3"
    local bonus="$4"

    if [[ -z "$current_version" ]] || [[ "$current_version" = "0.0.0" ]]; then
        case "$bump_type" in
            major) printf '1.0.0' ;;
            minor) printf '0.1.0' ;;
            patch) printf '0.0.1' ;;
            *) printf '0.0.0' ;;
        esac
        return
    fi

    # Validate VERSION format
    if [[ ! $current_version =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        current_version=0.0.0
    fi

    local major minor patch
    IFS='.' read -r major minor patch <<< "$current_version"

    # Calculate base delta from LOC
    local base_delta=$(calculate_loc_delta "$bump_type" "$loc")
    
    # Calculate bonus multiplier
    local bonus_multiplier=$(calculate_bonus_multiplier "$bump_type" "$loc")
    
    # Calculate total bonus with multiplier
    local total_bonus=$(awk "BEGIN {printf \"%.0f\", $bonus * $bonus_multiplier}" 2>/dev/null || echo "$bonus")
    
    # Calculate total delta_z (base delta + total bonus)
    local delta_z=$((base_delta + total_bonus))
    
    # Ensure minimum delta_z of 1
    if [[ "$delta_z" -lt 1 ]]; then
        delta_z=1
    fi
    
    # Apply mathematical rollover system:
    # z_new = (z + delta_z) % MAIN_VERSION_MOD
    # delta_y = ((z + delta_z) - (z + delta_z) % MAIN_VERSION_MOD) / MAIN_VERSION_MOD
    # y_new = (y + delta_y) % MAIN_VERSION_MOD
    # delta_x = ((y + delta_y) - (y + delta_y) % MAIN_VERSION_MOD) / MAIN_VERSION_MOD
    # x_new = x + delta_x
    
    local new_z=$((patch + delta_z))
    local delta_y=$(((new_z - (new_z % MAIN_VERSION_MOD)) / MAIN_VERSION_MOD))
    local final_z=$((new_z % MAIN_VERSION_MOD))
    
    local new_y=$((minor + delta_y))
    local delta_x=$(((new_y - (new_y % MAIN_VERSION_MOD)) / MAIN_VERSION_MOD))
    local final_y=$((new_y % MAIN_VERSION_MOD))
    
    local final_x=$((major + delta_x))
    
    printf '%d.%d.%d' "$final_x" "$final_y" "$final_z"
}

# Main execution
NEXT_VERSION=$(calculate_next_version "$CURRENT_VERSION" "$BUMP_TYPE" "$LOC" "$BONUS")

# Calculate components for output
BASE_DELTA=$(calculate_loc_delta "$BUMP_TYPE" "$LOC")
BONUS_MULTIPLIER=$(calculate_bonus_multiplier "$BUMP_TYPE" "$LOC")
TOTAL_BONUS=$(awk "BEGIN {printf \"%.0f\", $BONUS * $BONUS_MULTIPLIER}" 2>/dev/null || echo "$BONUS")
TOTAL_DELTA=$((BASE_DELTA + TOTAL_BONUS))

# Determine LOC divisor for reason
LOC_DIVISOR=250
case "$BUMP_TYPE" in
    patch) LOC_DIVISOR=250 ;;
    minor) LOC_DIVISOR=500 ;;
    major) LOC_DIVISOR=1000 ;;
esac

# Output results
if [[ "$JSON_OUTPUT" = "true" ]]; then
    printf '{\n'
    printf '  "current_version": "%s",\n' "$CURRENT_VERSION"
    printf '  "bump_type": "%s",\n' "$BUMP_TYPE"
    printf '  "next_version": "%s",\n' "$NEXT_VERSION"
    printf '  "loc": %s,\n' "$LOC"
    printf '  "bonus": %s,\n' "$BONUS"
    printf '  "base_delta": %s,\n' "$BASE_DELTA"
    printf '  "bonus_multiplier": %s,\n' "$BONUS_MULTIPLIER"
    printf '  "total_bonus": %s,\n' "$TOTAL_BONUS"
    printf '  "total_delta": %s,\n' "$TOTAL_DELTA"
    printf '  "main_version_mod": %s,\n' "$MAIN_VERSION_MOD"
    printf '  "loc_divisor": %s,\n' "$LOC_DIVISOR"
    printf '  "reason": "LOC=%s, %s update, base_delta=%s, bonus=%s*%s=%s, total_delta=%s"\n' "$LOC" "$(printf '%s' "$BUMP_TYPE" | tr '[:lower:]' '[:upper:]')" "$BASE_DELTA" "$BONUS" "$BONUS_MULTIPLIER" "$TOTAL_BONUS" "$TOTAL_DELTA"
    printf '}\n'
elif [[ "$MACHINE_OUTPUT" = "true" ]]; then
    printf 'CURRENT_VERSION=%s\n' "$CURRENT_VERSION"
    printf 'BUMP_TYPE=%s\n' "$BUMP_TYPE"
    printf 'NEXT_VERSION=%s\n' "$NEXT_VERSION"
    printf 'LOC=%s\n' "$LOC"
    printf 'BONUS=%s\n' "$BONUS"
    printf 'BASE_DELTA=%s\n' "$BASE_DELTA"
    printf 'BONUS_MULTIPLIER=%s\n' "$BONUS_MULTIPLIER"
    printf 'TOTAL_BONUS=%s\n' "$TOTAL_BONUS"
    printf 'TOTAL_DELTA=%s\n' "$TOTAL_DELTA"
    printf 'MAIN_VERSION_MOD=%s\n' "$MAIN_VERSION_MOD"
    printf 'LOC_DIVISOR=%s\n' "$LOC_DIVISOR"
    printf 'REASON=LOC=%s, %s update, base_delta=%s, bonus=%s*%s=%s, total_delta=%s\n' "$LOC" "$(printf '%s' "$BUMP_TYPE" | tr '[:lower:]' '[:upper:]')" "$BASE_DELTA" "$BONUS" "$BONUS_MULTIPLIER" "$TOTAL_BONUS" "$TOTAL_DELTA"
else
    printf '=== Version Calculation ===\n'
    printf 'Current version: %s\n' "$CURRENT_VERSION"
    printf 'Bump type: %s\n' "$BUMP_TYPE"
    printf 'Next version: %s\n' "$NEXT_VERSION"
    printf '\nCalculation Details:\n'
    printf '  Lines of code: %s\n' "$LOC"
    printf '  Base bonus: %s\n' "$BONUS"
    printf '  Base delta: %s\n' "$BASE_DELTA"
    printf '  Bonus multiplier: %s\n' "$BONUS_MULTIPLIER"
    printf '  Total bonus: %s\n' "$TOTAL_BONUS"
    printf '  Total delta: %s\n' "$TOTAL_DELTA"
    printf '  Main version mod: %s\n' "$MAIN_VERSION_MOD"
    printf '  LOC divisor: %s\n' "$LOC_DIVISOR"
    printf '\nReason: LOC=%s, %s update, base_delta=%s, bonus=%s*%s=%s, total_delta=%s\n' "$LOC" "$(printf '%s' "$BUMP_TYPE" | tr '[:lower:]' '[:upper:]')" "$BASE_DELTA" "$BONUS" "$BONUS_MULTIPLIER" "$TOTAL_BONUS" "$TOTAL_DELTA"
fi 