#!/bin/bash
# Copyright Â© 2025 Eser KUBALI <lxldev.contact@gmail.com>
# SPDX-License-Identifier: GPL-3.0-or-later
#
# This file is part of vglog-filter and is licensed under
# the GNU General Public License v3.0 or later.
# See the LICENSE file in the project root for details.
#
# File Change Analyzer
# Analyzes file changes and classifies them by type

set -Eeuo pipefail
IFS=$'\n\t'
export LC_ALL=C
# Prevent any pager and avoid unnecessary repo locks for better performance.
export GIT_PAGER=cat PAGER=cat GIT_OPTIONAL_LOCKS=0

show_help() {
    cat << EOF
File Change Analyzer

Usage: $(basename "$0") [options]

Options:
  --base <ref>             Base reference for comparison
  --target <ref>           Target reference for comparison (default: HEAD)
  --repo-root <path>       Set repository root directory
  --only-paths <globs>     Restrict analysis to comma-separated path globs
  --ignore-whitespace      Ignore whitespace changes in diff analysis
  --machine                Output machine-readable key=value format
  --json                   Output machine-readable JSON
  --help, -h               Show this help

Examples:
  $(basename "$0") --base v1.0.0 --target HEAD
  $(basename "$0") --base HEAD~5 --target HEAD --machine
  $(basename "$0") --base v1.0.0 --target v1.1.0 --json
EOF
}

# Parse arguments
BASE_REF=""
TARGET_REF="HEAD"
REPO_ROOT=""
ONLY_PATHS=""
IGNORE_WHITESPACE=false
MACHINE_OUTPUT=false
JSON_OUTPUT=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --base)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --base requires a value\n' >&2; exit 1; }
            BASE_REF="$2"; shift 2;;
        --target)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --target requires a value\n' >&2; exit 1; }
            TARGET_REF="$2"; shift 2;;
        --repo-root)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --repo-root requires a value\n' >&2; exit 1; }
            REPO_ROOT="$2"; shift 2;;
        --only-paths)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --only-paths requires a comma-separated globs list\n' >&2; exit 1; }
            ONLY_PATHS="$2"; shift 2;;
        --ignore-whitespace) IGNORE_WHITESPACE=true; shift;;
        --machine) MACHINE_OUTPUT=true; shift;;
        --json) JSON_OUTPUT=true; shift;;
        --help|-h) show_help; exit 0;;
        *) printf 'Error: Unknown option: %s\n' "$1" >&2; show_help; exit 1;;
    esac
done

# Validate required arguments
if [[ -z "$BASE_REF" ]]; then
    printf 'Error: --base is required\n' >&2
    exit 1
fi

# Check git command
if ! command -v git >/dev/null 2>&1; then
    printf 'Error: git command not found\n' >&2
    exit 1
fi

# Change to repo root if specified
if [[ -n "$REPO_ROOT" ]]; then
    cd "$REPO_ROOT"
    git rev-parse --is-inside-work-tree >/dev/null 2>&1 || {
        printf 'Error: Not in a git repository at %s\n' "$REPO_ROOT" >&2
        exit 1
    }
fi

# Build PATH_ARGS array from --only-paths
PATH_ARGS=()
if [[ -n "$ONLY_PATHS" ]]; then
    IFS=',' read -r -a tmp <<< "$ONLY_PATHS"
    PATH_ARGS+=(--)
    for g in "${tmp[@]}"; do
        # Trim surrounding spaces
        g="${g##+([[:space:]])}"
        g="${g%%+([[:space:]])}"
        [[ -n "$g" ]] && PATH_ARGS+=("$g")
    done
fi

# Validate git references
verify_ref() {
    local ref="$1"
    if ! git -c color.ui=false rev-parse -q --verify "$ref^{commit}" >/dev/null; then
        printf 'Error: Invalid reference: %s\n' "$ref" >&2
        exit 1
    fi
}

verify_ref "$BASE_REF"
verify_ref "$TARGET_REF"

# Classify file path - improved to handle multiple folder patterns and nested directories
classify_path() {
    local path="$1"
    local path_lower
    path_lower=$(printf '%s' "$path" | tr '[:upper:]' '[:lower:]')

    # Skip noise directories and binary/lock artifacts (including nested ones)
    if [[ "$path" =~ /(build|dist|out|third_party|vendor|\.git|node_modules|target|bin|obj)/ ]] || \
       [[ "$path" =~ ^(build|dist|out|third_party|vendor|\.git|node_modules|target|bin|obj)/ ]] || \
       [[ "$path" =~ \.(lock|exe|dll|so|dylib|jar|war|ear|zip|tar|gz|bz2|xz|7z|rar)$ ]]; then
        printf '0'
        return
    fi

    # Source files (including headers)
    if [[ "$path" =~ (^|/)src/ ]] || [[ "$path" =~ (^|/)source/ ]] || [[ "$path" =~ (^|/)app/ ]] || \
       [[ "$path" =~ \.(c|cc|cpp|cxx|h|hpp|hh)$ ]]; then
        printf '30'
        return
    fi

    # Test files
    if [[ "$path" =~ (^|/)(test|tests|unittests)/ ]] || [[ "$path" =~ \.(test|spec)\.(c|cpp|sh|py)$ ]]; then
        printf '10'
        return
    fi

    # Documentation files (case-insensitive)
    if [[ "$path_lower" =~ (^|/)(doc|docs)/ ]] || \
       [[ "$path_lower" =~ (^|/)(readme|changelog|contributing|license|copying|authors|install|news|history) ]] || \
       [[ "$path_lower" =~ \.(md|rst|adoc|txt)$ ]]; then
        printf '20'
        return
    fi

    printf '0'
}

# Binary-safe numstat summation function
sum_numstat() {
    local cmd=("$@")
    local total_ins=0 total_del=0
    while IFS=$'\t' read -r ins del _; do
        [[ $ins =~ ^[0-9]+$ ]] || ins=0
        [[ $del =~ ^[0-9]+$ ]] || del=0
        total_ins=$((total_ins + ins))
        total_del=$((total_del + del))
    done < <("${cmd[@]}")
    printf '%s' $((total_ins + total_del))
}

# Analyze file changes
analyze_file_changes() {
    local base_ref="$1"
    local target_ref="$2"
    
    # Initialize counters
    local added_files=0
    local modified_files=0
    local deleted_files=0
    local new_source_files=0
    local new_test_files=0
    local new_doc_files=0
    local diff_size=0

    # Check if there are any changes
    if [[ "$IGNORE_WHITESPACE" = "true" ]]; then
        if git -c color.ui=false diff -M -C -w --quiet "$base_ref".."$target_ref"; then
            printf 'Warning: No changes detected between %s and %s (ignoring whitespace)\n' "$base_ref" "$target_ref" >&2
            # Output empty results
            if [[ "$JSON_OUTPUT" = "true" ]]; then
                printf '{\n'
                printf '  "added_files": 0,\n'
                printf '  "modified_files": 0,\n'
                printf '  "deleted_files": 0,\n'
                printf '  "new_source_files": 0,\n'
                printf '  "new_test_files": 0,\n'
                printf '  "new_doc_files": 0,\n'
                printf '  "diff_size": 0\n'
                printf '}\n'
            elif [[ "$MACHINE_OUTPUT" = "true" ]]; then
                printf 'ADDED_FILES=0\n'
                printf 'MODIFIED_FILES=0\n'
                printf 'DELETED_FILES=0\n'
                printf 'NEW_SOURCE_FILES=0\n'
                printf 'NEW_TEST_FILES=0\n'
                printf 'NEW_DOC_FILES=0\n'
                printf 'DIFF_SIZE=0\n'
            else
                printf '=== File Change Analysis ===\n'
                printf 'No changes detected\n'
            fi
            return
        fi
    else
        if git -c color.ui=false diff -M -C --quiet "$base_ref".."$target_ref"; then
            printf 'Warning: No changes detected between %s and %s\n' "$base_ref" "$target_ref" >&2
            # Output empty results
            if [[ "$JSON_OUTPUT" = "true" ]]; then
                printf '{\n'
                printf '  "added_files": 0,\n'
                printf '  "modified_files": 0,\n'
                printf '  "deleted_files": 0,\n'
                printf '  "new_source_files": 0,\n'
                printf '  "new_test_files": 0,\n'
                printf '  "new_doc_files": 0,\n'
                printf '  "diff_size": 0\n'
                printf '}\n'
            elif [[ "$MACHINE_OUTPUT" = "true" ]]; then
                printf 'ADDED_FILES=0\n'
                printf 'MODIFIED_FILES=0\n'
                printf 'DELETED_FILES=0\n'
                printf 'NEW_SOURCE_FILES=0\n'
                printf 'NEW_TEST_FILES=0\n'
                printf 'NEW_DOC_FILES=0\n'
                printf 'DIFF_SIZE=0\n'
            else
                printf '=== File Change Analysis ===\n'
                printf 'No changes detected\n'
            fi
            return
        fi
    fi

    # NUL-delimited, handle renames/copies
    while IFS= read -r -d '' status; do
        local path1 path2 file
        IFS= read -r -d '' path1
        file="$path1"
        case "${status:0:1}" in
            R|C)
                IFS= read -r -d '' path2
                file="$path2"
                ;;
        esac

        case "${status:0:1}" in
            A) 
                added_files=$((added_files + 1))
                case "$(classify_path "$file")" in
                    30) new_source_files=$((new_source_files + 1)) ;;
                    10) new_test_files=$((new_test_files + 1)) ;;
                    20) new_doc_files=$((new_doc_files + 1)) ;;
                esac
                ;;
            M|T) modified_files=$((modified_files + 1)) ;;
            D)   deleted_files=$((deleted_files + 1)) ;;
            R)   modified_files=$((modified_files + 1)) ;;
            C)   modified_files=$((modified_files + 1)) ;; # Count copies as modifications, not additions
        esac
    done < <(if [[ "$IGNORE_WHITESPACE" = "true" ]]; then
        git -c color.ui=false -c core.quotepath=false diff -M -C -w --name-status -z "$base_ref".."$target_ref" "${PATH_ARGS[@]}" 2>/dev/null
    else
        git -c color.ui=false -c core.quotepath=false diff -M -C --name-status -z "$base_ref".."$target_ref" "${PATH_ARGS[@]}" 2>/dev/null
    fi)

    # Get diff size using numstat (binary-safe)
    if [[ "$IGNORE_WHITESPACE" = "true" ]]; then
        diff_size=$(sum_numstat git -c color.ui=false -c core.quotepath=false diff -M -C -w --numstat "$base_ref".."$target_ref" "${PATH_ARGS[@]}")
    else
        diff_size=$(sum_numstat git -c color.ui=false -c core.quotepath=false diff -M -C --numstat "$base_ref".."$target_ref" "${PATH_ARGS[@]}")
    fi

    # Output results
    if [[ "$JSON_OUTPUT" = "true" ]]; then
        printf '{\n'
        printf '  "added_files": %s,\n' "$added_files"
        printf '  "modified_files": %s,\n' "$modified_files"
        printf '  "deleted_files": %s,\n' "$deleted_files"
        printf '  "new_source_files": %s,\n' "$new_source_files"
        printf '  "new_test_files": %s,\n' "$new_test_files"
        printf '  "new_doc_files": %s,\n' "$new_doc_files"
        printf '  "diff_size": %s\n' "$diff_size"
        printf '}\n'
    elif [[ "$MACHINE_OUTPUT" = "true" ]]; then
        printf 'ADDED_FILES=%s\n' "$added_files"
        printf 'MODIFIED_FILES=%s\n' "$modified_files"
        printf 'DELETED_FILES=%s\n' "$deleted_files"
        printf 'NEW_SOURCE_FILES=%s\n' "$new_source_files"
        printf 'NEW_TEST_FILES=%s\n' "$new_test_files"
        printf 'NEW_DOC_FILES=%s\n' "$new_doc_files"
        printf 'DIFF_SIZE=%s\n' "$diff_size"
    else
        printf '=== File Change Analysis ===\n'
        printf 'Base reference: %s\n' "$base_ref"
        printf 'Target reference: %s\n' "$target_ref"
        printf '\nFile Changes:\n'
        printf '  Added files: %s\n' "$added_files"
        printf '  Modified files: %s\n' "$modified_files"
        printf '  Deleted files: %s\n' "$deleted_files"
        printf '\nNew Content:\n'
        printf '  New source files: %s\n' "$new_source_files"
        printf '  New test files: %s\n' "$new_test_files"
        printf '  New doc files: %s\n' "$new_doc_files"
        printf '\nChange Magnitude:\n'
        printf '  Diff size: %s lines\n' "$diff_size"
    fi
}

# Main execution
analyze_file_changes "$BASE_REF" "$TARGET_REF" 