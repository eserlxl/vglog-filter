#!/bin/bash
# Copyright © 2025 Eser KUBALI <lxldev.contact@gmail.com>
# SPDX-License-Identifier: GPL-3.0-or-later
#
# This file is part of vglog-filter and is licensed under
# the GNU General Public License v3.0 or later.
# See the LICENSE file in the project root for details.
#
# Version bump script for vglog-filter
# Usage: ./dev-bin/bump-version [major|minor|patch] [--commit] [--tag] [--dry-run] [--message MSG] [--allow-dirty] [--lightweight-tag] [--signed-tag] [--no-verify] [--print] [--no-cmake] [--tag-prefix PREFIX] [--sign-commit] [--set VERSION]

set -euo pipefail

# Ensure consistent locale and behavior
export LC_ALL=C

# Set predictable file permissions
umask 022

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
RESET='\033[0m'

# Get script directory and project root
SCRIPT_DIR="$(dirname "$(realpath "$0")")"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
VERSION_FILE="$PROJECT_ROOT/VERSION"

# Change to project root for git operations
cd "$PROJECT_ROOT"

# Track temp file for cleanup
TMP_FILE=""

# Trap to clean temp files on interrupt/exit
trap '[[ -n "$TMP_FILE" ]] && rm -f "$TMP_FILE" 2>/dev/null || true' INT TERM EXIT

# Check if VERSION file exists
if [[ ! -f "$VERSION_FILE" ]]; then
    echo -e "${RED}Error: VERSION file not found at $VERSION_FILE${RESET}" >&2
    exit 1
fi

# Validate VERSION symlink safety
VERSION_REAL="$(readlink -f "$VERSION_FILE")"
case "$VERSION_REAL" in 
    "$PROJECT_ROOT"/*) ;; 
    *) 
        echo -e "${RED}Error: VERSION resolves outside repo${RESET}" >&2
        exit 1
        ;;
esac

# Read current version
CURRENT_VERSION=$(tr -d '[:space:]' < "$VERSION_FILE")

# Validate current version format
if [[ ! "$CURRENT_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    echo -e "${RED}Error: Invalid version format in VERSION file: $CURRENT_VERSION${RESET}" >&2
    echo -e "${YELLOW}Expected format: MAJOR.MINOR.PATCH (e.g., 1.0.0)${RESET}" >&2
    exit 1
fi

# New options vars
COMMIT_MSG=""
ALLOW_DIRTY=false
ANNOTATED_TAG=true    # default to annotated tag
SIGNED_TAG=false      # default to unsigned tag
COMMIT_SIGN=false     # default to unsigned commit
NO_VERIFY=false       # default to running hooks
UPDATE_CMAKE=true     # default to updating CMake
TAG_PREFIX="${TAG_PREFIX:-v}"  # default tag prefix, can be overridden by env var
SET_VERSION=""        # for --set option

# Validate TAG_PREFIX content early
if [[ "$TAG_PREFIX" =~ $'\n' || "$TAG_PREFIX" =~ $'\r' ]]; then
    echo -e "${RED}Error: TAG_PREFIX contains newline characters${RESET}" >&2
    exit 1
fi

# Function to show usage
usage() {
    cat << 'EOF'
Usage: ./dev-bin/bump-version [major|minor|patch] [--commit] [--tag] [--dry-run] [--message MSG] [--allow-dirty] [--lightweight-tag] [--signed-tag] [--no-verify] [--print] [--no-cmake] [--tag-prefix PREFIX] [--sign-commit] [--set VERSION]

Bump the semantic version of vglog-filter

Requirements:
  GNU tools on Linux: realpath, sha1sum, GNU sed, GNU grep

Arguments:
  major    Increment major version (breaking changes)
  minor    Increment minor version (new features)
  patch    Increment patch version (bug fixes)

Options:
  --commit Create a git commit with the version bump
  --tag    Create a git tag for the new version
  --dry-run Show what would be done without making changes
  --print  Print the new version without making any changes
  --message MSG     Use MSG as the full commit message (overrides default)
                    Note: When --message is provided, ANALYSIS_MESSAGE is ignored
  --allow-dirty     Allow committing when other files are modified
  --lightweight-tag Create a lightweight tag instead of annotated
  --signed-tag      Create a signed tag (requires GPG key configured)
  --sign-commit     GPG-sign the commit (requires GPG key configured)
  --no-verify       Skip commit hooks (useful in CI environments)
  --no-cmake        Skip updating CMakeLists.txt version fields
  --tag-prefix PREFIX  Use PREFIX instead of 'v' for tag names (default: v)
                       Note: Empty prefix is allowed (tags like 1.2.3)
  --set VERSION     Set version to VERSION instead of bumping (format: X.Y.Z)

Environment Variables:
  ANALYSIS_MESSAGE  Optional detailed analysis to include in commit message
                    (ignored when --message is provided)
  TAG_PREFIX       Default tag prefix (can be overridden by --tag-prefix)
                   Note: Glob characters (* ? [ ]) are supported and will be escaped for tag matching

CI Integration:
  When running in GitHub Actions and --message isn't provided, the script
  automatically appends [skip ci] to the default commit message to prevent
  other workflows from running.

Commit Message Consistency:
  The default commit subject uses the same prefix as tags:
  chore(release): <prefix><version>
  This ensures consistency between commit messages and tag names.

GPG Signing Notes:
  If commit.gpgSign=true is configured, --no-verify will skip hooks but
  still require GPG signing. Use --sign-commit explicitly if needed.

Examples:
  ./dev-bin/bump-version patch                    # Bump patch version
  ./dev-bin/bump-version minor --commit           # Bump minor version and commit
  ./dev-bin/bump-version major --commit --tag     # Bump major version, commit, and tag
  ./dev-bin/bump-version patch --dry-run          # Show what patch bump would do
  ./dev-bin/bump-version patch --print            # Print new version without changes
  ANALYSIS_MESSAGE='...' ./dev-bin/bump-version patch --commit  # Include analysis in commit
  ./dev-bin/bump-version patch --message 'Custom commit message' --commit  # Use custom message
  ./dev-bin/bump-version patch --signed-tag --tag # Create signed tag for provenance
  ./dev-bin/bump-version patch --sign-commit --commit # GPG-sign the commit
  ./dev-bin/bump-version patch --no-verify --commit # Skip commit hooks (useful in CI)
  ./dev-bin/bump-version patch --commit --signed-tag --no-verify --message 'chore(release): <prefix>X.Y.Z [skip ci]'  # Signed tag with CI
  ANALYSIS_MESSAGE='Auto version bump (push)' ./dev-bin/bump-version patch --commit --message 'chore(release): <prefix>X.Y.Z [skip ci]'  # CI usage
  ./dev-bin/bump-version patch --no-cmake         # Skip CMakeLists.txt updates
  ./dev-bin/bump-version patch --tag-prefix 'release-' --tag  # Create tag 'release-1.2.3'
  ./dev-bin/bump-version patch --tag-prefix '' --tag  # Create tag '1.2.3' (no prefix)
  TAG_PREFIX='ver' ./dev-bin/bump-version patch --tag  # Use environment variable for prefix
  ./dev-bin/bump-version --set 2.1.0 --commit     # Set version to 2.1.0 and commit

Current version: CURRENT_VERSION_PLACEHOLDER
EOF
}

# Function to validate version format
validate_version_format() {
    local version="$1"
    if [[ ! "$version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        echo -e "${RED}Error: Invalid version format: $version${RESET}" >&2
        echo -e "${YELLOW}Expected format: MAJOR.MINOR.PATCH (e.g., 1.0.0)${RESET}" >&2
        exit 1
    fi
}

# Function to bump version
bump_version() {
    local bump_type="$1"
    local current_major current_minor current_patch
    local new_major new_minor new_patch
    
    # Parse current version components
    IFS='.' read -r current_major current_minor current_patch <<< "$CURRENT_VERSION"
    
    case "$bump_type" in
        major)
            new_major=$((current_major + 1))
            new_minor=0
            new_patch=0
            ;;
        minor)
            new_major=$current_major
            new_minor=$((current_minor + 1))
            new_patch=0
            ;;
        patch)
            new_major=$current_major
            new_minor=$current_minor
            new_patch=$((current_patch + 1))
            ;;
        *)
            echo -e "${RED}Error: Invalid bump type '$bump_type'${RESET}" >&2
            echo -e "${YELLOW}Valid types: major, minor, patch${RESET}" >&2
            exit 1
            ;;
    esac
    
    NEW_VERSION="$new_major.$new_minor.$new_patch"
}

# Function to update VERSION file with atomic write
update_version_file() {
    TMP_FILE="${VERSION_FILE}.tmp.$$"
    printf '%s\n' "$NEW_VERSION" > "$TMP_FILE"
    sync -f "$TMP_FILE" 2>/dev/null || true
    mv -f "$TMP_FILE" "$VERSION_FILE"
    echo -e "${GREEN}Updated VERSION file: $CURRENT_VERSION → $NEW_VERSION${RESET}" >&2
}

# Function to update CMakeLists.txt if it contains version information
update_cmake_version() {
    local cmake="$PROJECT_ROOT/CMakeLists.txt"
    [[ -f "$cmake" ]] || return 0
    local before after

    before="$(sha1sum "$cmake" | awk '{print $1}')"
    if grep -Eq '^[[:space:]]*project\([^)]*VERSION[[:space:]]+[0-9]+\.[0-9]+\.[0-9]+' "$cmake"; then
        sed -E -i "s/(^[[:space:]]*project\([^)]*VERSION[[:space:]]+)[0-9]+\.[0-9]+\.[0-9]+/\1${NEW_VERSION}/" "$cmake"
    elif grep -Eq '^[[:space:]]*set[[:space:]]*\([[:space:]]*PROJECT_VERSION[[:space:]]+"?[0-9]+\.[0-9]+\.[0-9]+' "$cmake"; then
        sed -E -i "s/(^[[:space:]]*set[[:space:]]*\([[:space:]]*PROJECT_VERSION[[:space:]]+\"?)[0-9]+\.[0-9]+\.[0-9]+/\1${NEW_VERSION}/" "$cmake"
    else
        echo -e "${YELLOW}Note: CMakeLists.txt present but no recognizable version field to update${RESET}" >&2
        return 0
    fi
    after="$(sha1sum "$cmake" | awk '{print $1}')"
    if [[ "$before" != "$after" ]]; then
        echo -e "${GREEN}Updated CMakeLists.txt to ${NEW_VERSION}${RESET}" >&2
        git add -- "$cmake"
    fi
}

# Function to stage files for commit
stage_files() {
    # Stage VERSION file
    git add -- "$VERSION_FILE"
}

# Function to check git identity
check_git_identity() {
    if ! git config --get user.name >/dev/null; then
        echo -e "${YELLOW}Warning: git user.name is not set${RESET}" >&2
    fi
    if ! git config --get user.email >/dev/null; then
        echo -e "${YELLOW}Warning: git user.email is not set${RESET}" >&2
    fi
}

# Function to create git commit
create_commit() {
    stage_files
    
    # update_cmake_version may have already staged CMakeLists.txt
    if git diff --cached --quiet; then
        echo -e "${YELLOW}No staged changes to commit${RESET}" >&2
        return 0
    fi
    
    # Check git identity before committing
    check_git_identity
    
    # Default conventional message if not provided
    local msg="${COMMIT_MSG}"
    if [[ -z "$msg" ]]; then
        # Use paragraph-style commit message
        local commit_args=(${NO_VERIFY:+--no-verify})
        commit_args+=(${COMMIT_SIGN:+-S})
        commit_args+=(-m "chore(release): ${TAG_PREFIX}${NEW_VERSION}${GITHUB_ACTIONS:+ [skip ci]}")
        commit_args+=(-m "bump: ${CURRENT_VERSION} → ${NEW_VERSION}")
        
        # Append analysis if provided and no custom message
        if [[ -n "${ANALYSIS_MESSAGE:-}" ]]; then
            commit_args+=(-m "$ANALYSIS_MESSAGE")
        fi
        
        git commit "${commit_args[@]}"
        echo -e "${GREEN}Created commit${RESET}" >&2
    else
        # Use custom message (ANALYSIS_MESSAGE is ignored when --message is provided)
        git commit ${NO_VERIFY:+--no-verify} ${COMMIT_SIGN:+-S} -m "$msg"
        echo -e "${GREEN}Created commit${RESET}" >&2
    fi
}

# Function to create git tag
create_tag() {
    local tag_name="${TAG_PREFIX}${NEW_VERSION}"
    
    # Guard against accidental re-tag on same commit
    if git rev-parse -q --verify "$tag_name" >/dev/null; then
        if ! git rev-parse "$tag_name^{commit}" | grep -qx "$(git rev-parse HEAD)"; then
            echo -e "${RED}Error: tag $tag_name exists but not on HEAD.${RESET}" >&2
            exit 1
        fi
        echo -e "${YELLOW}Tag $tag_name already exists${RESET}" >&2
        return 0
    fi
    
    if $SIGNED_TAG; then
        git tag -s "$tag_name" -m "Release ${TAG_PREFIX}${NEW_VERSION}"
        echo -e "${GREEN}Created signed tag: $tag_name${RESET}" >&2
    elif $ANNOTATED_TAG; then
        git tag -a "$tag_name" -m "Release ${TAG_PREFIX}${NEW_VERSION}"
        echo -e "${GREEN}Created annotated tag: $tag_name${RESET}" >&2
    else
        git tag "$tag_name"
        echo -e "${GREEN}Created lightweight tag: $tag_name${RESET}" >&2
    fi
    
    echo -e "${GREEN}Tag created: $tag_name${RESET}" >&2
}

# Function to sanitize TAG_PREFIX for use in git tag patterns
sanitize_tag_prefix() {
    local p="$1"
    p="${p//\\/\\\\}"   # backslash -> \\ 
    p="${p//\*/\\*}"    # * -> \*
    p="${p//\?/\\?}"    # ? -> \?
    p="${p//\[/\\[}"    # [ -> \[ (fixed escaping)
    p="${p//\]/\\]}"    # ] -> \] (fixed escaping)
    printf '%s' "$p"
}

# Function to check if new version is greater than last tag
check_version_order() {
    local last_tag
    local sanitized_prefix
    sanitized_prefix=$(sanitize_tag_prefix "$TAG_PREFIX")
    last_tag=$(git tag --list "${sanitized_prefix}[0-9]*.[0-9]*.[0-9]*" --sort=-v:refname | head -n1)
    
    if [[ -n "$last_tag" ]]; then
        # Remove tag prefix for comparison
        local last_version="${last_tag:${#TAG_PREFIX}}"
        if [[ ! "$last_version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            return 0  # Skip comparison if last tag format is unexpected
        fi
        
        # Parse NEW_VERSION components for comparison
        IFS='.' read -r new_major new_minor new_patch <<< "$NEW_VERSION"
        IFS='.' read -r last_major last_minor last_patch <<< "$last_version"
        
        local version_not_greater=false
        if [[ "$NEW_VERSION" == "$last_version" ]] || 
           [[ "$new_major" -lt "$last_major" ]] ||
           ([[ "$new_major" -eq "$last_major" ]] && [[ "$new_minor" -lt "$last_minor" ]]) ||
           ([[ "$new_major" -eq "$last_major" ]] && [[ "$new_minor" -eq "$last_minor" ]] && [[ "$new_patch" -le "$last_patch" ]]); then
            version_not_greater=true
        fi
        
        if $version_not_greater; then
            echo -e "${YELLOW}Warning:${RESET} New version $NEW_VERSION is not greater than last tag $last_tag${RESET}" >&2
            
            # Enforce version order in CI
            if [[ -n "${GITHUB_ACTIONS:-}" ]]; then
                echo -e "${RED}Error: NEW_VERSION ($NEW_VERSION) must be greater than last tag ($last_tag)${RESET}" >&2
                exit 1
            fi
        fi
    fi
}

# Parse command line arguments
BUMP_TYPE=""
DO_COMMIT=false
DO_TAG=false
DRY_RUN=false
PRINT_ONLY=false

while [[ $# -gt 0 ]]; do
    case "$1" in
        major|minor|patch)
            if [[ -n "$BUMP_TYPE" ]]; then
                echo -e "${RED}Error: Multiple bump types specified${RESET}" >&2
                exit 1
            fi
            BUMP_TYPE="$1"
            shift
            ;;
        --commit)
            DO_COMMIT=true
            shift
            ;;
        --tag)
            DO_TAG=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --print)
            PRINT_ONLY=true
            shift
            ;;
        --message)
            COMMIT_MSG="${2-}"
            shift 2
            ;;
        --allow-dirty)
            ALLOW_DIRTY=true
            shift
            ;;
        --lightweight-tag)
            ANNOTATED_TAG=false
            shift
            ;;
        --signed-tag)
            SIGNED_TAG=true
            ANNOTATED_TAG=false  # signed tags are always annotated
            shift
            ;;
        --sign-commit)
            COMMIT_SIGN=true
            shift
            ;;
        --no-verify)
            NO_VERIFY=true
            shift
            ;;
        --no-cmake)
            UPDATE_CMAKE=false
            shift
            ;;
        --tag-prefix)
            TAG_PREFIX="${2-}"
            shift 2
            ;;
        --set)
            SET_VERSION="${2-}"
            shift 2
            ;;
        -h|--help)
            usage | sed "s/CURRENT_VERSION_PLACEHOLDER/$CURRENT_VERSION/"
            exit 0
            ;;
        *)
            echo -e "${RED}Error: Unknown option '$1'${RESET}" >&2
            usage | sed "s/CURRENT_VERSION_PLACEHOLDER/$CURRENT_VERSION/"
            exit 1
            ;;
    esac
done

# Check if bump type was specified (unless using --set)
if [[ -z "$BUMP_TYPE" && -z "$SET_VERSION" ]]; then
    echo -e "${RED}Error: No bump type specified and no --set version provided${RESET}" >&2
    usage | sed "s/CURRENT_VERSION_PLACEHOLDER/$CURRENT_VERSION/"
    exit 1
fi

# Handle --set option
if [[ -n "$SET_VERSION" ]]; then
    validate_version_format "$SET_VERSION"
    NEW_VERSION="$SET_VERSION"
    BUMP_TYPE="set"  # for display purposes
else
    # Perform the version bump
    echo -e "${CYAN}Bumping version from $CURRENT_VERSION...${RESET}" >&2
    bump_version "$BUMP_TYPE"
fi

# Check for conflicting options
if [[ "$DRY_RUN" == "true" && "$PRINT_ONLY" == "true" ]]; then
    echo -e "${RED}Error: --dry-run and --print cannot be used together${RESET}" >&2
    exit 1
fi

# Check if we're in a git repository
if [[ "$DO_COMMIT" == "true" || "$DO_TAG" == "true" ]]; then
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo -e "${RED}Error: Not in a git repository${RESET}" >&2
        exit 1
    fi
fi

# Check for detached HEAD if committing or tagging
if [[ "$DO_COMMIT" == "true" || "$DO_TAG" == "true" ]]; then
    if ! git symbolic-ref -q HEAD >/dev/null; then
        echo -e "${RED}Error:${RESET} detached HEAD; checkout a branch before committing/tagging." >&2
        exit 1
    fi
fi

# Fail fast if VERSION is untracked
if [[ "$DO_COMMIT" == "true" || "$DO_TAG" == "true" ]]; then
    if ! git ls-files --error-unmatch -- "$VERSION_FILE" >/dev/null 2>&1; then
        echo -e "${RED}Error: VERSION is not tracked by git${RESET}" >&2
        exit 1
    fi
fi

# Check signed tag prerequisites
if $SIGNED_TAG && ! git config --get user.signingkey >/dev/null; then
    echo -e "${YELLOW}Warning:${RESET} --signed-tag requested but no user.signingkey is configured. Tag creation may fail." >&2
    # Fail in CI for signed tags without key
    if [[ -n "${GITHUB_ACTIONS:-}" ]]; then
        echo -e "${RED}Error:${RESET} --signed-tag requested in CI but no user.signingkey configured." >&2
        exit 1
    fi
fi

# Check signed commit prerequisites
if $COMMIT_SIGN && ! git config --get user.signingkey >/dev/null; then
    echo -e "${YELLOW}Warning:${RESET} --sign-commit requested but no user.signingkey is configured. Commit signing may fail." >&2
    # Fail in CI for signed commits without key
    if [[ -n "${GITHUB_ACTIONS:-}" ]]; then
        echo -e "${RED}Error:${RESET} --sign-commit requested in CI but no user.signingkey configured." >&2
        exit 1
    fi
fi

# Add GPG_TTY hint for interactive signed tags/commits
if $SIGNED_TAG || $COMMIT_SIGN; then
    [[ -t 1 && -z "${GPG_TTY:-}" ]] && echo -e "${YELLOW}Hint:${RESET} export GPG_TTY=$(tty) may be required for pinentry." >&2
fi

# Protect against concurrent edits (local use)
if $DO_COMMIT && ! $ALLOW_DIRTY && ! git diff --quiet --no-ext-diff; then
    echo -e "${RED}Error:${RESET} working tree has unstaged changes; use --allow-dirty to override." >&2
    exit 1
fi

# Safer dirty-tree guard using pathspec exclusion (for both commit and tag)
if ([[ "$DO_COMMIT" == "true" ]] || [[ "$DO_TAG" == "true" ]]) && ! $ALLOW_DIRTY; then
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo -e "${RED}Error: Not in a git repository${RESET}" >&2
        exit 1
    fi
    if ! git diff --quiet -- . ':(exclude)VERSION' ':(exclude)CMakeLists.txt'; then
        echo -e "${RED}Error:${RESET} working tree has changes other than VERSION and CMakeLists.txt. Use --allow-dirty to override." >&2
        exit 1
    fi
fi

# No-op guard if version unchanged
if [[ "$CURRENT_VERSION" == "$NEW_VERSION" ]]; then
    echo -e "${YELLOW}Version unchanged ($CURRENT_VERSION); nothing to do.${RESET}" >&2
    exit 0
fi

# Handle print-only mode
if [[ "$PRINT_ONLY" == "true" ]]; then
    echo "$NEW_VERSION"
    exit 0
fi

# Handle dry-run mode
if [[ "$DRY_RUN" == "true" ]]; then
    echo -e "${YELLOW}DRY RUN: Would update VERSION file to $NEW_VERSION${RESET}" >&2
    if $UPDATE_CMAKE; then
        echo -e "${YELLOW}DRY RUN: Would update CMakeLists.txt to $NEW_VERSION${RESET}" >&2
    else
        echo -e "${YELLOW}DRY RUN: Would skip CMakeLists.txt update (--no-cmake)${RESET}" >&2
    fi
    if $DO_TAG; then
        echo -e "${YELLOW}DRY RUN: Would create tag: ${TAG_PREFIX}${NEW_VERSION}${RESET}" >&2
        # Show last detected tag for comparison
        local sanitized_prefix last_tag
        sanitized_prefix=$(sanitize_tag_prefix "$TAG_PREFIX")
        last_tag=$(git tag --list "${sanitized_prefix}[0-9]*.[0-9]*.[0-9]*" --sort=-v:refname | head -n1)
        if [[ -n "$last_tag" ]]; then
            echo -e "${YELLOW}DRY RUN: Last tag for comparison: $last_tag${RESET}" >&2
        fi
    fi
    exit 0
fi

update_version_file

# Update CMake only if requested (default true)
if $UPDATE_CMAKE; then
    update_cmake_version
else
    echo -e "${YELLOW}Skipped CMakeLists.txt update (--no-cmake)${RESET}" >&2
fi

# Create commit if requested
if [[ "$DO_COMMIT" == "true" ]]; then
    create_commit
fi

# Create tag if requested
if [[ "$DO_TAG" == "true" ]]; then
    # Warn if tagging without committing and files have changes
    if [[ "$DO_COMMIT" != "true" ]]; then
        files_to_check=("$VERSION_FILE")
        $UPDATE_CMAKE && files_to_check+=("$PROJECT_ROOT/CMakeLists.txt")
        
        if ! git diff --quiet -- "${files_to_check[@]}"; then
            echo -e "${YELLOW}Warning:${RESET} Tagging without --commit; ensure the version bump commit is pushed before the tag so CI/release matches the version." >&2
        fi
        
        # Additional warning for any uncommitted changes
        if ! git diff --quiet --name-only; then
            echo -e "${YELLOW}Warning:${RESET} There are uncommitted changes; tag may not reflect working tree." >&2
        fi
    fi
    
    # Check version order before creating tag
    check_version_order
    
    create_tag
fi

echo -e "${GREEN}Version bump completed: $CURRENT_VERSION → $NEW_VERSION${RESET}" >&2

# Show next steps
if [[ "$DO_TAG" == "true" ]]; then
    echo -e "${YELLOW}Next steps:${RESET}" >&2
    current_branch="$(git rev-parse --abbrev-ref HEAD)"
    echo -e "  git push origin ${current_branch}" >&2
    echo -e "  git push origin ${TAG_PREFIX}${NEW_VERSION}" >&2
fi

# Print the new version for callers
echo "$NEW_VERSION" 
