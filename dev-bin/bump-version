#!/bin/bash
# Copyright © 2025 Eser KUBALI <lxldev.contact@gmail.com>
# SPDX-License-Identifier: GPL-3.0-or-later
#
# This file is part of vglog-filter and is licensed under
# the GNU General Public License v3.0 or later.
# See the LICENSE file in the project root for details.
#
# Core version bump orchestrator for vglog-filter
# Modular version of the original bump-version script

set -euo pipefail

# Source utilities
SCRIPT_DIR="$(dirname "$(realpath "$0")")"
source "$SCRIPT_DIR/version-utils"

# --- Initialize and setup ----------------------------------------------------
setup_environment() {
    # Initialize colors
    init_colors "${NO_COLOR:-false}"
    
    # Resolve paths
    resolve_script_paths "$0" "${REPO_ROOT:-}"
    
    # Store original project root for semantic analyzer
    ORIGINAL_PROJECT_ROOT="$PROJECT_ROOT"
    
    # Setup cleanup
    setup_cleanup "TMP_FILE"
    
    # Check dependencies
    require_cmd
}

# --- Version file operations -------------------------------------------------
handle_version_file() {
    local version_exists="false"
    local current_version="none"
    
    if [[ -f "$VERSION_FILE" ]]; then
        version_exists="true"
        validate_version_file_path "$VERSION_FILE" "$PROJECT_ROOT"
        current_version=$(read_version_file "$VERSION_FILE")
        
        if ! is_semver "$current_version"; then
            die "Invalid version format in VERSION: $current_version"
            printf '%s\n' "${YELLOW}Expected: MAJOR.MINOR.PATCH${RESET}" >&2
            exit 1
        fi
    elif [[ -n "${SET_VERSION:-}" ]]; then
        printf '%s\n' "${YELLOW}Note: VERSION not found; will create with $SET_VERSION${RESET}" >&2
    else
        die "VERSION file not found at $VERSION_FILE"
        printf '%s\n' "${YELLOW}Use --set VERSION to create it${RESET}" >&2
        exit 1
    fi
    
    printf '%s\n%s' "$version_exists" "$current_version"
}

# --- Version calculation ----------------------------------------------------
calculate_new_version() {
    local current_version="$1"
    local bump_type="${BUMP_TYPE:-}"
    local set_version="${SET_VERSION:-}"
    
    if [[ -n "$set_version" ]]; then
        validate_version_format "$set_version" "${ALLOW_PRERELEASE:-false}"
        printf '%s' "$set_version"
    else
        [[ -z "$bump_type" ]] && die "No bump type specified"
        printf '%s\n' "${CYAN}Bumping version from $current_version...${RESET}" >&2
        
        # Use the LOC-based calculator
        local new_version
        local calculator_args=(
            --current-version "$current_version"
            --bump-type "$bump_type"
            --original-project-root "$ORIGINAL_PROJECT_ROOT"
        )
        if [[ -n "${REPO_ROOT:-}" ]]; then
            calculator_args+=(--repo-root "${REPO_ROOT}")
        fi
        
        new_version=$("$SCRIPT_DIR/version-calculator-loc" "${calculator_args[@]}")
        
        printf '%s' "$new_version"
    fi
}

# --- File updates -----------------------------------------------------------
update_files() {
    local new_version="$1"
    local current_version="$2"
    
    # Update VERSION file
    if [[ "$new_version" != *-* ]]; then
        safe_write_file "$VERSION_FILE" "$new_version"
        TMP_FILE_VAR="TMP_FILE"
        
        if [[ "$current_version" == "none" ]]; then
            success "Created VERSION file: $new_version"
        else
            success "Updated VERSION file: $current_version → $new_version"
        fi
    else
        warn "Pre-release $new_version - not writing to VERSION file"
        printf '%s\n' "${CYAN}Pre-release versions should not be stored in VERSION file${RESET}" >&2
    fi
    
    # Update CMakeLists.txt
    if [[ "${UPDATE_CMAKE:-true}" == "true" ]]; then
        if [[ "${DRY_RUN:-false}" == "true" ]]; then
            "$SCRIPT_DIR/cmake-updater" simulate \
                "$PROJECT_ROOT/CMakeLists.txt" \
                "$new_version"
        else
            "$SCRIPT_DIR/cmake-updater" update \
                "$PROJECT_ROOT/CMakeLists.txt" \
                "$new_version"
        fi
    fi
}

# --- Git operations ---------------------------------------------------------
perform_git_operations() {
    local new_version="$1"
    local current_version="$2"
    
    if [[ "${DO_COMMIT:-false}" == "true" || "${DO_TAG:-false}" == "true" || "${DO_PUSH:-false}" == "true" || "${PUSH_TAGS:-false}" == "true" ]]; then
        "$SCRIPT_DIR/git-operations" perform_git_operations \
            "$VERSION_FILE" \
            "${UPDATE_CMAKE:-true}" \
            "$new_version" \
            "$current_version" \
            "${DO_COMMIT:-false}" \
            "${DO_TAG:-false}" \
            "${DO_PUSH:-false}" \
            "${PUSH_TAGS:-false}" \
            "${COMMIT_MSG:-}" \
            "${NO_VERIFY:-false}" \
            "${COMMIT_SIGN:-false}" \
            "${TAG_PREFIX:-v}" \
            "${ANNOTATED_TAG:-true}" \
            "${SIGNED_TAG:-false}" \
            "${ALLOW_DIRTY:-false}" \
            "$PROJECT_ROOT" \
            "$ORIGINAL_PROJECT_ROOT" \
            "${REMOTE:-origin}" \
            "${ALLOW_NONMONOTONIC_TAG:-false}"
    fi
}

# --- Dry run simulation -----------------------------------------------------
simulate_dry_run() {
    local new_version="$1"
    local current_version="$2"
    local version_exists="$3"
    
    if [[ "$current_version" == "none" ]]; then
        if [[ "$new_version" == *-* ]]; then
            printf '%s\n' "${YELLOW}DRY RUN: Would print pre-release $new_version (not write VERSION)${RESET}" >&2
        else
            printf '%s\n' "${YELLOW}DRY RUN: Would create VERSION with $new_version${RESET}" >&2
        fi
    else
        if [[ "$new_version" == *-* ]]; then
            printf '%s\n' "${YELLOW}DRY RUN: Would print pre-release $new_version (not update VERSION)${RESET}" >&2
        else
            printf '%s\n' "${YELLOW}DRY RUN: Would update VERSION to $new_version${RESET}" >&2
        fi
    fi
    
    # Simulate CMake update
    "$SCRIPT_DIR/cmake-updater" simulate \
        "$PROJECT_ROOT/CMakeLists.txt" \
        "$new_version"
    
    # Simulate git operations
    if [[ "${DO_COMMIT:-false}" == "true" ]]; then
        printf '%s\n' "${YELLOW}DRY RUN: Would create commit: chore(release): ${TAG_PREFIX:-v}${new_version}${RESET}" >&2
        local effective_files=()
        [[ "$new_version" != *-* ]] && effective_files+=("VERSION")
        if [[ "${UPDATE_CMAKE:-true}" == "true" && "$new_version" != *-* ]]; then
            if "$SCRIPT_DIR/cmake-updater" detect_cmake_version_format "$PROJECT_ROOT/CMakeLists.txt" | grep -q "variable"; then
                # Skip CMakeLists.txt since it uses VERSION file variable
                :
            elif "$SCRIPT_DIR/cmake-updater" detect_cmake_version_format "$PROJECT_ROOT/CMakeLists.txt" | grep -q -E "(inline|set)"; then
                effective_files+=("CMakeLists.txt")
            fi
        fi
        if ((${#effective_files[@]} > 0)); then
            printf '%s\n' "${YELLOW}DRY RUN: Would commit files: ${effective_files[*]}${RESET}" >&2
        else
            printf '%s\n' "${YELLOW}DRY RUN: Would skip commit (no files to commit)${RESET}" >&2
        fi
    fi
    
    if [[ "${DO_TAG:-false}" == "true" ]]; then
        if [[ "$new_version" == *-* ]]; then
            printf '%s\n' "${YELLOW}DRY RUN: Would block tag creation for pre-release $new_version${RESET}" >&2
        else
            printf '%s\n' "${YELLOW}DRY RUN: Would create tag: ${TAG_PREFIX:-v}${new_version}${RESET}" >&2
        fi
        local last_tag
        last_tag=$("$SCRIPT_DIR/version-utils" last-tag "${TAG_PREFIX:-v}")
        if [[ -n "$last_tag" ]]; then
            printf '%s\n' "${YELLOW}DRY RUN: Last tag for comparison: $last_tag${RESET}" >&2
        fi
    fi
    
    # Print the computed version to stdout for pipelines
    printf '%s\n' "$new_version"
}

# --- Print only mode --------------------------------------------------------
handle_print_only() {
    local set_version="${SET_VERSION:-}"
    local bump_type="${BUMP_TYPE:-}"
    
    if [[ -n "$set_version" ]]; then
        validate_version_format "$set_version" "${ALLOW_PRERELEASE:-false}"
        printf '%s\n' "$set_version"
        exit 0
    elif [[ -n "$bump_type" && -f "$VERSION_FILE" ]]; then
        local current_version
        current_version=$(read_version_file "$VERSION_FILE")
        if is_semver "$current_version"; then
            local new_version
            local calculator_args=(
                --current-version "$current_version"
                --bump-type "$bump_type"
                --original-project-root "$ORIGINAL_PROJECT_ROOT"
            )
            if [[ -n "${REPO_ROOT:-}" ]]; then
                calculator_args+=(--repo-root "${REPO_ROOT}")
            fi
            
            new_version=$("$SCRIPT_DIR/version-calculator-loc" "${calculator_args[@]}")
            printf '%s\n' "$new_version"
            exit 0
        fi
    fi
    
    die "Cannot compute version for --print. Provide --set VERSION or a bump type with existing VERSION file."
}

# --- Main orchestration function --------------------------------------------
main() {
    # Handle help case early
    if [[ "$1" == "--help" || "$1" == "-h" ]]; then
        "$SCRIPT_DIR/cli-parser" help
        exit 0
    fi
    
    # Parse CLI arguments and source variables
    eval "$("$SCRIPT_DIR/cli-parser" parse "$@")"
    
    # Setup environment
    setup_environment
    
    # Handle print-only mode early
    if [[ "${PRINT_ONLY:-false}" == "true" ]]; then
        handle_print_only
    fi
    
    # Handle version file
    local version_info
    version_info=$(handle_version_file)
    local version_exists="${version_info%$'\n'*}"
    local current_version="${version_info#*$'\n'}"
    
    # Calculate new version
    local new_version
    new_version=$(calculate_new_version "$current_version")
    
    # No-op guard
    if [[ "$current_version" == "$new_version" ]]; then
        printf '%s\n' "${YELLOW}Version unchanged ($current_version); nothing to do.${RESET}" >&2
        printf '%s\n' "$new_version"
        exit 0
    fi
    
    # Handle dry run
    if [[ "${DRY_RUN:-false}" == "true" ]]; then
        simulate_dry_run "$new_version" "$current_version" "$version_exists"
        exit 0
    fi
    
    # Update files
    update_files "$new_version" "$current_version"
    
    # Perform git operations
    perform_git_operations "$new_version" "$current_version"
    
    # Warn about order for --set when not tagging
    if [[ -n "${SET_VERSION:-}" && "${DO_TAG:-false}" != "true" && "$new_version" != *-* ]]; then
        local last_tag
        last_tag=$("$SCRIPT_DIR/version-utils" last-tag "${TAG_PREFIX:-v}")
        if [[ -n "$last_tag" ]]; then
            local last_version="${last_tag:${#TAG_PREFIX:-v}}"
            if is_semver "$last_version"; then
                if ! "$SCRIPT_DIR/version-validator" is_version_greater "$new_version" "$last_version"; then
                    warn "--set version $new_version is not greater than last tag $last_tag"
                fi
            fi
        fi
    fi
    
    # Success message
    if [[ "$current_version" == "none" ]]; then
        success "Version bump completed: created $new_version"
    else
        success "Version bump completed: $current_version → $new_version"
    fi
    
    # Next steps
    if [[ "${DO_TAG:-false}" == "true" ]]; then
        printf '%s\n' "${YELLOW}Next steps:${RESET}" >&2
        local current_branch
        current_branch="$(git rev-parse --abbrev-ref HEAD)"
        printf '%s\n' "  git push ${REMOTE:-origin} ${current_branch}" >&2
        printf '%s\n' "  git push ${REMOTE:-origin} ${TAG_PREFIX:-v}${new_version}" >&2
    fi
    
    # Print the new version on stdout for scripting
    printf '%s\n' "$new_version"
}

# --- Script execution -------------------------------------------------------
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi 