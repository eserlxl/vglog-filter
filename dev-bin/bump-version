#!/bin/bash
# Copyright © 2025 Eser KUBALI <lxldev.contact@gmail.com>
# SPDX-License-Identifier: GPL-3.0-or-later
#
# This file is part of vglog-filter and is licensed under
# the GNU General Public License v3.0 or later.
# See the LICENSE file in the project root for details.
#
# Version bump script for vglog-filter
# Usage: ./dev-bin/bump-version [major|minor|patch] [--commit] [--tag] [--dry-run] [--message MSG] [--allow-dirty] [--lightweight-tag] [--signed-tag] [--no-verify] [--print] [--no-cmake] [--tag-prefix PREFIX] [--sign-commit] [--set VERSION] [--no-color] [--push] [--push-tags]

set -euo pipefail

# Ensure consistent locale and behavior
export LC_ALL=C

# Set predictable file permissions
umask 022

# Get script directory and project root
SCRIPT_DIR="$(dirname "$(realpath "$0")")"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
VERSION_FILE="$PROJECT_ROOT/VERSION"

# Change to project root for git operations
cd "$PROJECT_ROOT"

# Track temp file for cleanup
TMP_FILE=""

# Trap to clean temp files on interrupt/exit
trap '[[ -n "$TMP_FILE" ]] && rm -f "$TMP_FILE" 2>/dev/null || true' INT TERM EXIT

# New options vars
COMMIT_MSG=""
ALLOW_DIRTY="false"
ANNOTATED_TAG="true"    # default to annotated tag
SIGNED_TAG="false"      # default to unsigned tag
COMMIT_SIGN="false"     # default to unsigned commit
NO_VERIFY="false"       # default to running hooks
UPDATE_CMAKE="true"     # default to updating CMake
TAG_PREFIX="${TAG_PREFIX:-v}"  # default tag prefix, can be overridden by env var
SET_VERSION=""        # for --set option
NO_COLOR="false"      # for --no-color option
DO_PUSH="false"       # for --push option
PUSH_TAGS="false"     # for --push-tags option
ALLOW_NONMONOTONIC_TAG="false"  # for --allow-nonmonotonic-tag option
ALLOW_PRERELEASE="false"  # for --allow-prerelease option
REPO_ROOT=""          # for --repo-root option

# Colors will be initialized after argument parsing
RED=''
GREEN=''
YELLOW=''
CYAN=''
RESET=''

# Function to check for dirty tree with proper exclusions
check_dirty_tree() {
    # For prerelease versions, we don't write to VERSION file, so exclude it from dirty check
    local exclude_paths=()
    if [[ "$NEW_VERSION" == *-* ]]; then
        exclude_paths+=("VERSION")
    fi
    if [[ "$UPDATE_CMAKE" != "true" ]]; then
        exclude_paths+=("CMakeLists.txt")
    fi
    
    # Build git diff arguments as array for safety
    local diff_args=(-- .)
    for path in "${exclude_paths[@]}"; do
        diff_args+=(":(exclude)$path")
    done
    
    # Check for changes excluding the specified files
    if ! git diff --quiet "${diff_args[@]}"; then
        local suffix=""
        if [[ "$NEW_VERSION" != *-* ]]; then
            suffix="VERSION"
            if [[ "$UPDATE_CMAKE" != "true" ]]; then
                suffix+=" and CMakeLists.txt"
            fi
        elif [[ "$UPDATE_CMAKE" != "true" ]]; then
            suffix="CMakeLists.txt"
        fi
        
        if [[ -n "$suffix" ]]; then
            printf '%s\n' "${RED}Error:${RESET} working tree has changes other than ${suffix}. Use --allow-dirty to override." >&2
        else
            printf '%s\n' "${RED}Error:${RESET} working tree has changes. Use --allow-dirty to override." >&2
        fi
        exit 1
    fi
    
    # Optional warning for untracked files
    if git ls-files --others --exclude-standard | grep -q .; then
        printf '%s\n' "${YELLOW}Warning:${RESET} untracked files present (ignored)." >&2
    fi
}

# Function to validate version format (tightened SemVer)
validate_version_format() {
    local version="$1"
    local allow_prerelease="$2"
    
    if [[ "$allow_prerelease" == "true" ]]; then
        # Allow prerelease format: X.Y.Z-rc.1, X.Y.Z-alpha.1, etc.
        if [[ ! "$version" =~ ^(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)(-[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?$ ]]; then
            printf '%s\n' "${RED}Error: Invalid version format: $version${RESET}" >&2
            printf '%s\n' "${YELLOW}Expected format: MAJOR.MINOR.PATCH or MAJOR.MINOR.PATCH-PRERELEASE (e.g., 1.0.0 or 1.0.0-rc.1)${RESET}" >&2
            printf '%s\n' "${YELLOW}Note: Leading zeros are not allowed (e.g., 01.02.03 is invalid)${RESET}" >&2
            exit 1
        fi
    else
        # Standard format only
        if [[ ! "$version" =~ ^(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)$ ]]; then
            printf '%s\n' "${RED}Error: Invalid version format: $version${RESET}" >&2
            printf '%s\n' "${YELLOW}Expected format: MAJOR.MINOR.PATCH (e.g., 1.0.0)${RESET}" >&2
            printf '%s\n' "${YELLOW}Note: Leading zeros are not allowed (e.g., 01.02.03 is invalid)${RESET}" >&2
            printf '%s\n' "${YELLOW}Note: Pre-releases are not supported by default. Use --allow-prerelease for --set only.${RESET}" >&2
            exit 1
        fi
    fi
}

# Function to bump version
bump_version() {
    local bump_type="$1"
    local current_major current_minor current_patch
    local new_major new_minor new_patch
    
    # Parse current version components
    IFS='.' read -r current_major current_minor current_patch <<< "$CURRENT_VERSION"
    
    case "$bump_type" in
        major)
            new_major=$((current_major + 1))
            new_minor=0
            new_patch=0
            ;;
        minor)
            new_major=$current_major
            new_minor=$((current_minor + 1))
            new_patch=0
            ;;
        patch)
            new_major=$current_major
            new_minor=$current_minor
            new_patch=$((current_patch + 1))
            ;;
        *)
            printf '%s\n' "${RED}Error: Invalid bump type '$bump_type'${RESET}" >&2
            printf '%s\n' "${YELLOW}Valid types: major, minor, patch${RESET}" >&2
            exit 1
            ;;
    esac
    
    NEW_VERSION="$new_major.$new_minor.$new_patch"
}

# Function to update VERSION file with atomic write
update_version_file() {
    # For prerelease versions, only print and don't write to VERSION file
    if [[ "$NEW_VERSION" == *-* ]]; then
        printf '%s\n' "${YELLOW}Note: Pre-release version $NEW_VERSION - not writing to VERSION file${RESET}" >&2
        printf '%s\n' "${CYAN}Pre-release versions should not be stored in VERSION file${RESET}" >&2
        return 0
    fi
    
    TMP_FILE="${VERSION_FILE}.tmp.$$"
    printf '%s\n' "$NEW_VERSION" > "$TMP_FILE"
    sync -f "$TMP_FILE" 2>/dev/null || sync "$TMP_FILE" 2>/dev/null || true
    mv -f "$TMP_FILE" "$VERSION_FILE"
    sync -f "$VERSION_FILE" 2>/dev/null || sync -f "$(dirname "$VERSION_FILE")" 2>/dev/null || sync || true
    TMP_FILE=""
    if [[ "$CURRENT_VERSION" == "none" ]]; then
        printf '%s\n' "${GREEN}Created VERSION file: $NEW_VERSION${RESET}" >&2
    else
        printf '%s\n' "${GREEN}Updated VERSION file: $CURRENT_VERSION → $NEW_VERSION${RESET}" >&2
    fi
}

# Function to update CMakeLists.txt if it contains version information
update_cmake_version() {
    # Skip CMake updates for prerelease versions
    if [[ "$NEW_VERSION" == *-* ]]; then
        printf '%s\n' "${YELLOW}Note: Skipping CMakeLists.txt update for pre-release version${RESET}" >&2
        return 0
    fi
    
    local cmake="$PROJECT_ROOT/CMakeLists.txt"
    [[ -f "$cmake" ]] || return 0
    local before after

    before="$(sha1sum "$cmake" | awk '{print $1}')"
    if grep -Eq '^[[:space:]]*project\([^)]*VERSION[[:space:]]+[0-9]+\.[0-9]+\.[0-9]+' "$cmake"; then
        sed -E -i "s/(^[[:space:]]*project\([^)]*VERSION[[:space:]]+)[0-9]+\.[0-9]+\.[0-9]+/\1${NEW_VERSION}/" "$cmake"
    elif grep -Eq '^[[:space:]]*set[[:space:]]*\([[:space:]]*PROJECT_VERSION[[:space:]]+"?[0-9]+\.[0-9]+\.[0-9]+' "$cmake"; then
        sed -E -i "s/(^[[:space:]]*set[[:space:]]*\([[:space:]]*PROJECT_VERSION[[:space:]]+\"?)[0-9]+\.[0-9]+\.[0-9]+/\1${NEW_VERSION}/" "$cmake"
    else
        printf '%s\n' "${YELLOW}Note: CMakeLists.txt present but no recognizable version field to update${RESET}" >&2
        return 0
    fi
    after="$(sha1sum "$cmake" | awk '{print $1}')"
    if [[ "$before" != "$after" ]]; then
        printf '%s\n' "${GREEN}Updated CMakeLists.txt to ${NEW_VERSION}${RESET}" >&2
        git add -- "$cmake"
    fi
}

# Function to stage files for commit
stage_files() {
    # Stage VERSION file (skip for prereleases)
    [[ "$NEW_VERSION" != *-* ]] && git add -- "$VERSION_FILE"
    
    # When UPDATE_CMAKE is false and --allow-dirty is off, ensure CMakeLists.txt is not staged
    if [[ "$UPDATE_CMAKE" != "true" && "$ALLOW_DIRTY" != "true" ]]; then
        git reset -- "$PROJECT_ROOT/CMakeLists.txt" 2>/dev/null || true
    fi
}

# Function to check git identity
check_git_identity() {
    if ! git config --get user.name >/dev/null; then
        printf '%s\n' "${YELLOW}Warning: git user.name is not set${RESET}" >&2
    fi
    if ! git config --get user.email >/dev/null; then
        printf '%s\n' "${YELLOW}Warning: git user.email is not set${RESET}" >&2
    fi
}

# Function to create git commit
create_commit() {
    stage_files
    
    # update_cmake_version may have already staged CMakeLists.txt
    if git diff --cached --quiet; then
        if [[ "$NEW_VERSION" == *-* ]]; then
            printf '%s\n' "${YELLOW}Skipping commit: pre-release made no file changes${RESET}" >&2
        else
            printf '%s\n' "${YELLOW}No staged changes to commit${RESET}" >&2
        fi
        return 0
    fi
    
    # Check git identity before committing
    check_git_identity
    
    # Default conventional message if not provided
    local msg="${COMMIT_MSG}"
    if [[ -z "$msg" ]]; then
        # Use paragraph-style commit message
        local commit_args=(${NO_VERIFY:+--no-verify})
        commit_args+=(${COMMIT_SIGN:+-S})
        commit_args+=(-m "chore(release): ${TAG_PREFIX}${NEW_VERSION}${GITHUB_ACTIONS:+ [skip ci]}")
        if [[ "$CURRENT_VERSION" == "none" ]]; then
            commit_args+=(-m "bump: initial version ${NEW_VERSION}")
        else
            commit_args+=(-m "bump: ${CURRENT_VERSION} → ${NEW_VERSION}")
        fi
        
        # Append analysis if provided and no custom message
        if [[ -n "${ANALYSIS_MESSAGE:-}" ]]; then
            commit_args+=(-m "$ANALYSIS_MESSAGE")
        fi
        
        git commit "${commit_args[@]}"
        printf '%s\n' "${GREEN}Created commit${RESET}" >&2
        
        # Print commit SHA for traceability
        local commit_sha
        commit_sha=$(git rev-parse --short HEAD)
        printf '%s\n' "${CYAN}Commit SHA: $commit_sha${RESET}" >&2
    else
        # Use custom message (ANALYSIS_MESSAGE is ignored when --message is provided)
        git commit ${NO_VERIFY:+--no-verify} ${COMMIT_SIGN:+-S} -m "$msg"
        printf '%s\n' "${GREEN}Created commit${RESET}" >&2
        
        # Print commit SHA for traceability
        local commit_sha
        commit_sha=$(git rev-parse --short HEAD)
        printf '%s\n' "${CYAN}Commit SHA: $commit_sha${RESET}" >&2
    fi
}

# Function to create git tag
create_tag() {
    local tag_name="${TAG_PREFIX}${NEW_VERSION}"
    
    # Block tagging of prerelease versions
    if [[ "$NEW_VERSION" == *-* ]]; then
        printf '%s\n' "${RED}Error: Cannot create tag for pre-release version $NEW_VERSION${RESET}" >&2
        printf '%s\n' "${YELLOW}Pre-release versions should not be tagged${RESET}" >&2
        exit 1
    fi
    
    # Guard against accidental re-tag on same commit
    if git rev-parse -q --verify "$tag_name" >/dev/null; then
        if [[ "$(git rev-parse "$tag_name^{commit}")" != "$(git rev-parse HEAD)" ]]; then
            printf '%s\n' "${RED}Error: tag $tag_name exists but not on HEAD.${RESET}" >&2
            exit 1
        fi
        printf '%s\n' "${YELLOW}Tag $tag_name already exists${RESET}" >&2
        return 0
    fi
    
    if [[ "$SIGNED_TAG" == "true" ]]; then
        git tag -s "$tag_name" -m "Release ${NEW_VERSION}"
        printf '%s\n' "${GREEN}Created signed tag: $tag_name${RESET}" >&2
    elif [[ "$ANNOTATED_TAG" == "true" ]]; then
        git tag -a "$tag_name" -m "Release ${NEW_VERSION}"
        printf '%s\n' "${GREEN}Created annotated tag: $tag_name${RESET}" >&2
    else
        git tag "$tag_name"
        printf '%s\n' "${GREEN}Created lightweight tag: $tag_name${RESET}" >&2
    fi
    
    printf '%s\n' "${GREEN}Tag created: $tag_name${RESET}" >&2
    
    # Print tag SHA for traceability
    local tag_sha
    tag_sha=$(git rev-parse --short "$tag_name")
    printf '%s\n' "${CYAN}Tag SHA: $tag_sha${RESET}" >&2
}

# Function to sanitize TAG_PREFIX for use in git tag patterns
sanitize_tag_prefix() {
    local p="$1"
    p="${p//\\/\\\\}"   # backslash -> \\ 
    p="${p//\*/\\*}"    # * -> \*
    p="${p//\?/\\?}"    # ? -> \?
    p="${p//\[/\\[}"    # [ -> \[
    p="${p//\]/\\]}"    # ] -> \]
    printf '%s' "$p"
}

# Function to check if new version is greater than last tag
check_version_order() {
    local last_tag
    local sanitized_prefix
    sanitized_prefix=$(sanitize_tag_prefix "$TAG_PREFIX")
    last_tag=$(git tag --list "${sanitized_prefix}[0-9]*.[0-9]*.[0-9]*" --sort=-v:refname | head -n1)
    
    if [[ -n "$last_tag" ]]; then
        # Remove tag prefix for comparison
        local last_version="${last_tag:${#TAG_PREFIX}}"
        if [[ ! "$last_version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            return 0  # Skip comparison if last tag format is unexpected
        fi
        
        # Parse NEW_VERSION components for comparison
        IFS='.' read -r new_major new_minor new_patch <<< "$NEW_VERSION"
        IFS='.' read -r last_major last_minor last_patch <<< "$last_version"
        
        local version_not_greater="false"
        if [[ "$NEW_VERSION" == "$last_version" ]] || 
           [[ "$new_major" -lt "$last_major" ]] ||
           ([[ "$new_major" -eq "$last_major" ]] && [[ "$new_minor" -lt "$last_minor" ]]) ||
           ([[ "$new_major" -eq "$last_major" ]] && [[ "$new_minor" -eq "$last_minor" ]] && [[ "$new_patch" -le "$last_patch" ]]); then
            version_not_greater="true"
        fi
        
        if [[ "$version_not_greater" == "true" ]]; then
            printf '%s\n' "${YELLOW}Warning:${RESET} New version $NEW_VERSION is not greater than last tag $last_tag${RESET}" >&2
            
            # Enforce version order in CI unless override is set
            if [[ -n "${GITHUB_ACTIONS:-}" && "$ALLOW_NONMONOTONIC_TAG" != "true" ]]; then
                printf '%s\n' "${RED}Error: NEW_VERSION ($NEW_VERSION) must be greater than last tag ($last_tag)${RESET}" >&2
                printf '%s\n' "${YELLOW}Use --allow-nonmonotonic-tag to override this check${RESET}" >&2
                exit 1
            fi
        fi
    fi
}

# Function to show usage
usage() {
    # Get current version for help display
    local help_version="N/A"
    if [[ -f "$VERSION_FILE" ]]; then
        help_version=$(tr -d '[:space:]' < "$VERSION_FILE" 2>/dev/null || echo "N/A")
    fi
    cat << EOF
Usage: ./dev-bin/bump-version [major|minor|patch] [--commit] [--tag] [--dry-run] [--message MSG] [--allow-dirty] [--lightweight-tag] [--signed-tag] [--no-verify] [--print] [--no-cmake] [--tag-prefix PREFIX] [--sign-commit] [--set VERSION] [--no-color] [--push] [--push-tags] [--allow-nonmonotonic-tag] [--allow-prerelease] [--repo-root PATH]

Bump the semantic version of vglog-filter

Requirements:
  GNU tools on Linux: realpath, sha1sum, GNU sed, GNU grep
  Note: sync -f requires GNU coreutils (not BusyBox). For minimal containers,
        consider using sync without -f as fallback.
  macOS users: run in GNU coreutils + gsed environment (e.g., brew install coreutils gnu-sed)

Arguments:
  major    Increment major version (breaking changes)
  minor    Increment minor version (new features)
  patch    Increment patch version (bug fixes)

Options:
  --commit Create a git commit with the version bump
  --tag    Create a git tag for the new version
  --dry-run Show what would be done without making changes
  --print  Print the new version without making any changes
  --message MSG     Use MSG as the full commit message (overrides default)
                    Note: When --message is provided, ANALYSIS_MESSAGE is ignored
  --allow-dirty     Allow committing when other files are modified
  --lightweight-tag Create a lightweight tag instead of annotated
  --signed-tag      Create a signed tag (requires GPG key configured)
  --sign-commit     GPG-sign the commit (requires GPG key configured)
  --no-verify       Skip commit hooks (useful in CI environments)
  --no-cmake        Skip updating CMakeLists.txt version fields
  --tag-prefix PREFIX  Use PREFIX instead of 'v' for tag names (default: v)
                       Note: Empty prefix is allowed (tags like 1.2.3)
  --set VERSION     Set version to VERSION instead of bumping (format: X.Y.Z)
                    Note: Creates VERSION file if it doesn't exist
  --no-color        Disable colored output
  --push            Push changes and tags to remote repository
                    Note: --push only pushes the newly created tag, not all tags
  --push-tags       Push all tags to remote repository (bulk tag sync)
  --allow-nonmonotonic-tag  Allow setting version lower than last tag (bypasses CI check)
  --allow-prerelease Allow prerelease versions for --set only (e.g., 1.0.0-rc.1)
                    Note: Pre-releases are printed but not written to VERSION file
                    Note: Pre-releases cannot be tagged
  --repo-root PATH  Use PATH as repository root instead of auto-detection
                    Useful for mono-repos or CI working directories

Environment Variables:
  ANALYSIS_MESSAGE  Optional detailed analysis to include in commit message
                    (ignored when --message is provided)
  TAG_PREFIX       Default tag prefix (can be overridden by --tag-prefix)
                   Note: Glob characters (* ? [ ]) are supported and will be escaped for tag matching

CI Integration:
  When running in GitHub Actions and --message isn't provided, the script
  automatically appends [skip ci] to the default commit message to prevent
  other workflows from running.

Commit Message Consistency:
  The default commit subject uses the same prefix as tags:
  chore(release): <prefix><version>
  This ensures consistency between commit messages and tag names.

GPG Signing Notes:
  If commit.gpgSign=true is configured, --no-verify will skip hooks but
  still require GPG signing. Use --sign-commit explicitly if needed.

Examples:
  ./dev-bin/bump-version patch                    # Bump patch version
  ./dev-bin/bump-version minor --commit           # Bump minor version and commit
  ./dev-bin/bump-version major --commit --tag     # Bump major version, commit, and tag
  ./dev-bin/bump-version patch --dry-run          # Show what patch bump would do
  ./dev-bin/bump-version patch --print            # Print new version without changes
  ANALYSIS_MESSAGE='...' ./dev-bin/bump-version patch --commit  # Include analysis in commit
  ./dev-bin/bump-version patch --message 'Custom commit message' --commit  # Use custom message
  ./dev-bin/bump-version patch --signed-tag --tag # Create signed tag for provenance
  ./dev-bin/bump-version patch --sign-commit --commit # GPG-sign the commit
  ./dev-bin/bump-version patch --no-verify --commit # Skip commit hooks (useful in CI)
  ./dev-bin/bump-version patch --commit --signed-tag --no-verify --message 'chore(release): <prefix>X.Y.Z [skip ci]'  # Signed tag with CI
  ANALYSIS_MESSAGE='Auto version bump (push)' ./dev-bin/bump-version patch --commit --message 'chore(release): <prefix>X.Y.Z [skip ci]'  # CI usage
  ./dev-bin/bump-version patch --no-cmake         # Skip CMakeLists.txt updates
  ./dev-bin/bump-version patch --tag-prefix 'release-' --tag  # Create tag 'release-1.2.3'
  ./dev-bin/bump-version patch --tag-prefix '' --tag  # Create tag '1.2.3' (no prefix)
  TAG_PREFIX='ver' ./dev-bin/bump-version patch --tag  # Use environment variable for prefix
  ./dev-bin/bump-version --set 2.1.0 --commit     # Set version to 2.1.0 and commit
  ./dev-bin/bump-version patch --no-color          # Disable colored output
  ./dev-bin/bump-version patch --commit --tag --push # Bump, commit, tag, and push
  ./dev-bin/bump-version patch --commit --push     # Bump, commit, and push (branch only)
  ./dev-bin/bump-version patch --push-tags         # Push existing tags without creating new ones
  ./dev-bin/bump-version --set 1.0.0-rc.1 --allow-prerelease --print # Print prerelease version
  ./dev-bin/bump-version --set 1.0.0-rc.1 --allow-prerelease --commit # Set prerelease version
  ./dev-bin/bump-version --set 1.0.0 --allow-nonmonotonic-tag --commit # Override tag ordering
  ./dev-bin/bump-version patch --repo-root /path/to/repo --commit # Use custom repo root

Current version: $help_version
EOF
}

# Parse command line arguments
BUMP_TYPE=""
DO_COMMIT="false"
DO_TAG="false"
DRY_RUN="false"
PRINT_ONLY="false"

while [[ $# -gt 0 ]]; do
    case "$1" in
        major|minor|patch)
            if [[ -n "$BUMP_TYPE" ]]; then
                printf '%s\n' "${RED}Error: Multiple bump types specified${RESET}" >&2
                usage
                exit 1
            fi
            BUMP_TYPE="$1"
            shift
            ;;
        --commit)
            DO_COMMIT="true"
            shift
            ;;
        --tag)
            DO_TAG="true"
            shift
            ;;
        --dry-run)
            DRY_RUN="true"
            shift
            ;;
        --print)
            PRINT_ONLY="true"
            shift
            ;;
        --message)
            if [[ -z "${2-}" || "${2-}" == -* ]]; then
                printf '%s\n' "${RED}Error: --message requires a value${RESET}" >&2
                exit 1
            fi
            COMMIT_MSG="${2-}"
            shift 2
            ;;
        --allow-dirty)
            ALLOW_DIRTY="true"
            shift
            ;;
        --lightweight-tag)
            ANNOTATED_TAG="false"
            shift
            ;;
        --signed-tag)
            SIGNED_TAG="true"
            ANNOTATED_TAG="false"  # signed tags are always annotated
            shift
            ;;
        --sign-commit)
            COMMIT_SIGN="true"
            shift
            ;;
        --no-verify)
            NO_VERIFY="true"
            shift
            ;;
        --no-cmake)
            UPDATE_CMAKE="false"
            shift
            ;;
        --tag-prefix)
            if [[ -z "${2-}" || "${2-}" == -* ]]; then
                printf '%s\n' "${RED}Error: --tag-prefix requires a value${RESET}" >&2
                exit 1
            fi
            TAG_PREFIX="${2-}"
            shift 2
            ;;
        --set)
            if [[ -z "${2-}" || "${2-}" == -* ]]; then
                printf '%s\n' "${RED}Error: --set requires a value${RESET}" >&2
                exit 1
            fi
            SET_VERSION="${2-}"
            shift 2
            ;;
        --no-color)
            NO_COLOR="true"
            shift
            ;;
        --push)
            DO_PUSH="true"
            shift
            ;;
        --push-tags)
            PUSH_TAGS="true"
            shift
            ;;
        --allow-nonmonotonic-tag)
            ALLOW_NONMONOTONIC_TAG="true"
            shift
            ;;
        --allow-prerelease)
            ALLOW_PRERELEASE="true"
            shift
            ;;
        --repo-root)
            if [[ -z "${2-}" || "${2-}" == -* ]]; then
                printf '%s\n' "${RED}Error: --repo-root requires a value${RESET}" >&2
                exit 1
            fi
            REPO_ROOT="${2-}"
            shift 2
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            printf '%s\n' "${RED}Error: Unknown option '$1'${RESET}" >&2
            usage
            exit 1
            ;;
    esac
done

# Initialize colors based on --no-color
if [[ "$NO_COLOR" != "true" ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    CYAN='\033[0;36m'
    RESET='\033[0m'
fi

# Handle --repo-root option
if [[ -n "$REPO_ROOT" ]]; then
    if [[ ! -d "$REPO_ROOT" ]]; then
        printf '%s\n' "${RED}Error: Repository root '$REPO_ROOT' does not exist${RESET}" >&2
        exit 1
    fi
    PROJECT_ROOT="$REPO_ROOT"
    VERSION_FILE="$PROJECT_ROOT/VERSION"
    cd "$PROJECT_ROOT"
    printf '%s\n' "${CYAN}Using repository root: $PROJECT_ROOT${RESET}" >&2
fi

# Validate TAG_PREFIX content early
if [[ "$TAG_PREFIX" == *$'\n'* || "$TAG_PREFIX" == *$'\r'* ]]; then
    printf '%s\n' "${RED}Error: TAG_PREFIX contains newline characters${RESET}" >&2
    exit 1
fi

# Handle VERSION file checks after argument parsing
VERSION_EXISTS="false"
CURRENT_VERSION="none"

if [[ -f "$VERSION_FILE" ]]; then
    VERSION_EXISTS="true"
    
    # Validate VERSION symlink safety
    VERSION_REAL="$(readlink -f "$VERSION_FILE" 2>/dev/null || echo "")"
    if [[ -z "$VERSION_REAL" ]]; then
        printf '%s\n' "${RED}Error: VERSION path is a broken symlink${RESET}" >&2
        exit 1
    fi
    case "$VERSION_REAL" in 
        "$PROJECT_ROOT"/*) ;; 
        *) 
            printf '%s\n' "${RED}Error: VERSION resolves outside repo${RESET}" >&2
            exit 1
            ;;
    esac
    
    # Read current version and trim whitespace
    CURRENT_VERSION=$(tr -d '[:space:]' < "$VERSION_FILE")
    
    # Validate current version format (VERSION file should always be stable)
    if [[ ! "$CURRENT_VERSION" =~ ^(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)$ ]]; then
        printf '%s\n' "${RED}Error: Invalid version format in VERSION file: $CURRENT_VERSION${RESET}" >&2
        printf '%s\n' "${YELLOW}Expected format: MAJOR.MINOR.PATCH (e.g., 1.0.0)${RESET}" >&2
        printf '%s\n' "${YELLOW}Note: Leading zeros are not allowed (e.g., 01.02.03 is invalid)${RESET}" >&2
        exit 1
    fi
elif [[ -n "$SET_VERSION" ]]; then
    # Allow --set to create VERSION file if it doesn't exist
    printf '%s\n' "${YELLOW}Note: VERSION file not found, will create it with version $SET_VERSION${RESET}" >&2
else
    printf '%s\n' "${RED}Error: VERSION file not found at $VERSION_FILE${RESET}" >&2
    printf '%s\n' "${YELLOW}Use --set VERSION to create the file with a specific version${RESET}" >&2
    exit 1
fi

# Check if bump type was specified (unless using --set)
if [[ -z "$BUMP_TYPE" && -z "$SET_VERSION" ]]; then
    printf '%s\n' "${RED}Error: No bump type specified and no --set version provided${RESET}" >&2
    usage
    exit 1
fi

# Handle --set option
if [[ -n "$SET_VERSION" ]]; then
    validate_version_format "$SET_VERSION" "$ALLOW_PRERELEASE"
    NEW_VERSION="$SET_VERSION"
    BUMP_TYPE="set"  # for display purposes
else
    # Perform the version bump
    printf '%s\n' "${CYAN}Bumping version from $CURRENT_VERSION...${RESET}" >&2
    bump_version "$BUMP_TYPE"
fi

# Check for conflicting options
if [[ "$DRY_RUN" == "true" && "$PRINT_ONLY" == "true" ]]; then
    printf '%s\n' "${RED}Error: --dry-run and --print cannot be used together${RESET}" >&2
    exit 1
fi

# Check if we're in a git repository (centralized check)
IN_GIT_REPO="false"
if git rev-parse --git-dir >/dev/null 2>&1; then
    IN_GIT_REPO="true"
fi

# Check for detached HEAD if committing or tagging
if [[ "$DO_COMMIT" == "true" || "$DO_TAG" == "true" ]]; then
    if [[ "$IN_GIT_REPO" != "true" ]]; then
        printf '%s\n' "${RED}Error: Not in a git repository${RESET}" >&2
        exit 1
    fi
    if ! git symbolic-ref -q HEAD >/dev/null; then
        printf '%s\n' "${RED}Error:${RESET} detached HEAD; checkout a branch before committing/tagging." >&2
        exit 1
    fi
fi

# Fail fast if VERSION is untracked (only if it exists and we're committing/tagging)
if [[ "$DO_COMMIT" == "true" || "$DO_TAG" == "true" ]] && [[ "$VERSION_EXISTS" == "true" ]]; then
    if ! git ls-files --error-unmatch -- "$VERSION_FILE" >/dev/null 2>&1; then
        printf '%s\n' "${RED}Error: VERSION is not tracked by git${RESET}" >&2
        exit 1
    fi
fi

# Check signed tag prerequisites
if [[ "$SIGNED_TAG" == "true" ]] && ! git config --get user.signingkey >/dev/null; then
    printf '%s\n' "${YELLOW}Warning:${RESET} --signed-tag requested but no user.signingkey is configured. Tag creation may fail." >&2
    printf '%s\n' "${YELLOW}Source:${RESET} $(git config --show-origin --get user.signingkey || printf '%s\n' 'not configured')" >&2
    # Fail in CI for signed tags without key
    if [[ -n "${GITHUB_ACTIONS:-}" ]]; then
        printf '%s\n' "${RED}Error:${RESET} --signed-tag requested in CI but no user.signingkey configured." >&2
        exit 1
    fi
fi

# Check signed commit prerequisites
if [[ "$COMMIT_SIGN" == "true" ]] && ! git config --get user.signingkey >/dev/null; then
    printf '%s\n' "${YELLOW}Warning:${RESET} --sign-commit requested but no user.signingkey is configured. Commit signing may fail." >&2
    printf '%s\n' "${YELLOW}Source:${RESET} $(git config --show-origin --get user.signingkey || printf '%s\n' 'not configured')" >&2
    # Fail in CI for signed commits without key
    if [[ -n "${GITHUB_ACTIONS:-}" ]]; then
        printf '%s\n' "${RED}Error:${RESET} --sign-commit requested in CI but no user.signingkey configured." >&2
        exit 1
    fi
fi

# Add GPG_TTY hint for interactive signed tags/commits
if [[ "$SIGNED_TAG" == "true" || "$COMMIT_SIGN" == "true" ]]; then
    [[ -t 1 && -z "${GPG_TTY:-}" ]] && printf '%s\n' "${YELLOW}Hint:${RESET} export GPG_TTY=$(tty) may be required for pinentry." >&2
fi

# Add signing UX hint for commit.gpgSign=true
if [[ "$DO_COMMIT" == "true" && "$COMMIT_SIGN" != "true" ]] && git config --get commit.gpgSign >/dev/null; then
    printf '%s\n' "${YELLOW}Note:${RESET} commit.gpgSign=true is configured; Git may still sign commits even without --sign-commit." >&2
    printf '%s\n' "${YELLOW}Source:${RESET} $(git config --show-origin --get commit.gpgSign)" >&2
fi

# Refresh git index before diff checks to handle timestamp skew
if [[ "$DO_COMMIT" == "true" || "$DO_TAG" == "true" ]]; then
    git update-index -q --refresh || true
fi

# Protect against concurrent edits (local use)
if [[ "$DO_COMMIT" == "true" && "$ALLOW_DIRTY" != "true" ]] && ! git diff --quiet --no-ext-diff; then
    printf '%s\n' "${RED}Error:${RESET} working tree has unstaged changes; use --allow-dirty to override." >&2
    exit 1
fi

# Safer dirty-tree guard using pathspec exclusion (for both commit and tag)
if ([[ "$DO_COMMIT" == "true" ]] || [[ "$DO_TAG" == "true" ]]) && [[ "$ALLOW_DIRTY" != "true" ]]; then
    if [[ "$IN_GIT_REPO" != "true" ]]; then
        printf '%s\n' "${RED}Error: Not in a git repository${RESET}" >&2
        exit 1
    fi
    
    check_dirty_tree
fi

# Handle print-only mode
if [[ "$PRINT_ONLY" == "true" ]]; then
    printf '%s\n' "$NEW_VERSION"
    exit 0
fi

# No-op guard if version unchanged
if [[ "$CURRENT_VERSION" == "$NEW_VERSION" ]]; then
    printf '%s\n' "${YELLOW}Version unchanged ($CURRENT_VERSION); nothing to do.${RESET}" >&2
    exit 0
fi

# Handle dry-run mode
if [[ "$DRY_RUN" == "true" ]]; then
    if [[ "$CURRENT_VERSION" == "none" ]]; then
        if [[ "$NEW_VERSION" == *-* ]]; then
            printf '%s\n' "${YELLOW}DRY RUN: Would print pre-release version $NEW_VERSION (not write to VERSION)${RESET}" >&2
        else
            printf '%s\n' "${YELLOW}DRY RUN: Would create VERSION file with $NEW_VERSION${RESET}" >&2
        fi
    else
        if [[ "$NEW_VERSION" == *-* ]]; then
            printf '%s\n' "${YELLOW}DRY RUN: Would print pre-release version $NEW_VERSION (not update VERSION)${RESET}" >&2
        else
            printf '%s\n' "${YELLOW}DRY RUN: Would update VERSION file to $NEW_VERSION${RESET}" >&2
        fi
    fi
    if [[ "$UPDATE_CMAKE" == "true" ]]; then
        if [[ "$NEW_VERSION" == *-* ]]; then
            printf '%s\n' "${YELLOW}DRY RUN: Would skip CMakeLists.txt update (pre-release version)${RESET}" >&2
        else
            printf '%s\n' "${YELLOW}DRY RUN: Would update CMakeLists.txt to $NEW_VERSION${RESET}" >&2
        fi
    else
        printf '%s\n' "${YELLOW}DRY RUN: Would skip CMakeLists.txt update (--no-cmake)${RESET}" >&2
    fi
    if [[ "$DO_COMMIT" == "true" ]]; then
        printf '%s\n' "${YELLOW}DRY RUN: Would create commit: chore(release): ${TAG_PREFIX}${NEW_VERSION}${RESET}" >&2
    fi
    if [[ "$DO_TAG" == "true" ]]; then
        if [[ "$NEW_VERSION" == *-* ]]; then
            printf '%s\n' "${YELLOW}DRY RUN: Would block tag creation for pre-release version $NEW_VERSION${RESET}" >&2
        else
            printf '%s\n' "${YELLOW}DRY RUN: Would create tag: ${TAG_PREFIX}${NEW_VERSION}${RESET}" >&2
        fi
        # Show last detected tag for comparison
        sanitized_prefix=$(sanitize_tag_prefix "$TAG_PREFIX")
        last_tag=$(git tag --list "${sanitized_prefix}[0-9]*.[0-9]*.[0-9]*" --sort=-v:refname | head -n1)
        if [[ -n "$last_tag" ]]; then
            printf '%s\n' "${YELLOW}DRY RUN: Last tag for comparison: $last_tag${RESET}" >&2
            # Check if last tag points to HEAD
            if git rev-parse -q --verify "$last_tag" >/dev/null; then
                if [[ "$(git rev-parse "$last_tag^{commit}")" == "$(git rev-parse HEAD)" ]]; then
                    printf '%s\n' "${YELLOW}DRY RUN: Last tag points to HEAD${RESET}" >&2
                else
                    printf '%s\n' "${YELLOW}DRY RUN: Last tag does not point to HEAD${RESET}" >&2
                fi
            fi
        fi
    fi
    exit 0
fi

update_version_file

# Update CMake only if requested (default true)
if [[ "$UPDATE_CMAKE" == "true" ]]; then
    update_cmake_version
else
    printf '%s\n' "${YELLOW}Skipped CMakeLists.txt update (--no-cmake)${RESET}" >&2
fi

# Create commit if requested
if [[ "$DO_COMMIT" == "true" ]]; then
    create_commit
fi

# Create tag if requested
if [[ "$DO_TAG" == "true" ]]; then
    # Warn if tagging without committing and files have changes
    if [[ "$DO_COMMIT" != "true" ]]; then
        files_to_check=("$VERSION_FILE")
        [[ "$UPDATE_CMAKE" == "true" ]] && files_to_check+=("$PROJECT_ROOT/CMakeLists.txt")
        
        if ! git diff --quiet -- "${files_to_check[@]}"; then
            printf '%s\n' "${YELLOW}Warning:${RESET} Tagging without --commit; ensure the version bump commit is pushed before the tag so CI/release matches the version." >&2
        fi
        
        # Additional warning for any uncommitted changes
        if ! git diff --quiet --name-only; then
            printf '%s\n' "${YELLOW}Warning:${RESET} There are uncommitted changes; tag may not reflect working tree." >&2
        fi
    fi
    
    # Check version order before creating tag
    check_version_order
    
    create_tag
fi

# Warn about version ordering for --set even when not tagging
if [[ -n "$SET_VERSION" && "$DO_TAG" != "true" ]]; then
    sanitized_prefix=$(sanitize_tag_prefix "$TAG_PREFIX")
    last_tag=$(git tag --list "${sanitized_prefix}[0-9]*.[0-9]*.[0-9]*" --sort=-v:refname | head -n1)
    if [[ -n "$last_tag" ]]; then
        last_version="${last_tag:${#TAG_PREFIX}}"
        if [[ "$last_version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            IFS='.' read -r new_major new_minor new_patch <<< "$NEW_VERSION"
            IFS='.' read -r last_major last_minor last_patch <<< "$last_version"
            
            if [[ "$NEW_VERSION" == "$last_version" ]] || 
               [[ "$new_major" -lt "$last_major" ]] ||
               ([[ "$new_major" -eq "$last_major" ]] && [[ "$new_minor" -lt "$last_minor" ]]) ||
               ([[ "$new_major" -eq "$last_major" ]] && [[ "$new_minor" -eq "$last_minor" ]] && [[ "$new_patch" -le "$last_patch" ]]); then
                printf '%s\n' "${YELLOW}Warning:${RESET} --set version $NEW_VERSION is not greater than last tag $last_tag${RESET}" >&2
            fi
        fi
    fi
fi

if [[ "$CURRENT_VERSION" == "none" ]]; then
    printf '%s\n' "${GREEN}Version bump completed: created $NEW_VERSION${RESET}" >&2
else
    printf '%s\n' "${GREEN}Version bump completed: $CURRENT_VERSION → $NEW_VERSION${RESET}" >&2
fi

# Show next steps
if [[ "$DO_TAG" == "true" ]]; then
    printf '%s\n' "${YELLOW}Next steps:${RESET}" >&2
    current_branch="$(git rev-parse --abbrev-ref HEAD)"
    printf '%s\n' "  git push origin ${current_branch}" >&2
    printf '%s\n' "  git push origin ${TAG_PREFIX}${NEW_VERSION}" >&2
fi

# Handle --push option with improved robustness
if [[ "$DO_PUSH" == "true" ]]; then
    if [[ "$IN_GIT_REPO" != "true" ]]; then
        printf '%s\n' "${RED}Error: Not in a git repository${RESET}" >&2
        exit 1
    fi
    
    # Check for detached HEAD
    if ! git symbolic-ref -q HEAD >/dev/null; then
        printf '%s\n' "${RED}Error: Detached HEAD; checkout a branch before pushing${RESET}" >&2
        exit 1
    fi
    
    # Check that origin remote exists
    if ! git remote get-url origin >/dev/null 2>&1; then
        printf '%s\n' "${RED}Error: No remote 'origin' configured${RESET}" >&2
        exit 1
    fi
    
    current_branch="$(git rev-parse --abbrev-ref HEAD)"
    printf '%s\n' "${CYAN}Pushing changes...${RESET}" >&2
    
    # Push branch
    if ! git push origin "$current_branch"; then
        printf '%s\n' "${RED}Error: Failed to push branch $current_branch${RESET}" >&2
        exit 1
    fi
    
    # Push tag if created
    if [[ "$DO_TAG" == "true" ]]; then
        if ! git push origin "${TAG_PREFIX}${NEW_VERSION}"; then
            printf '%s\n' "${RED}Error: Failed to push tag ${TAG_PREFIX}${NEW_VERSION}${RESET}" >&2
            exit 1
        fi
    fi
    
    printf '%s\n' "${GREEN}Push completed${RESET}" >&2
fi

# Handle --push-tags option
if [[ "$PUSH_TAGS" == "true" ]]; then
    if [[ "$IN_GIT_REPO" != "true" ]]; then
        printf '%s\n' "${RED}Error: Not in a git repository${RESET}" >&2
        exit 1
    fi
    
    # Check that origin remote exists
    if ! git remote get-url origin >/dev/null 2>&1; then
        printf '%s\n' "${RED}Error: No remote 'origin' configured${RESET}" >&2
        exit 1
    fi
    
    printf '%s\n' "${CYAN}Pushing tags...${RESET}" >&2
    if ! git push origin --tags; then
        printf '%s\n' "${RED}Error: Failed to push tags${RESET}" >&2
        exit 1
    fi
    printf '%s\n' "${GREEN}Tags push completed${RESET}" >&2
fi

# Print diagnostic summary when operations were performed
if [[ "$DO_COMMIT" == "true" || "$DO_TAG" == "true" || "$DO_PUSH" == "true" || "$PUSH_TAGS" == "true" ]]; then
    printf '%s\n' "${CYAN}Summary:${RESET}" >&2
    if [[ "$DO_COMMIT" == "true" ]]; then
        commit_sha=$(git rev-parse --short HEAD)
        current_branch=$(git rev-parse --abbrev-ref HEAD)
        printf '%s\n' "  Branch: $current_branch" >&2
        printf '%s\n' "  Commit: $commit_sha" >&2
    fi
    if [[ "$DO_TAG" == "true" ]]; then
        tag_sha=$(git rev-parse --short "${TAG_PREFIX}${NEW_VERSION}")
        printf '%s\n' "  Tag: ${TAG_PREFIX}${NEW_VERSION}/$tag_sha" >&2
    fi
    if [[ "$DO_PUSH" == "true" ]]; then
        printf '%s\n' "  Pushed: yes" >&2
    elif [[ "$PUSH_TAGS" == "true" ]]; then
        printf '%s\n' "  Tags pushed: yes" >&2
    else
        printf '%s\n' "  Pushed: no" >&2
    fi
fi

# Print the new version for callers
printf '%s\n' "$NEW_VERSION" 
