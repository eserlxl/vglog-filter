#!/bin/bash
# Copyright © 2025 Eser KUBALI <lxldev.contact@gmail.com>
# SPDX-License-Identifier: GPL-3.0-or-later
#
# This file is part of vglog-filter and is licensed under
# the GNU General Public License v3.0 or later.
# See the LICENSE file in the project root for details.
#
# Version bump script for vglog-filter
# Usage: ./dev-bin/bump-version [major|minor|patch] [--commit] [--tag] [--dry-run] [--message MSG] [--allow-dirty] [--lightweight-tag] [--signed-tag] [--no-verify] [--print] [--no-cmake] [--tag-prefix PREFIX]

set -euo pipefail

# Ensure consistent locale and behavior
export LC_ALL=C

# Set predictable file permissions
umask 022

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
RESET='\033[0m'

# Get script directory and project root
SCRIPT_DIR="$(dirname "$(realpath "$0")")"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
VERSION_FILE="$PROJECT_ROOT/VERSION"

# Change to project root for git operations
cd "$PROJECT_ROOT"

# Track temp file for cleanup
TMP_FILE=""

# Trap to clean temp files on interrupt/exit
trap '[[ -n "$TMP_FILE" ]] && rm -f "$TMP_FILE" 2>/dev/null || true' INT TERM EXIT

# Check if VERSION file exists
if [[ ! -f "$VERSION_FILE" ]]; then
    echo -e "${RED}Error: VERSION file not found at $VERSION_FILE${RESET}" >&2
    exit 1
fi

# Read current version
CURRENT_VERSION=$(tr -d '[:space:]' < "$VERSION_FILE")

# Validate current version format
if [[ ! "$CURRENT_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    echo -e "${RED}Error: Invalid version format in VERSION file: $CURRENT_VERSION${RESET}" >&2
    echo -e "${YELLOW}Expected format: MAJOR.MINOR.PATCH (e.g., 1.0.0)${RESET}" >&2
    exit 1
fi

# Parse current version components
IFS='.' read -r CURRENT_MAJOR CURRENT_MINOR CURRENT_PATCH <<< "$CURRENT_VERSION"

# New options vars
COMMIT_MSG=""
ALLOW_DIRTY=false
ANNOTATED_TAG=true    # default to annotated tag
SIGNED_TAG=false      # default to unsigned tag
NO_VERIFY=false       # default to running hooks
UPDATE_CMAKE=true     # default to updating CMake
TAG_PREFIX="${TAG_PREFIX:-v}"  # default tag prefix, can be overridden by env var

# Function to show usage
usage() {
    echo "Usage: $0 [major|minor|patch] [--commit] [--tag] [--dry-run] [--message MSG] [--allow-dirty] [--lightweight-tag] [--signed-tag] [--no-verify] [--print] [--no-cmake] [--tag-prefix PREFIX]"
    echo ""
    echo "Bump the semantic version of vglog-filter"
    echo ""
    echo "Arguments:"
    echo "  major    Increment major version (breaking changes)"
    echo "  minor    Increment minor version (new features)"
    echo "  patch    Increment patch version (bug fixes)"
    echo ""
    echo "Options:"
    echo "  --commit Create a git commit with the version bump"
    echo "  --tag    Create a git tag for the new version"
    echo "  --dry-run Show what would be done without making changes"
    echo "  --print  Print the new version without making any changes"
    echo "  --message MSG     Use MSG as the full commit message (overrides default)"
    echo "                    Note: When --message is provided, ANALYSIS_MESSAGE is ignored"
    echo "  --allow-dirty     Allow committing when other files are modified"
    echo "  --lightweight-tag Create a lightweight tag instead of annotated"
    echo "  --signed-tag      Create a signed tag (requires GPG key configured)"
    echo "  --no-verify       Skip commit hooks (useful in CI environments)"
    echo "  --no-cmake        Skip updating CMakeLists.txt version fields"
    echo "  --tag-prefix PREFIX  Use PREFIX instead of 'v' for tag names (default: v)"
    echo ""
    echo "Environment Variables:"
    echo "  ANALYSIS_MESSAGE  Optional detailed analysis to include in commit message"
    echo "                    (ignored when --message is provided)"
    echo "  TAG_PREFIX       Default tag prefix (can be overridden by --tag-prefix)"
    echo ""
    echo "CI Integration:"
    echo "  When running in GitHub Actions and --message isn't provided, the script"
    echo "  automatically appends [skip ci] to the default commit message to prevent"
    echo "  other workflows from running."
    echo ""
    echo "Examples:"
    echo "  $0 patch                    # Bump patch version"
    echo "  $0 minor --commit           # Bump minor version and commit"
    echo "  $0 major --commit --tag     # Bump major version, commit, and tag"
    echo "  $0 patch --dry-run          # Show what patch bump would do"
    echo "  $0 patch --print            # Print new version without changes"
    echo "  ANALYSIS_MESSAGE='...' $0 patch --commit  # Include analysis in commit"
    echo "  $0 patch --message 'Custom commit message' --commit  # Use custom message"
    echo "  $0 patch --signed-tag --tag # Create signed tag for provenance"
    echo "  $0 patch --no-verify --commit # Skip commit hooks (useful in CI)"
    echo "  $0 patch --commit --signed-tag --no-verify --message 'chore(release): vX.Y.Z [skip ci]'  # Signed tag with CI"
    echo "  ANALYSIS_MESSAGE='Auto version bump (push)' $0 patch --commit --message 'chore(release): vX.Y.Z [skip ci]'  # CI usage"
    echo "  $0 patch --no-cmake         # Skip CMakeLists.txt updates"
    echo "  $0 patch --tag-prefix 'release-' --tag  # Create tag 'release-1.2.3'"
    echo "  TAG_PREFIX='ver' $0 patch --tag  # Use environment variable for prefix"
    echo ""
    echo "Current version: $CURRENT_VERSION"
}

# Function to bump version
bump_version() {
    local bump_type="$1"
    local new_major new_minor new_patch
    
    case "$bump_type" in
        major)
            new_major=$((CURRENT_MAJOR + 1))
            new_minor=0
            new_patch=0
            ;;
        minor)
            new_major=$CURRENT_MAJOR
            new_minor=$((CURRENT_MINOR + 1))
            new_patch=0
            ;;
        patch)
            new_major=$CURRENT_MAJOR
            new_minor=$CURRENT_MINOR
            new_patch=$((CURRENT_PATCH + 1))
            ;;
        *)
            echo -e "${RED}Error: Invalid bump type '$bump_type'${RESET}" >&2
            echo -e "${YELLOW}Valid types: major, minor, patch${RESET}" >&2
            exit 1
            ;;
    esac
    
    NEW_VERSION="$new_major.$new_minor.$new_patch"
}

# Function to update VERSION file with atomic write
update_version_file() {
    TMP_FILE="${VERSION_FILE}.tmp.$$"
    printf '%s\n' "$NEW_VERSION" > "$TMP_FILE"
    mv -f "$TMP_FILE" "$VERSION_FILE"
    echo -e "${GREEN}Updated VERSION file: $CURRENT_VERSION → $NEW_VERSION${RESET}"
}

# Function to update CMakeLists.txt if it contains version information
update_cmake_version() {
    local cmake="$PROJECT_ROOT/CMakeLists.txt"
    if [[ -f "$cmake" ]]; then
        # Update common patterns if present; otherwise just note it
        if grep -Eq 'project\([^)]*VERSION[[:space:]]+[0-9]+\.[0-9]+\.[0-9]+' "$cmake"; then
            sed -E -i "s/(project\([^)]*VERSION[[:space:]]+)[0-9]+\.[0-9]+\.[0-9]+/\1${NEW_VERSION}/" "$cmake"
            echo -e "${GREEN}Updated CMakeLists.txt project VERSION to ${NEW_VERSION}${RESET}"
        elif grep -Eq 'set[[:space:]]*\([[:space:]]*PROJECT_VERSION[[:space:]]+"?[0-9]+\.[0-9]+\.[0-9]+' "$cmake"; then
            sed -E -i "s/(set[[:space:]]*\([[:space:]]*PROJECT_VERSION[[:space:]]+"?)[0-9]+\.[0-9]+\.[0-9]+/\1${NEW_VERSION}/" "$cmake"
            echo -e "${GREEN}Updated CMake PROJECT_VERSION to ${NEW_VERSION}${RESET}"
        else
            echo -e "${YELLOW}Note: CMakeLists.txt present but no recognizable version field to update${RESET}"
        fi
    fi
}

# Function to stage files for commit
stage_files() {
    # Stage CMakeLists.txt if it exists and has changes
    if [[ -f "$PROJECT_ROOT/CMakeLists.txt" ]]; then
        git add -- "$PROJECT_ROOT/CMakeLists.txt" || true
    fi
    # Stage VERSION file
    git add -- "$VERSION_FILE"
}

# Function to check git identity
check_git_identity() {
    if ! git config --get user.name >/dev/null; then
        echo -e "${YELLOW}Warning: git user.name is not set${RESET}" >&2
    fi
    if ! git config --get user.email >/dev/null; then
        echo -e "${YELLOW}Warning: git user.email is not set${RESET}" >&2
    fi
}

# Function to create git commit
create_commit() {
    if ! git diff --quiet -- "$VERSION_FILE"; then
        stage_files
        
        # Check git identity before committing
        check_git_identity
        
        # Default conventional message if not provided
        local msg="${COMMIT_MSG}"
        if [[ -z "$msg" ]]; then
            # Use paragraph-style commit message
            local commit_args=(${NO_VERIFY:+--no-verify})
            commit_args+=(-m "chore(release): v${NEW_VERSION}${GITHUB_ACTIONS:+ [skip ci]}")
            commit_args+=(-m "bump: ${CURRENT_VERSION} → ${NEW_VERSION}")
            
            # Append analysis if provided and no custom message
            if [[ -n "${ANALYSIS_MESSAGE:-}" ]]; then
                commit_args+=(-m "$ANALYSIS_MESSAGE")
            fi
            
            git commit "${commit_args[@]}"
            echo -e "${GREEN}Created commit${RESET}"
        else
            # Use custom message (ANALYSIS_MESSAGE is ignored when --message is provided)
            git commit ${NO_VERIFY:+--no-verify} -m "$msg"
            echo -e "${GREEN}Created commit${RESET}"
        fi
    else
        echo -e "${YELLOW}No changes to commit${RESET}"
    fi
}

# Function to create git tag
create_tag() {
    local tag_name="${TAG_PREFIX}${NEW_VERSION}"
    
    if git rev-parse "$tag_name" >/dev/null 2>&1; then
        echo -e "${YELLOW}Tag $tag_name already exists${RESET}"
        return 0
    fi
    
    if $SIGNED_TAG; then
        git tag -s "$tag_name" -m "Release v$NEW_VERSION"
        echo -e "${GREEN}Created signed tag: $tag_name${RESET}"
    elif $ANNOTATED_TAG; then
        git tag -a "$tag_name" -m "Release v$NEW_VERSION"
        echo -e "${GREEN}Created annotated tag: $tag_name${RESET}"
    else
        git tag "$tag_name"
        echo -e "${GREEN}Created lightweight tag: $tag_name${RESET}"
    fi
}

# Function to check if new version is greater than last tag
check_version_order() {
    local last_tag
    last_tag=$(git tag --list "${TAG_PREFIX}[0-9]*.[0-9]*.[0-9]*" --sort=-v:refname | head -n1)
    
    if [[ -n "$last_tag" ]]; then
        # Remove tag prefix for comparison
        local last_version="${last_tag#${TAG_PREFIX}}"
        if [[ ! "$last_version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            return 0  # Skip comparison if last tag format is unexpected
        fi
        
        # Parse NEW_VERSION components for comparison
        IFS='.' read -r new_major new_minor new_patch <<< "$NEW_VERSION"
        IFS='.' read -r last_major last_minor last_patch <<< "$last_version"
        
        local version_not_greater=false
        if [[ "$NEW_VERSION" == "$last_version" ]] || 
           [[ "$new_major" -lt "$last_major" ]] ||
           ([[ "$new_major" -eq "$last_major" ]] && [[ "$new_minor" -lt "$last_minor" ]]) ||
           ([[ "$new_major" -eq "$last_major" ]] && [[ "$new_minor" -eq "$last_minor" ]] && [[ "$new_patch" -le "$last_patch" ]]); then
            version_not_greater=true
        fi
        
        if $version_not_greater; then
            echo -e "${YELLOW}Warning:${RESET} New version $NEW_VERSION is not greater than last tag $last_tag${RESET}" >&2
            
            # Enforce version order in CI
            if [[ -n "${GITHUB_ACTIONS:-}" ]]; then
                echo -e "${RED}Error: NEW_VERSION ($NEW_VERSION) must be greater than last tag ($last_tag)${RESET}" >&2
                exit 1
            fi
        fi
    fi
}

# Parse command line arguments
BUMP_TYPE=""
DO_COMMIT=false
DO_TAG=false
DRY_RUN=false
PRINT_ONLY=false

while [[ $# -gt 0 ]]; do
    case "$1" in
        major|minor|patch)
            if [[ -n "$BUMP_TYPE" ]]; then
                echo -e "${RED}Error: Multiple bump types specified${RESET}" >&2
                exit 1
            fi
            BUMP_TYPE="$1"
            shift
            ;;
        --commit)
            DO_COMMIT=true
            shift
            ;;
        --tag)
            DO_TAG=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --print)
            PRINT_ONLY=true
            shift
            ;;
        --message)
            COMMIT_MSG="${2-}"
            shift 2
            ;;
        --allow-dirty)
            ALLOW_DIRTY=true
            shift
            ;;
        --lightweight-tag)
            ANNOTATED_TAG=false
            shift
            ;;
        --signed-tag)
            SIGNED_TAG=true
            ANNOTATED_TAG=false  # signed tags are always annotated
            shift
            ;;
        --no-verify)
            NO_VERIFY=true
            shift
            ;;
        --no-cmake)
            UPDATE_CMAKE=false
            shift
            ;;
        --tag-prefix)
            TAG_PREFIX="${2-}"
            shift 2
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            echo -e "${RED}Error: Unknown option '$1'${RESET}" >&2
            usage
            exit 1
            ;;
    esac
done

# Check if bump type was specified
if [[ -z "$BUMP_TYPE" ]]; then
    echo -e "${RED}Error: No bump type specified${RESET}" >&2
    usage
    exit 1
fi

# Check for conflicting options
if [[ "$DRY_RUN" == "true" && "$PRINT_ONLY" == "true" ]]; then
    echo -e "${RED}Error: --dry-run and --print cannot be used together${RESET}" >&2
    exit 1
fi

# Check if we're in a git repository
if [[ "$DO_COMMIT" == "true" || "$DO_TAG" == "true" ]]; then
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo -e "${RED}Error: Not in a git repository${RESET}" >&2
        exit 1
    fi
fi

# Check for detached HEAD if committing or tagging
if [[ "$DO_COMMIT" == "true" || "$DO_TAG" == "true" ]]; then
    if ! git symbolic-ref -q HEAD >/dev/null; then
        echo -e "${RED}Error:${RESET} detached HEAD; checkout a branch before committing/tagging." >&2
        exit 1
    fi
fi

# Check signed tag prerequisites
if $SIGNED_TAG && ! git config --get user.signingkey >/dev/null; then
    echo -e "${YELLOW}Warning:${RESET} --signed-tag requested but no user.signingkey is configured. Tag creation may fail." >&2
fi

# Add GPG_TTY hint for interactive signed tags
if $SIGNED_TAG && [[ -t 1 && -z "${GPG_TTY:-}" ]]; then
    echo -e "${YELLOW}Hint:${RESET} export GPG_TTY=$(tty) may be required for pinentry." >&2
fi

# Safer dirty-tree guard using pathspec exclusion
if [[ "$DO_COMMIT" == "true" && "$ALLOW_DIRTY" == "false" ]]; then
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo -e "${RED}Error: Not in a git repository${RESET}" >&2
        exit 1
    fi
    if ! git diff --quiet -- . ':(exclude)VERSION' ':(exclude)CMakeLists.txt'; then
        echo -e "${RED}Error:${RESET} working tree has changes other than VERSION and CMakeLists.txt. Use --allow-dirty to override." >&2
        exit 1
    fi
fi

# Perform the version bump
echo -e "${CYAN}Bumping version from $CURRENT_VERSION...${RESET}"
bump_version "$BUMP_TYPE"

# No-op guard if version unchanged
if [[ "$CURRENT_VERSION" == "$NEW_VERSION" ]]; then
    echo -e "${YELLOW}Version unchanged ($CURRENT_VERSION); nothing to do.${RESET}"
    exit 0
fi

# Handle print-only mode
if [[ "$PRINT_ONLY" == "true" ]]; then
    echo "$NEW_VERSION"
    exit 0
fi

# Handle dry-run mode
if [[ "$DRY_RUN" == "true" ]]; then
    echo -e "${YELLOW}DRY RUN: Would update VERSION file to $NEW_VERSION${RESET}"
    if $UPDATE_CMAKE; then
        echo -e "${YELLOW}DRY RUN: Would update CMakeLists.txt to $NEW_VERSION${RESET}"
    else
        echo -e "${YELLOW}DRY RUN: Would skip CMakeLists.txt update (--no-cmake)${RESET}"
    fi
    exit 0
fi

update_version_file

# Update CMake only if requested (default true)
if $UPDATE_CMAKE; then
    update_cmake_version
else
    echo -e "${YELLOW}Skipped CMakeLists.txt update (--no-cmake)${RESET}"
fi

# Create commit if requested
if [[ "$DO_COMMIT" == "true" ]]; then
    create_commit
fi

# Create tag if requested
if [[ "$DO_TAG" == "true" ]]; then
    # Warn if tagging without committing and VERSION has changes
    if [[ "$DO_COMMIT" != "true" ]]; then
        if ! git diff --quiet -- "$VERSION_FILE"; then
            echo -e "${YELLOW}Warning:${RESET} Tagging without --commit; ensure the VERSION bump commit is pushed before the tag so CI/release matches the version." >&2
        fi
    fi
    
    # Check version order before creating tag
    check_version_order
    
    create_tag
fi

echo -e "${GREEN}Version bump completed: $CURRENT_VERSION → $NEW_VERSION${RESET}"

# Show next steps
if [[ "$DO_TAG" == "true" ]]; then
    echo -e "${YELLOW}Next steps:${RESET}"
    current_branch="$(git rev-parse --abbrev-ref HEAD)"
    echo -e "  git push origin ${current_branch}"
    echo -e "  git push origin ${TAG_PREFIX}${NEW_VERSION}"
fi

# Print the new version for callers
echo "$NEW_VERSION" 
