#!/bin/bash
# Copyright Â© 2025 Eser KUBALI <lxldev.contact@gmail.com>
# SPDX-License-Identifier: GPL-3.0-or-later
#
# This file is part of vglog-filter and is licensed under
# the GNU General Public License v3.0 or later.
# See the LICENSE file in the project root for details.
#
# Semantic Version Analyzer v2 for vglog-filter
# Orchestrates modular components for version analysis

set -Eeuo pipefail
IFS=$'\n\t'
export LC_ALL=C

show_help() {
    cat << EOF
Semantic Version Analyzer v2 for vglog-filter

Usage: $(basename "$0") [options]

Options:
  --since <tag>            Analyze changes since specific tag (default: last tag)
  --since-tag <tag>        Alias for --since
  --since-commit <hash>    Analyze changes since specific commit
  --since-date <date>      Analyze changes since specific date (YYYY-MM-DD)
  --base <ref>             Set base reference for comparison (default: auto-detected)
  --target <ref>           Set target reference for comparison (default: HEAD)
  --repo-root <path>       Set repository root directory
  --no-merge-base          Disable automatic merge-base detection for disjoint branches
  --only-paths <globs>     Restrict analysis to comma-separated path globs
  --ignore-whitespace      Ignore whitespace changes in diff analysis
  --verbose                Show detailed analysis
  --machine                Output machine-readable key=value format (SUGGESTION only)
  --json                   Output machine-readable JSON
  --suggest-only           Output only the suggestion (major/minor/patch/none)
  --strict-status          Use strict exit codes even with --suggest-only
  --help, -h               Show this help

Examples:
  $(basename "$0") --since v1.1.0
  $(basename "$0") --since-date 2025-01-01
  $(basename "$0") --base HEAD~5 --target HEAD
  $(basename "$0") --base v1.0.0 --target v1.1.0
  $(basename "$0") --only-paths "src/**,include/**"
  $(basename "$0") --verbose
  $(basename "$0") --machine
  $(basename "$0") --json

Exit codes:
  10 = major version bump suggested
  11 = minor version bump suggested
  12 = patch version bump suggested
  20 = no version bump suggested
EOF
}

# Parse arguments
SINCE_TAG=""
SINCE_COMMIT=""
SINCE_DATE=""
BASE_REF=""
TARGET_REF=""
REPO_ROOT=""
NO_MERGE_BASE=false
ONLY_PATHS=""
IGNORE_WHITESPACE=false
VERBOSE=false
MACHINE_OUTPUT=false
JSON_OUTPUT=false
SUGGEST_ONLY=false
STRICT_STATUS=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --since|--since-tag)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --since requires a value\n' >&2; exit 1; }
            SINCE_TAG="$2"; shift 2;;
        --since-commit)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --since-commit requires a value\n' >&2; exit 1; }
            SINCE_COMMIT="$2"; shift 2;;
        --since-date)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --since-date requires a value\n' >&2; exit 1; }
            SINCE_DATE="$2"; shift 2;;
        --base)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --base requires a value\n' >&2; exit 1; }
            BASE_REF="$2"; shift 2;;
        --target)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --target requires a value\n' >&2; exit 1; }
            TARGET_REF="$2"; shift 2;;
        --repo-root)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --repo-root requires a value\n' >&2; exit 1; }
            REPO_ROOT="$2"; shift 2;;
        --no-merge-base) NO_MERGE_BASE=true; shift;;
        --only-paths)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --only-paths requires a comma-separated globs list\n' >&2; exit 1; }
            ONLY_PATHS="$2"; shift 2;;
        --ignore-whitespace) IGNORE_WHITESPACE=true; shift;;
        --verbose) VERBOSE=true; shift;;
        --machine) MACHINE_OUTPUT=true; shift;;
        --json) JSON_OUTPUT=true; shift;;
        --suggest-only) SUGGEST_ONLY=true; shift;;
        --strict-status) STRICT_STATUS=true; shift;;
        --help|-h) show_help; exit 0;;
        *) printf 'Error: Unknown option: %s\n' "$1" >&2; show_help; exit 1;;
    esac
done

# Check if required binaries exist
check_binary() {
    local binary="$1"
    if [[ ! -x "$binary" ]]; then
        printf 'Error: Required binary not found: %s\n' "$binary" >&2
        exit 1
    fi
}

check_binary "./dev-bin/ref-resolver"
check_binary "./dev-bin/version-config-loader"
check_binary "./dev-bin/file-change-analyzer"
check_binary "./dev-bin/cli-options-analyzer"
check_binary "./dev-bin/security-keyword-analyzer"
check_binary "./dev-bin/version-calculator"

# Build common arguments for all components
build_common_args() {
    local args=""
    [[ -n "$BASE_REF" ]] && args="$args --base '$BASE_REF'"
    [[ -n "$TARGET_REF" ]] && args="$args --target '$TARGET_REF'"
    [[ -n "$REPO_ROOT" ]] && args="$args --repo-root '$REPO_ROOT'"
    [[ -n "$ONLY_PATHS" ]] && args="$args --only-paths '$ONLY_PATHS'"
    [[ "$IGNORE_WHITESPACE" = "true" ]] && args="$args --ignore-whitespace"
    [[ "$MACHINE_OUTPUT" = "true" ]] && args="$args --machine"
    [[ "$JSON_OUTPUT" = "true" ]] && args="$args --json"
    printf '%s' "$args"
}

# Build ref resolver arguments
build_ref_args() {
    local args=""
    [[ -n "$SINCE_TAG" ]] && args="$args --since '$SINCE_TAG'"
    [[ -n "$SINCE_COMMIT" ]] && args="$args --since-commit '$SINCE_COMMIT'"
    [[ -n "$SINCE_DATE" ]] && args="$args --since-date '$SINCE_DATE'"
    [[ -n "$BASE_REF" ]] && args="$args --base '$BASE_REF'"
    [[ -n "$TARGET_REF" ]] && args="$args --target '$TARGET_REF'"
    [[ -n "$REPO_ROOT" ]] && args="$args --repo-root '$REPO_ROOT'"
    [[ "$NO_MERGE_BASE" = "true" ]] && args="$args --no-merge-base"
    [[ "$MACHINE_OUTPUT" = "true" ]] && args="$args --machine"
    [[ "$JSON_OUTPUT" = "true" ]] && args="$args --json"
    printf '%s' "$args"
}

# Parse machine output into associative array
parse_machine_output() {
    local output="$1"
    local -A result
    while IFS='=' read -r key value; do
        [[ -n "$key" ]] && result["$key"]="$value"
    done <<< "$output"
    printf '%s' "$(declare -p result)"
}

# Main analysis function
main() {
    # Step 1: Resolve references
    [[ "$VERBOSE" = "true" ]] && printf 'Verbose: Resolving git references...\n' >&2
    local ref_args
    ref_args=$(build_ref_args)
    local ref_output
    ref_output=$(eval "./dev-bin/ref-resolver $ref_args")
    
    if [[ "$MACHINE_OUTPUT" = "true" ]]; then
        # Parse machine output
        local ref_data
        ref_data=$(parse_machine_output "$ref_output")
        eval "$ref_data"
        
        # Check if single commit repo
        if [[ "${result[SINGLE_COMMIT_REPO]:-false}" = "true" ]]; then
            printf 'SUGGESTION=none\n'
            exit 20
        fi
        
        # Check if no commits
        if [[ "${result[HAS_COMMITS]:-false}" = "false" ]]; then
            printf 'SUGGESTION=none\n'
            exit 20
        fi
        
        BASE_REF="${result[BASE_REF]}"
        TARGET_REF="${result[TARGET_REF]}"
    else
        # For non-machine output, extract base and target from JSON or parse output
        # This is a simplified version - in practice you'd parse JSON properly
        BASE_REF=$(printf '%s' "$ref_output" | grep -o '"base_ref":"[^"]*"' | cut -d'"' -f4 || echo "HEAD~1")
        TARGET_REF=$(printf '%s' "$ref_output" | grep -o '"target_ref":"[^"]*"' | cut -d'"' -f4 || echo "HEAD")
    fi
    
    # Step 2: Load configuration
    [[ "$VERBOSE" = "true" ]] && printf 'Verbose: Loading version configuration...\n' >&2
    local config_output
    config_output=$(./dev-bin/version-config-loader --machine)
    
    # Parse configuration output manually
    declare -A config_data
    while IFS='=' read -r key value; do
        [[ -n "$key" ]] && config_data["$key"]="$value"
    done <<< "$config_output"
    
    # Step 3: Analyze file changes
    [[ "$VERBOSE" = "true" ]] && printf 'Verbose: Analyzing file changes...\n' >&2
    local common_args
    common_args=$(build_common_args)
    local file_output
    file_output=$(eval "./dev-bin/file-change-analyzer $common_args")
    
    # Step 4: Analyze CLI options
    [[ "$VERBOSE" = "true" ]] && printf 'Verbose: Analyzing CLI options...\n' >&2
    local cli_output
    cli_output=$(eval "./dev-bin/cli-options-analyzer $common_args")
    
    # Step 5: Analyze security keywords
    [[ "$VERBOSE" = "true" ]] && printf 'Verbose: Analyzing security keywords...\n' >&2
    local security_output
    security_output=$(eval "./dev-bin/security-keyword-analyzer $common_args")
    
    # Parse all outputs
    local file_data cli_data security_data
    file_data=$(parse_machine_output "$file_output")
    cli_data=$(parse_machine_output "$cli_output")
    security_data=$(parse_machine_output "$security_output")
    
    # Initialize result arrays with defaults
    declare -A file_result cli_result security_result
    
    # Parse file analysis results
    if [[ -n "$file_data" ]]; then
        eval "$file_data"
        # Copy to file_result array
        for key in "${!result[@]}"; do
            file_result["$key"]="${result[$key]}"
        done
    fi
    
    # Parse CLI analysis results
    if [[ -n "$cli_data" ]]; then
        eval "$cli_data"
        # Copy to cli_result array
        for key in "${!result[@]}"; do
            cli_result["$key"]="${result[$key]}"
        done
    fi
    
    # Parse security analysis results
    if [[ -n "$security_data" ]]; then
        eval "$security_data"
        # Copy to security_result array
        for key in "${!result[@]}"; do
            security_result["$key"]="${result[$key]}"
        done
    fi
    
    # Step 6: Calculate bonus points
    local total_bonus=0
    
    # Breaking changes
    if [[ "${cli_result[BREAKING_CLI_CHANGES]:-false}" = "true" ]]; then
        total_bonus=$((total_bonus + ${config_data[VERSION_BREAKING_CLI_BONUS]:-2}))
    fi
    if [[ "${cli_result[API_BREAKING]:-false}" = "true" ]]; then
        total_bonus=$((total_bonus + ${config_data[VERSION_API_BREAKING_BONUS]:-3}))
    fi
    
    # Security keywords
    local security_keywords="${security_result[SECURITY_KEYWORDS]:-0}"
    if [[ "$security_keywords" -gt 0 ]]; then
        total_bonus=$((total_bonus + security_keywords * ${config_data[VERSION_SECURITY_BONUS]:-2}))
    fi
    
    # Feature additions
    if [[ "${cli_result[CLI_CHANGES]:-false}" = "true" ]]; then
        total_bonus=$((total_bonus + ${config_data[VERSION_CLI_CHANGES_BONUS]:-2}))
    fi
    if [[ "${cli_result[MANUAL_CLI_CHANGES]:-false}" = "true" ]]; then
        total_bonus=$((total_bonus + ${config_data[VERSION_MANUAL_CLI_BONUS]:-1}))
    fi
    if [[ "${file_result[NEW_SOURCE_FILES]:-0}" -gt 0 ]]; then
        total_bonus=$((total_bonus + ${config_data[VERSION_NEW_SOURCE_BONUS]:-1}))
    fi
    if [[ "${file_result[NEW_TEST_FILES]:-0}" -gt 0 ]]; then
        total_bonus=$((total_bonus + ${config_data[VERSION_NEW_TEST_BONUS]:-1}))
    fi
    if [[ "${file_result[NEW_DOC_FILES]:-0}" -gt 0 ]]; then
        total_bonus=$((total_bonus + ${config_data[VERSION_NEW_DOC_BONUS]:-1}))
    fi
    
    # Removed features
    if [[ "${cli_result[REMOVED_SHORT_COUNT]:-0}" -gt 0 ]] || [[ "${cli_result[REMOVED_LONG_COUNT]:-0}" -gt 0 ]]; then
        total_bonus=$((total_bonus + ${config_data[VERSION_REMOVED_OPTION_BONUS]:-1}))
    fi
    
    # Step 7: Determine suggestion based on bonus thresholds
    local major_threshold="${config_data[MAJOR_BONUS_THRESHOLD]:-8}"
    local minor_threshold="${config_data[MINOR_BONUS_THRESHOLD]:-4}"
    local patch_threshold="${config_data[PATCH_BONUS_THRESHOLD]:-0}"
    
    # Use default values if not available from config
    major_threshold="${major_threshold:-8}"
    minor_threshold="${minor_threshold:-4}"
    patch_threshold="${patch_threshold:-0}"
    
    local suggestion="none"
    if [[ "$total_bonus" -ge "$major_threshold" ]]; then
        suggestion="major"
    elif [[ "$total_bonus" -ge "$minor_threshold" ]]; then
        suggestion="minor"
    elif [[ "$total_bonus" -ge "$patch_threshold" ]]; then
        suggestion="patch"
    fi
    
    # Step 8: Get current version
    local current_version="0.0.0"
    if [[ -f "VERSION" ]]; then
        current_version=$(tr -d '[:space:]' < "VERSION" 2>/dev/null || printf '0.0.0')
        [[ $current_version =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]] || current_version=0.0.0
    fi
    
    # Step 9: Calculate next version if needed
    local next_version=""
    if [[ "$suggestion" != "none" ]]; then
        local calc_args="--current-version '$current_version' --bump-type '$suggestion' --loc '${file_result[DIFF_SIZE]:-0}' --bonus '$total_bonus'"
        [[ "$MACHINE_OUTPUT" = "true" ]] && calc_args="$calc_args --machine"
        [[ "$JSON_OUTPUT" = "true" ]] && calc_args="$calc_args --json"
        
        local calc_output
        calc_output=$(eval "./dev-bin/version-calculator $calc_args")
        
        if [[ "$MACHINE_OUTPUT" = "true" ]]; then
            local calc_data
            calc_data=$(parse_machine_output "$calc_output")
            eval "$calc_data"
            next_version="${result[NEXT_VERSION]}"
        else
            next_version=$(printf '%s' "$calc_output" | grep -o '"next_version":"[^"]*"' | cut -d'"' -f4 || echo "")
        fi
    fi
    
    # Step 10: Output results
    if [[ "$SUGGEST_ONLY" = "true" ]]; then
        printf '%s\n' "$suggestion"
    elif [[ "$JSON_OUTPUT" = "true" ]]; then
        printf '{\n'
        printf '  "suggestion": "%s",\n' "$suggestion"
        printf '  "current_version": "%s",\n' "$current_version"
        if [[ -n "$next_version" ]]; then
            printf '  "next_version": "%s",\n' "$next_version"
        fi
        printf '  "total_bonus": %s,\n' "$total_bonus"
        printf '  "base_ref": "%s",\n' "$BASE_REF"
        printf '  "target_ref": "%s",\n' "$TARGET_REF"
        printf '  "loc_delta": {\n'
        printf '    "patch_delta": %s,\n' "$(./dev-bin/version-calculator --current-version "$current_version" --bump-type patch --loc "${file_result[DIFF_SIZE]:-0}" --bonus "$total_bonus" --json 2>/dev/null | grep -o '"total_delta":[[:space:]]*[0-9]*' | cut -d: -f2 | tr -d ' ' || echo "1")"
        printf '    "minor_delta": %s,\n' "$(./dev-bin/version-calculator --current-version "$current_version" --bump-type minor --loc "${file_result[DIFF_SIZE]:-0}" --bonus "$total_bonus" --json 2>/dev/null | grep -o '"total_delta":[[:space:]]*[0-9]*' | cut -d: -f2 | tr -d ' ' || echo "5")"
        printf '    "major_delta": %s\n' "$(./dev-bin/version-calculator --current-version "$current_version" --bump-type major --loc "${file_result[DIFF_SIZE]:-0}" --bonus "$total_bonus" --json 2>/dev/null | grep -o '"total_delta":[[:space:]]*[0-9]*' | cut -d: -f2 | tr -d ' ' || echo "10")"
        printf '  }\n'
        printf '}\n'
    elif [[ "$MACHINE_OUTPUT" = "true" ]]; then
        printf 'SUGGESTION=%s\n' "$suggestion"
    else
        printf '=== Semantic Version Analysis v2 ===\n'
        printf 'Analyzing changes: %s -> %s\n' "$BASE_REF" "$TARGET_REF"
        printf '\nCurrent version: %s\n' "$current_version"
        printf 'Total bonus points: %s\n' "$total_bonus"
        printf '\nSuggested bump: %s\n' "$(printf '%s' "$suggestion" | tr '[:lower:]' '[:upper:]')"
        if [[ -n "$next_version" ]]; then
            printf 'Next version: %s\n' "$next_version"
        fi
        printf '\nSUGGESTION=%s\n' "$suggestion"
    fi
    
    # Set exit code
    if [[ "$SUGGEST_ONLY" = "true" ]] && [[ "$STRICT_STATUS" != "true" ]]; then
        exit 0
    else
        case "$suggestion" in
            major) exit 10 ;;
            minor) exit 11 ;;
            patch) exit 12 ;;
            none) exit 20 ;;
            *) exit 0 ;;
        esac
    fi
}

# Run main function
main "$@" 