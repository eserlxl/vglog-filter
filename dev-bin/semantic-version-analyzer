#!/bin/bash
# Copyright © 2025 Eser KUBALI <lxldev.contact@gmail.com>
# SPDX-License-Identifier: GPL-3.0-or-later
#
# This file is part of vglog-filter and is licensed under
# the GNU General Public License v3.0 or later.
# See the LICENSE file in the project root for details.
#
# Semantic Version Analyzer v3 for vglog-filter
# Simple, reliable version bumping based on actual code changes

set -Eeuo pipefail
IFS=$'\n\t'

show_help() {
    cat << EOF
Semantic Version Analyzer v3 for vglog-filter

Usage: $0 [options]

Options:
  --since <tag>     Analyze changes since specific tag (default: last tag)
  --since-commit <hash>  Analyze changes since specific commit
  --since-date <date>    Analyze changes since specific date (YYYY-MM-DD)
  --verbose         Show detailed analysis
  --suggest-only    Only show suggestion, don't analyze
  --json           Output machine-readable JSON
  --help            Show this help

Examples:
  $0 --since v1.1.0
  $0 --since-date 2025-01-01
  $0 --verbose

EOF
}

# Default values
SINCE_TAG=""
SINCE_COMMIT=""
SINCE_DATE=""
VERBOSE=false
SUGGEST_ONLY=false
JSON_OUTPUT=false

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --since)
            SINCE_TAG="$2"
            shift 2
            ;;
        --since-commit)
            SINCE_COMMIT="$2"
            shift 2
            ;;
        --since-date)
            SINCE_DATE="$2"
            shift 2
            ;;
        --verbose)
            VERBOSE=true
            shift
            ;;
        --suggest-only)
            SUGGEST_ONLY=true
            shift
            ;;
        --json)
            JSON_OUTPUT=true
            shift
            ;;
        --help|-h)
            show_help
            exit 0
            ;;
        *)
            printf 'Error: Unknown option: %s\n' "$1" >&2
            show_help
            exit 1
            ;;
    esac
done

# Validate git reference
verify_ref() {
    local ref="$1"
    if ! git rev-parse -q --verify "$ref^{commit}" >/dev/null; then
        printf 'Error: Invalid reference: %s\n' "$ref" >&2
        exit 1
    fi
}

# Determine the base for comparison
get_base_reference() {
    if [[ -n "$SINCE_COMMIT" ]]; then
        verify_ref "$SINCE_COMMIT"
        printf '%s' "$SINCE_COMMIT"
        return
    elif [[ -n "$SINCE_TAG" ]]; then
        verify_ref "$SINCE_TAG"
        printf '%s' "$SINCE_TAG"
        return
    elif [[ -n "$SINCE_DATE" ]]; then
        # Find the latest commit before the specified date
        local ref
        ref=$(git rev-list -1 --before="$SINCE_DATE 23:59:59" HEAD 2>/dev/null || true)
        if [[ -n "$ref" ]]; then
            printf '%s' "$ref"
        else
            printf 'Warning: No commits found before %s, using first commit\n' "$SINCE_DATE" >&2
            git rev-list --max-parents=0 HEAD
        fi
        return
    fi
    
    # Default to last tag
    local last_tag
    last_tag=$(git describe --tags --abbrev=0 2>/dev/null || true)
    if [[ -n "$last_tag" ]]; then
        printf '%s' "$last_tag"
    else
        # If no tags exist, use the first commit
        git rev-list --max-parents=0 HEAD
    fi
}

# Classify file path
classify_path() {
    local path="$1"
    # Skip vendor/build directories
    if [[ "$path" =~ ^(third_party|vendor|build|dist)/ ]]; then
        return 0
    fi
    
    # Source files (including headers)
    if [[ "$path" =~ \.(c|cc|cpp|cxx|h|hpp)$ ]] || [[ "$path" =~ ^src/ ]]; then
        return 30
    fi
    
    # Test files
    if [[ "$path" =~ ^tests/ ]]; then
        return 10
    fi
    
    # Documentation files
    if [[ "$path" =~ ^docs/ ]]; then
        return 20
    fi
    
    return 0
}

# CLI-focused analysis based on file changes and diff size
analyze_changes() {
    local base_ref="$1"
    
    # Check if there are any changes (but don't exit - we want to analyze even small changes)
    if git diff --quiet "$base_ref"..HEAD; then
        printf 'Warning: No changes detected since %s\n' "$base_ref" >&2
        # Continue with analysis anyway - might be edge cases
    fi
    
    local added_files=0
    local modified_files=0
    local deleted_files=0
    local new_source_files=0
    local new_test_files=0
    local new_doc_files=0
    local cli_changes=false
    local breaking_cli_changes=false
    
    # Process changes with NUL-delimited output to handle spaces and renames
    while IFS=$'\t' read -r -d '' status path1; do
        local file="$path1"
        
        # Handle renames and copies (R100/C100 format)
        if [[ "$status" =~ ^[RC] ]]; then
            IFS= read -r -d '' path2
            file="$path2"  # Use the new path for classification
        fi
        
        case "${status:0:1}" in
            A)
                ((added_files++))
                case $(classify_path "$file") in
                    30) ((new_source_files++)) ;;
                    10) ((new_test_files++)) ;;
                    20) ((new_doc_files++)) ;;
                esac
                ;;
            M)
                ((modified_files++))
                ;;
            D)
                ((deleted_files++))
                ;;
        esac
    done < <(git diff --name-status -z "$base_ref"..HEAD 2>/dev/null)
    
    # Improved CLI change detection with tighter patterns
    local srcdiff
    srcdiff=$(git diff "$base_ref"..HEAD -- src ':(glob)/*.[ch]pp' ':(glob)/*.[ch]' 2>/dev/null || true)
    
    if [[ -n "$srcdiff" ]]; then
        # Check for added CLI options
        if printf '%s' "$srcdiff" | grep -E '^\+.*\b(getopt|getopt_long)\b' >/dev/null 2>&1 || \
           printf '%s' "$srcdiff" | grep -E '^\+.*"--[A-Za-z0-9-]+"' >/dev/null 2>&1 || \
           printf '%s' "$srcdiff" | grep -E '^\+.*\bcase[[:space:]]+['"'"'"]?-[A-Za-z0-9]' >/dev/null 2>&1 || \
           printf '%s' "$srcdiff" | grep -E '^\+.*\b(struct[[:space:]]+option|long_options)\b' >/dev/null 2>&1; then
            cli_changes=true
        fi
        
        # Check for removed CLI options (breaking changes)
        local removed_cases
        local added_cases
        removed_cases=$(printf '%s' "$srcdiff" | grep -E '^-.*\bcase[[:space:]]+['"'"'"]?-[A-Za-z0-9]' 2>&1 | wc -l)
        added_cases=$(printf '%s' "$srcdiff" | grep -E '^\+.*\bcase[[:space:]]+['"'"'"]?-[A-Za-z0-9]' 2>&1 | wc -l)
        
        if [[ "$removed_cases" -gt 0 ]] && [[ "$added_cases" -eq 0 ]]; then
            breaking_cli_changes=true
        fi
    fi
    
    # Get diff size using numstat for reliable parsing
    local diff_size
    diff_size=$(git diff --numstat "$base_ref"..HEAD 2>&1 | awk '{a+=$1; d+=$2} END{print 0+a+d}' || echo "0")
    
    printf 'added_files=%s\n' "$added_files"
    printf 'modified_files=%s\n' "$modified_files"
    printf 'deleted_files=%s\n' "$deleted_files"
    printf 'new_source_files=%s\n' "$new_source_files"
    printf 'new_test_files=%s\n' "$new_test_files"
    printf 'new_doc_files=%s\n' "$new_doc_files"
    printf 'cli_changes=%s\n' "$cli_changes"
    printf 'breaking_cli_changes=%s\n' "$breaking_cli_changes"
    printf 'diff_size=%s\n' "$diff_size"
}

# Determine version bump suggestion based on CLI-focused rules
suggest_version_bump() {
    local added_files="$1"
    local modified_files="$2"
    local deleted_files="$3"
    local new_source_files="$4"
    local new_test_files="$5"
    local new_doc_files="$6"
    local cli_changes="$7"
    local breaking_cli_changes="$8"
    local diff_size="$9"
    
    # CLI-focused thresholds - only bump for significant changes
    if [[ "$breaking_cli_changes" = "true" ]] && [[ "${diff_size:-0}" -gt 500 ]]; then
        printf 'major'
    elif [[ "$cli_changes" = "true" ]] && [[ "${diff_size:-0}" -gt 800 ]]; then
        printf 'minor'
    elif [[ "${new_source_files:-0}" -gt 2 ]] && [[ "${diff_size:-0}" -gt 1000 ]]; then
        printf 'minor'
    elif [[ "${new_test_files:-0}" -gt 3 ]] && [[ "${diff_size:-0}" -gt 800 ]]; then
        printf 'minor'
    elif [[ "${new_doc_files:-0}" -gt 2 ]] && [[ "${diff_size:-0}" -gt 600 ]]; then
        printf 'minor'
    elif [[ "${modified_files:-0}" -gt 10 ]] && [[ "${diff_size:-0}" -gt 500 ]]; then
        printf 'patch'
    else
        printf 'none'
    fi
}

# Main analysis
main() {
    local base_ref
    base_ref=$(get_base_reference)
    
    if [[ "$SUGGEST_ONLY" = "true" ]]; then
        printf 'SUGGESTION=none\n'
        exit 0
    fi
    
    if [[ "$JSON_OUTPUT" = "false" ]]; then
        printf '=== Semantic Version Analysis v3 ===\n'
        printf 'Analyzing changes since: %s\n' "$base_ref"
        printf '\n'
        
        # Show base ref context in verbose mode
        if [[ "$VERBOSE" = "true" ]]; then
            local base_commit_info
            base_commit_info=$(git log -1 --format="%H %s (%ad)" --date=short "$base_ref" 2>/dev/null || printf 'Unknown')
            printf 'Base reference: %s\n' "$base_commit_info"
            printf '\n'
        fi
    fi
    
    # Get current version
    local current_version
    current_version=$(cat VERSION 2>/dev/null | tr -d '[:space:]' || printf '0.0.0')
    
    if [[ "$JSON_OUTPUT" = "false" ]]; then
        printf 'Current version: %s\n' "$current_version"
        printf '\n'
    fi
    
    # Analyze changes
    local analysis
    analysis=$(analyze_changes "$base_ref")
    local added_files
    added_files=$(printf '%s' "$analysis" | grep "added_files=" | cut -d'=' -f2)
    local modified_files
    modified_files=$(printf '%s' "$analysis" | grep "modified_files=" | cut -d'=' -f2)
    local deleted_files
    deleted_files=$(printf '%s' "$analysis" | grep "deleted_files=" | cut -d'=' -f2)
    local new_source_files
    new_source_files=$(printf '%s' "$analysis" | grep "new_source_files=" | cut -d'=' -f2)
    local new_test_files
    new_test_files=$(printf '%s' "$analysis" | grep "new_test_files=" | cut -d'=' -f2)
    local new_doc_files
    new_doc_files=$(printf '%s' "$analysis" | grep "new_doc_files=" | cut -d'=' -f2)
    local cli_changes
    cli_changes=$(printf '%s' "$analysis" | grep "cli_changes=" | cut -d'=' -f2)
    local breaking_cli_changes
    breaking_cli_changes=$(printf '%s' "$analysis" | grep "breaking_cli_changes=" | cut -d'=' -f2)
    local diff_size
    diff_size=$(printf '%s' "$analysis" | grep "diff_size=" | cut -d'=' -f2)
    
    # Show detailed analysis if verbose
    if [[ "$VERBOSE" = "true" ]] && [[ "$JSON_OUTPUT" = "false" ]]; then
        printf '=== Detailed Analysis ===\n'
        printf 'File changes:\n'
        printf '  Added files: %s\n' "$added_files"
        printf '  Modified files: %s\n' "$modified_files"
        printf '  Deleted files: %s\n' "$deleted_files"
        printf '\n'
        printf 'New content:\n'
        printf '  New source files: %s\n' "$new_source_files"
        printf '  New test files: %s\n' "$new_test_files"
        printf '  New doc files: %s\n' "$new_doc_files"
        printf '\n'
        printf 'CLI changes:\n'
        printf '  CLI interface changes: %s\n' "$cli_changes"
        printf '  Breaking CLI changes: %s\n' "$breaking_cli_changes"
        printf '\n'
        printf 'Change magnitude:\n'
        printf '  Diff size: %s lines\n' "$diff_size"
        printf '\n'
        printf 'Thresholds for auto-release (CLI-focused):\n'
        printf '  Major: Breaking CLI changes + diff > 500 lines\n'
        printf '  Minor: CLI interface changes + diff > 800 lines\n'
        printf '  Minor: New source files (>2) + diff > 1000 lines\n'
        printf '  Minor: New test files (>3) + diff > 800 lines\n'
        printf '  Minor: New doc files (>2) + diff > 600 lines\n'
        printf '  Patch: Modified files (>10) + diff > 500 lines\n'
        printf '\n'
        
        # Show recent commits
        printf 'Recent commits:\n'
        git log --oneline "$base_ref"..HEAD | head -10
        printf '\n'
    fi
    
    # Determine suggestion
    local suggestion
    suggestion=$(suggest_version_bump "$added_files" "$modified_files" "$deleted_files" "$new_source_files" "$new_test_files" "$new_doc_files" "$cli_changes" "$breaking_cli_changes" "$diff_size")
    
    # Get next version for preview
    local next_version=""
    case "$suggestion" in
        major)
            next_version=$(./dev-bin/bump-version major --print 2>/dev/null || printf 'X.0.0')
            ;;
        minor)
            next_version=$(./dev-bin/bump-version minor --print 2>/dev/null || printf '0.X.0')
            ;;
        patch)
            next_version=$(./dev-bin/bump-version patch --print 2>/dev/null || printf '0.0.X')
            ;;
        none)
            next_version=""
            ;;
    esac
    
    if [[ "$JSON_OUTPUT" = "true" ]]; then
        # JSON output for machine consumption
        printf '{\n'
        printf '  "suggestion": "%s",\n' "$suggestion"
        printf '  "current_version": "%s",\n' "$current_version"
        if [[ -n "$next_version" ]]; then
            printf '  "next_version": "%s",\n' "$next_version"
        fi
        printf '  "changes": {\n'
        printf '    "added_files": %s,\n' "$added_files"
        printf '    "modified_files": %s,\n' "$modified_files"
        printf '    "deleted_files": %s,\n' "$deleted_files"
        printf '    "new_source_files": %s,\n' "$new_source_files"
        printf '    "new_test_files": %s,\n' "$new_test_files"
        printf '    "new_doc_files": %s,\n' "$new_doc_files"
        printf '    "cli_changes": %s,\n' "$cli_changes"
        printf '    "breaking_cli_changes": %s,\n' "$breaking_cli_changes"
        printf '    "diff_size": %s\n' "$diff_size"
        printf '  }\n'
        printf '}\n'
    else
        printf '=== Version Bump Suggestion ===\n'
        case "$suggestion" in
            major)
                printf 'Suggested bump: MAJOR version\n'
                printf 'Reason: Breaking CLI changes with large code changes\n'
                printf 'Current: %s → New: %s\n' "$current_version" "$next_version"
                ;;
            minor)
                printf 'Suggested bump: MINOR version\n'
                printf 'Reason: New source files, tests, or documentation with significant changes\n'
                printf 'Current: %s → New: %s\n' "$current_version" "$next_version"
                ;;
            patch)
                printf 'Suggested bump: PATCH version\n'
                printf 'Reason: Significant modifications with large code changes\n'
                printf 'Current: %s → New: %s\n' "$current_version" "$next_version"
                ;;
            none)
                printf 'Suggested bump: NONE\n'
                printf 'Reason: No significant changes detected\n'
                ;;
        esac
        
        printf '\n'
        
        # Only show apply command if there's a suggestion
        if [[ "$suggestion" != "none" ]]; then
            printf 'To apply this suggestion:\n'
            printf '  ./dev-bin/bump-version %s --commit\n' "$suggestion"
            printf '\n'
            printf 'Or use GitHub Actions:\n'
            printf '  Go to Actions → Auto Version Bump → Run workflow → Choose: %s\n' "$suggestion"
        fi
        
        # Machine-readable output for CI
        printf 'SUGGESTION=%s\n' "$suggestion"
    fi
}

# Run main function
main "$@" 