#!/bin/bash
# Copyright Â© 2025 Eser KUBALI <lxldev.contact@gmail.com>
# SPDX-License-Identifier: GPL-3.0-or-later
#
# This file is part of vglog-filter and is licensed under
# the GNU General Public License v3.0 or later.
# See the LICENSE file in the project root for details.
#
# Semantic Version Analyzer for vglog-filter
# Simple, reliable version bumping based on actual code changes
# Note: Short option detection is byte-based; non-ASCII options not supported

set -Eeuo pipefail
IFS=$'\n\t'
export LC_ALL=C

# --- early guards -------------------------------------------------------------

# Check git command first before any git usage
if ! command -v git >/dev/null 2>&1; then
    printf 'Error: git command not found\n' >&2
    exit 1
fi

# Auto-detect project root using POSIX-friendly approach
SCRIPT_DIR="$(cd -- "$(dirname -- "$0")" && pwd -P)"
PROJECT_ROOT="$(cd -- "$SCRIPT_DIR/.." && pwd -P)"
cd "$PROJECT_ROOT"

# Early repository guard
git rev-parse --is-inside-work-tree >/dev/null 2>&1 || {
    printf 'Not in a git repository\n' >&2
    exit 1
}

# Optional error trap for CI debugging (uncomment if needed)
# trap 'printf "Error at line %d in %s\n" $LINENO "${BASH_SOURCE[0]}" >&2' ERR

show_help() {
    cat << EOF
Semantic Version Analyzer for vglog-filter

Usage: $(basename "$0") [options]

Options:
  --since <tag>            Analyze changes since specific tag (default: last tag)
  --since-tag <tag>        Alias for --since
  --since-commit <hash>    Analyze changes since specific commit
  --since-date <date>      Analyze changes since specific date (YYYY-MM-DD)
  --base <ref>             Set base reference for comparison (default: auto-detected)
  --target <ref>           Set target reference for comparison (default: HEAD)
  --repo-root <path>       Set repository root directory
  --no-merge-base          Disable automatic merge-base detection for disjoint branches
  --print-base             Output the chosen base reference SHA on a single line
  --verbose                Show detailed analysis
  --machine                Output machine-readable key=value format (SUGGESTION only)
  --json                   Output machine-readable JSON
  --ignore-whitespace      Ignore whitespace changes in diff size calculation
  --suggest-only           Output only the suggestion (major/minor/patch/none)
  --help, -h               Show this help

Environment Variables:
  MIN_MAJOR_DIFF_LINES     Minimum lines for major bump (default: 2000)
  MIN_MINOR_DIFF_LINES     Minimum lines for minor bump (default: 50)
  MIN_PATCH_DIFF_LINES     Minimum lines for patch bump (default: 100)
  MIN_PATCH_FILES          Minimum files for patch bump (default: 5)
  MIN_NEW_SOURCE_FILES     Minimum new source files for minor (default: 2)
  MIN_NEW_TEST_FILES       Minimum new test files for minor (default: 3)
  MIN_NEW_DOC_FILES        Minimum new doc files for minor (default: 2)
  MAJOR_REQUIRE_BREAKING   Require breaking changes for major (default: true; accepts: true/1/yes)

Examples:
  $(basename "$0") --since v1.1.0
  $(basename "$0") --since-date 2025-01-01
  $(basename "$0") --base HEAD~5 --target HEAD
  $(basename "$0") --base v1.0.0 --target v1.1.0
  $(basename "$0") --verbose
  $(basename "$0") --machine
  $(basename "$0") --json

Machine output examples:
  $(basename "$0") --machine | grep SUGGESTION
  $(basename "$0") --json | jq -r .suggestion

Exit codes:
  10 = major version bump suggested
  11 = minor version bump suggested
  12 = patch version bump suggested
  20 = no version bump suggested

Notes:
  - CLI option detection uses fold -w1 for short options (byte-based splitting)
  - Multi-byte characters in long options are not supported
  - Colons are filtered from getopt strings to avoid false "removed option" detections
  - All git commands use color.ui=false for consistent output
  - All git diff commands use -M -C for deterministic parsing and rename detection
  - Header prototype detection is restricted to include/** or src/** header files with semicolon endings
  - Manual CLI detection (--verbose or not) scans for added/removed --[[:alnum:]-]+ tokens in C/C++ sources
  - JSON output includes manual_added_long_count and manual_removed_long_count fields
EOF
}

# Default values
SINCE_TAG=""
SINCE_COMMIT=""
SINCE_DATE=""
BASE_REF=""
TARGET_REF=""
REPO_ROOT=""
NO_MERGE_BASE=false
PRINT_BASE=false
VERBOSE=false
MACHINE_OUTPUT=false
JSON_OUTPUT=false
IGNORE_WHITESPACE=false
SUGGEST_ONLY=false

# --- defaults / config --------------------------------------------------------

# Configurable thresholds (can be overridden by environment)
MIN_MAJOR_DIFF_LINES="${MIN_MAJOR_DIFF_LINES:-2000}"
MIN_MINOR_DIFF_LINES="${MIN_MINOR_DIFF_LINES:-50}"
MIN_PATCH_DIFF_LINES="${MIN_PATCH_DIFF_LINES:-100}"
MIN_PATCH_FILES="${MIN_PATCH_FILES:-5}"
MIN_NEW_SOURCE_FILES="${MIN_NEW_SOURCE_FILES:-2}"
MIN_NEW_TEST_FILES="${MIN_NEW_TEST_FILES:-3}"
MIN_NEW_DOC_FILES="${MIN_NEW_DOC_FILES:-2}"
MAJOR_REQUIRE_BREAKING="${MAJOR_REQUIRE_BREAKING:-true}"

# Normalize MAJOR_REQUIRE_BREAKING once for consistency
REQ="${MAJOR_REQUIRE_BREAKING,,}"

# --- arg parsing --------------------------------------------------------------

# Parse arguments with proper validation
while [[ $# -gt 0 ]]; do
    case $1 in
        --since|--since-tag)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --since requires a value\n' >&2; exit 1; }
            SINCE_TAG="$2"; shift 2;;
        --since-commit)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --since-commit requires a value\n' >&2; exit 1; }
            SINCE_COMMIT="$2"; shift 2;;
        --since-date)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --since-date requires a value\n' >&2; exit 1; }
            # Validate date format (YYYY-MM-DD)
            [[ "$2" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]] || { printf 'Error: --since-date requires YYYY-MM-DD format\n' >&2; exit 1; }
            IFS='-' read -r year month day <<< "$2"
            # shellcheck disable=SC2034 # year is used for validation in date parsing
            ((month>=1 && month<=12)) || { printf 'Error: Invalid month in date %s (must be 01-12)\n' "$2" >&2; exit 1; }
            ((day>=1 && day<=31)) ||  { printf 'Error: Invalid day in date %s (must be 01-31)\n' "$2" >&2; exit 1; }
            SINCE_DATE="$2"; shift 2;;
        --base)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --base requires a value\n' >&2; exit 1; }
            BASE_REF="$2"; shift 2;;
        --target)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --target requires a value\n' >&2; exit 1; }
            TARGET_REF="$2"; shift 2;;
        --repo-root)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --repo-root requires a value\n' >&2; exit 1; }
            REPO_ROOT="$2"; shift 2;;
        --no-merge-base) NO_MERGE_BASE=true; shift;;
        --print-base)    PRINT_BASE=true; shift;;
        --verbose)       VERBOSE=true; shift;;
        --machine)       MACHINE_OUTPUT=true; shift;;
        --json)          JSON_OUTPUT=true; shift;;
        --ignore-whitespace) IGNORE_WHITESPACE=true; shift;;
        --suggest-only)  SUGGEST_ONLY=true; shift;;
        --help|-h)       show_help; exit 0;;
        *) printf 'Error: Unknown option: %s\n' "$1" >&2; show_help; exit 1;;
    esac
done

# Change to repo root if specified
if [[ -n "$REPO_ROOT" ]]; then
    cd "$REPO_ROOT"
    git rev-parse --is-inside-work-tree >/dev/null 2>&1 || {
        printf 'Error: Not in a git repository at %s\n' "$REPO_ROOT" >&2
        exit 1
    }
fi

# --- helpers ------------------------------------------------------------------

# Validate git reference
verify_ref() {
    local ref="$1"
    if ! git -c color.ui=false rev-parse -q --verify "$ref^{commit}" >/dev/null; then
        printf 'Error: Invalid reference: %s\n' "$ref" >&2
        exit 1
    fi
}

# Determine the base for comparison with better error handling
get_base_reference() {
    # Handle explicit base/target references
    if [[ -n "$BASE_REF" ]]; then
        verify_ref "$BASE_REF"; printf '%s|explicit_base' "$BASE_REF"; return
    fi

    if [[ -n "$SINCE_COMMIT" ]]; then
        verify_ref "$SINCE_COMMIT"; printf '%s|commit' "$SINCE_COMMIT"; return
    elif [[ -n "$SINCE_TAG" ]]; then
        verify_ref "$SINCE_TAG"; printf '%s|tag' "$SINCE_TAG"; return
    elif [[ -n "$SINCE_DATE" ]]; then
        # Find the latest commit before the specified date
        local ref
        ref=$(git -c color.ui=false rev-list -1 --before="$SINCE_DATE 23:59:59" HEAD 2>/dev/null || true)
        if [[ -n "$ref" ]]; then
            verify_ref "$ref"; printf '%s|date' "$ref"
        else
            printf 'Warning: No commits found before %s, using first commit\n' "$SINCE_DATE" >&2
            local first_commit
            first_commit=$(git -c color.ui=false rev-list --max-parents=0 HEAD 2>/dev/null || true)
            [[ -n "$first_commit" ]] || { printf 'Error: No commits found in repository\n' >&2; exit 1; }
            printf '%s|first' "$first_commit"
        fi
        return
    fi

    # Default to last tag, fallback to HEAD~1 if no tags exist
    local last_tag
    last_tag=$(git -c color.ui=false describe --tags --abbrev=0 2>/dev/null || true)
    if [[ -n "$last_tag" ]]; then
        verify_ref "$last_tag"
        printf '%s|last_tag' "$last_tag"
    else
        # If no tags exist, use HEAD~1 instead of first commit
        local parent_commit
        parent_commit=$(git -c color.ui=false rev-parse HEAD~1 2>/dev/null || true)
        if [[ -n "$parent_commit" ]]; then
            printf '%s|parent' "$parent_commit"
        else
            # Only use first commit if HEAD~1 doesn't exist (single-commit repo)
            local first_commit
            first_commit=$(git -c color.ui=false rev-list --max-parents=0 HEAD 2>/dev/null || true)
            [[ -n "$first_commit" ]] || { printf 'Error: No commits found in repository\n' >&2; exit 1; }
            printf '%s|first' "$first_commit"
        fi
    fi
}

# Check if there are commits in the range
check_commit_range() {
    local base_ref="$1"
    local target_ref="$2"

    local commit_count
    commit_count=$(git -c color.ui=false rev-list --count "$base_ref".."$target_ref" 2>/dev/null || printf '0')

    (( commit_count > 0 )) || { printf 'Warning: No commits found between %s and %s\n' "$base_ref" "$target_ref" >&2; return 1; }
    return 0
}

# Classify file path - improved to handle multiple folder patterns and nested directories
classify_path() {
    local path="$1"

    # Skip noise directories and binary/lock artifacts (including nested ones)
    if [[ "$path" =~ /(build|dist|out|third_party|vendor|\.git|node_modules|target|bin|obj)/ ]] || \
       [[ "$path" =~ ^(build|dist|out|third_party|vendor|\.git|node_modules|target|bin|obj)/ ]] || \
       [[ "$path" =~ \.(lock|exe|dll|so|dylib|jar|war|ear|zip|tar|gz|bz2|xz|7z|rar)$ ]]; then
        printf '0'
        return
    fi

    # Source files (including headers) - support multiple source directories and nested paths
    if [[ "$path" =~ \.(c|cc|cpp|cxx|h|hpp|hh)$ ]] || [[ "$path" =~ /(src|source|app)/ ]] || [[ "$path" =~ ^(src|source|app)/ ]]; then
        printf '30'
        return
    fi

    # Test files - support test/, tests/, and unittests/ in nested directories
    if [[ "$path" =~ /(test|tests|unittests)/ ]] || [[ "$path" =~ ^(test|tests|unittests)/ ]]; then
        printf '10'
        return
    fi

    # Documentation files - support both doc/ and docs/ and README files in nested directories
    # FIXED: Broaden doc classification to include common documentation files in any directory
    # ENHANCED: Case-insensitive matching for better portability
    local path_lower
    path_lower=$(printf '%s' "$path" | tr '[:upper:]' '[:lower:]')
    if [[ "$path_lower" =~ /(doc|docs)/ ]] || [[ "$path_lower" =~ ^(doc|docs)/ ]] || \
       [[ "$path_lower" =~ /(readme|changelog|contributing|license|copying|authors|install|news|history) ]] || \
       [[ "$path_lower" =~ ^(readme|changelog|contributing|license|copying|authors|install|news|history) ]] || \
       [[ "$path_lower" =~ \.(md|rst|adoc|txt)$ ]]; then
        printf '20'
        return
    fi

    printf '0'
}

# Helper function to increment counters for new files
inc_counters_for() {
    local file="$1"
    case "$(classify_path "$file")" in
        30) ((new_source_files++)) ;;
        10) ((new_test_files++)) ;;
        20) ((new_doc_files++)) ;;
    esac
}

# Enhanced CLI options detection with better accuracy - restrict to changed lines
extract_cli_options() {
    local base_ref="$1"
    local target_ref="$2"

    # Get source files diff
    local srcdiff
    srcdiff=$(git -c color.ui=false diff -M -C "$base_ref".."$target_ref" -- 'src/**/*.c' 'src/**/*.cc' 'src/**/*.cpp' 'src/**/*.cxx' 'include/**/*.h' 'include/**/*.hpp' 'include/**/*.hh' 2>/dev/null || true)

    if [[ -z "$srcdiff" ]]; then
        printf 'short_options_before=\n'
        printf 'short_options_after=\n'
        printf 'long_options_before=\n'
        printf 'long_options_after=\n'
        printf 'breaking_changes=false\n'
        printf 'api_breaking=false\n'
        printf 'security_keywords=0\n'
        printf 'manual_cli_changes=false\n'
        printf 'manual_added_long_count=0\n'
        printf 'manual_removed_long_count=0\n'
        printf 'removed_short_count=0\n'
        printf 'added_short_count=0\n'
        printf 'removed_long_count=0\n'
        printf 'added_long_count=0\n'
        return
    fi

    # Extract short options / long options from changed source files
    local short_before short_after
    local long_before long_after
    local -a changed_files=()

    while IFS= read -r -d '' f; do changed_files+=("$f"); done \
        < <(git -c color.ui=false -c core.quotepath=false diff -M -C -z --name-only "$base_ref".."$target_ref" -- \
            'src/**/*.c' 'src/**/*.cc' 'src/**/*.cpp' 'src/**/*.cxx' \
            'include/**/*.h' 'include/**/*.hpp' 'include/**/*.hh' 2>/dev/null || printf '')

    if (( ${#changed_files[@]} > 0 )); then
        short_before=$(
            for file in "${changed_files[@]}"; do
                git -c color.ui=false show "$base_ref:$file" 2>/dev/null \
                | grep -E 'getopt\(|getopt_long\(' \
                | grep -o '"[^"]*"' \
                | tr -d '"' || true
            done | sort -u | tr -d '\n' || printf ''
        )
        short_after=$(
            for file in "${changed_files[@]}"; do
                git -c color.ui=false show "$target_ref:$file" 2>/dev/null \
                | grep -E 'getopt\(|getopt_long\(' \
                | grep -o '"[^"]*"' \
                | tr -d '"' || true
            done | sort -u | tr -d '\n' || printf ''
        )

        # Extract long options from struct option arrays
        long_before=$(
            for file in "${changed_files[@]}"; do
                git -c color.ui=false show "$base_ref:$file" 2>/dev/null \
                | awk '/struct option/,/};/' \
                | grep '{"[^"]*"' \
                | grep -o '"[^"]*"' \
                | tr -d '"' || true
            done | sort -u | tr '\n' ',' | sed 's/,$//' || printf ''
        )
        long_after=$(
            for file in "${changed_files[@]}"; do
                git -c color.ui=false show "$target_ref:$file" 2>/dev/null \
                | awk '/struct option/,/};/' \
                | grep '{"[^"]*"' \
                | grep -o '"[^"]*"' \
                | tr -d '"' || true
            done | sort -u | tr '\n' ',' | sed 's/,$//' || printf ''
        )
    else
        short_before=""; short_after=""; long_before=""; long_after=""
    fi

    # Enhanced breaking change detection: look for removed case labels
    local breaking_changes=false

    local removed_cases
    removed_cases=$(
        git -c color.ui=false diff -M -C --unified=0 "$base_ref".."$target_ref" -- \
            'src/**/*.c' 'src/**/*.cc' 'src/**/*.cpp' 'src/**/*.cxx' \
            'include/**/*.h' 'include/**/*.hpp' 'include/**/*.hh' \
        | grep -E '^-[[:space:]]*case[[:space:]]' \
        | sed 's/^-[[:space:]]*case[[:space:]]*//' \
        | sort -u || printf ''
    )

    if [[ -n "$removed_cases" ]]; then
        local added_cases
        added_cases=$(
            git -c color.ui=false diff -M -C --unified=0 "$base_ref".."$target_ref" -- \
                'src/**/*.c' 'src/**/*.cc' 'src/**/*.cpp' 'src/**/*.cxx' \
                'include/**/*.h' 'include/**/*.hpp' 'include/**/*.hh' \
            | grep -E '^\+[[:space:]]*case[[:space:]]' \
            | sed 's/^+[[:space:]]*case[[:space:]]*//' \
            | sort -u || printf ''
        )
        local missing_cases
        missing_cases=$(
            comm -23 <(printf '%s\n' "$removed_cases" | sort -u) <(printf '%s\n' "$added_cases" | sort -u) 2>/dev/null || printf ''
        )
        [[ -n "$missing_cases" ]] && breaking_changes=true
    fi

    # Check for API-breaking hints in headers
    local api_breaking=false
    local removed_prototypes
    removed_prototypes=$(
        git -c color.ui=false diff -M -C --unified=0 "$base_ref".."$target_ref" -- \
            'include/**/*.h' 'include/**/*.hpp' 'include/**/*.hh' \
            'src/**/*.h'     'src/**/*.hpp'     'src/**/*.hh' \
        | awk '/^-[[:space:]]*[A-Za-z_][A-Za-z0-9_]*[[:space:]]+[A-Za-z_][A-Za-z0-9_]*[[:space:]]*\(/ && /\);[[:space:]]*$/ && !/^-[[:space:]]*(typedef|#)/' \
        | wc -l || printf '0'
    )
    if [[ "${removed_prototypes:-0}" -gt 0 ]]; then
        api_breaking=true
    fi

    # Explicit API-BREAKING comments
    local explicit_breaking
    explicit_breaking=$(
        git -c color.ui=false diff -M -C "$base_ref".."$target_ref" -- \
            'src/**/*.c' 'src/**/*.cc' 'src/**/*.cpp' 'src/**/*.cxx' \
            'include/**/*.h' 'include/**/*.hpp' 'include/**/*.hh' \
        | grep -ci 'API-BREAKING:' 2>/dev/null || printf '0'
    )
    if [[ "${explicit_breaking:-0}" -gt 0 ]]; then
        api_breaking=true
    fi

    # Security/crash detection in commit messages (gated on code/API/CLI change)
    local security_keywords=0
    local has_code_changes=false
    if git -c color.ui=false diff -M -C --name-only "$base_ref".."$target_ref" -- \
         'src/**/*.c' 'src/**/*.cc' 'src/**/*.cpp' 'src/**/*.cxx' \
         'src/**/*.h' 'src/**/*.hpp' 'src/**/*.hh' \
         'include/**/*.h' 'include/**/*.hpp' 'include/**/*.hh' | grep -q .; then
        has_code_changes=true
    fi
    if [[ "$has_code_changes" = "true" ]] || [[ "$api_breaking" = "true" ]] || [[ "$breaking_changes" = "true" ]]; then
        security_keywords=$(
            git -c color.ui=false log --format="%s %b" "$base_ref".."$target_ref" \
            | grep -ci -E '(security|cve|crash|segfault|uaf|overflow|xss|vulnerability)' || printf '0'
        )
    fi

    # Manual argv parser detection for tools that don't use getopt
    manual_cli_changes=false
    manual_added_long_count=0
    manual_removed_long_count=0

    local added_long_opts
    added_long_opts=$(
        git -c color.ui=false diff -M -C "$base_ref".."$target_ref" -- \
            'src/**/*.c' 'src/**/*.cc' 'src/**/*.cpp' 'src/**/*.cxx' \
        | grep -E '^\+.*--[[:alnum:]-]+' \
        | sed -n 's/.*\(--[[:alnum:]-]\+\).*/\1/p' | sort -u || printf ''
    )
    local removed_long_opts
    removed_long_opts=$(
        git -c color.ui=false diff -M -C "$base_ref".."$target_ref" -- \
            'src/**/*.c' 'src/**/*.cc' 'src/**/*.cpp' 'src/**/*.cxx' \
        | grep -E '^-.*--[[:alnum:]-]+' \
        | sed -n 's/.*\(--[[:alnum:]-]\+\).*/\1/p' | sort -u || printf ''
    )
    manual_added_long_count=$(printf '%s\n' "$added_long_opts"   | wc -l || printf '0')
    manual_removed_long_count=$(printf '%s\n' "$removed_long_opts" | wc -l || printf '0')
    (( ${manual_added_long_count:-0} > 0 || ${manual_removed_long_count:-0} > 0 )) && manual_cli_changes=true

    # Compute counts for removed/added options
    local removed_short_count=0 added_short_count=0
    local removed_long_count=0  added_long_count=0

    if [[ -n "$short_before" ]] || [[ -n "$short_after" ]]; then
        removed_short_count=$(
            comm -23 <(printf '%s' "${short_before:-}" | tr -d ':' | fold -w1 | sort -u) \
                     <(printf '%s' "${short_after:-}"  | tr -d ':' | fold -w1 | sort -u) 2>/dev/null | wc -l || printf '0'
        )
        added_short_count=$(
            comm -13 <(printf '%s' "${short_before:-}" | tr -d ':' | fold -w1 | sort -u) \
                     <(printf '%s' "${short_after:-}"  | tr -d ':' | fold -w1 | sort -u) 2>/dev/null | wc -l || printf '0'
        )
    fi

    if [[ -n "$long_before" ]] || [[ -n "$long_after" ]]; then
        removed_long_count=$(
            comm -23 <(printf '%s' "${long_before:-}" | tr ',' '\n' | sort -u) \
                     <(printf '%s' "${long_after:-}"  | tr ',' '\n' | sort -u) 2>/dev/null | wc -l || printf '0'
        )
        added_long_count=$(
            comm -13 <(printf '%s' "${long_before:-}" | tr ',' '\n' | sort -u) \
                     <(printf '%s' "${long_after:-}"  | tr ',' '\n' | sort -u) 2>/dev/null | wc -l || printf '0'
        )
    fi

    printf 'short_options_before=%s\n' "$short_before"
    printf 'short_options_after=%s\n' "$short_after"
    printf 'long_options_before=%s\n' "$long_before"
    printf 'long_options_after=%s\n' "$long_after"
    printf 'breaking_changes=%s\n' "$breaking_changes"
    printf 'api_breaking=%s\n' "$api_breaking"
    printf 'security_keywords=%s\n' "$security_keywords"
    printf 'manual_cli_changes=%s\n' "$manual_cli_changes"
    printf 'manual_added_long_count=%s\n' "$manual_added_long_count"
    printf 'manual_removed_long_count=%s\n' "$manual_removed_long_count"
    printf 'removed_short_count=%s\n' "$removed_short_count"
    printf 'added_short_count=%s\n' "$added_short_count"
    printf 'removed_long_count=%s\n' "$removed_long_count"
    printf 'added_long_count=%s\n' "$added_long_count"
}

# Binary-safe numstat summation function
sum_numstat() {
    local cmd=("$@")
    local total_ins=0 total_del=0
    while IFS=$'\t' read -r ins del _; do
        [[ $ins =~ ^[0-9]+$ ]] || ins=0
        [[ $del =~ ^[0-9]+$ ]] || del=0
        total_ins=$((total_ins + ins))
        total_del=$((total_del + del))
    done < <("${cmd[@]}")
    printf '%s' $((total_ins + total_del))
}

# Enhanced change analysis with better diff parsing and rename/copy handling
analyze_changes() {
    local base_ref="$1"
    local target_ref="$2"

    # Check if there are any changes
    if git -c color.ui=false diff -M -C --quiet "$base_ref".."$target_ref"; then
        printf 'Warning: No changes detected between %s and %s\n' "$base_ref" "$target_ref" >&2
        printf 'added_files=0\n'
        printf 'modified_files=0\n'
        printf 'deleted_files=0\n'
        printf 'new_source_files=0\n'
        printf 'new_test_files=0\n'
        printf 'new_doc_files=0\n'
        printf 'cli_changes=false\n'
        printf 'breaking_cli_changes=false\n'
        printf 'diff_size=0\n'
        printf 'api_breaking=false\n'
        printf 'security_keywords=0\n'
        printf 'manual_cli_changes=false\n'
        printf 'manual_added_long_count=0\n'
        printf 'manual_removed_long_count=0\n'
        printf 'removed_short_count=0\n'
        printf 'added_short_count=0\n'
        printf 'removed_long_count=0\n'
        printf 'added_long_count=0\n'
        return
    fi

    local added_files=0
    local modified_files=0
    local deleted_files=0
    local new_source_files=0
    local new_test_files=0
    local new_doc_files=0
    local cli_changes=false
    local breaking_cli_changes=false

    # NUL-delimited, handle renames/copies
    while IFS= read -r -d '' status; do
        local path1 path2 file
        IFS= read -r -d '' path1
        file="$path1"
        case "${status:0:1}" in
            R|C)
                IFS= read -r -d '' path2
                file="$path2"
                ;;
        esac

        case "${status:0:1}" in
            A) ((added_files++)); inc_counters_for "$file" ;;
            M|T) ((modified_files++)) ;;
            D)   ((deleted_files++)) ;;
            R)   ((modified_files++)) ;;
            C)   ((added_files++)); inc_counters_for "$file" ;;
        esac
    done < <(git -c color.ui=false -c core.quotepath=false diff -M -C --name-status -z "$base_ref".."$target_ref" 2>/dev/null)

    # Extract CLI options for comparison
    local cli_analysis
    cli_analysis=$(extract_cli_options "$base_ref" "$target_ref")
    local short_before short_after long_before long_after
    short_before=$(printf '%s\n' "$cli_analysis" | grep "^short_options_before=" | cut -d'=' -f2)
    short_after=$(printf '%s\n' "$cli_analysis" | grep "^short_options_after="  | cut -d'=' -f2)
    long_before=$(printf '%s\n' "$cli_analysis"  | grep "^long_options_before=" | cut -d'=' -f2)
    long_after=$(printf '%s\n' "$cli_analysis"   | grep "^long_options_after="  | cut -d'=' -f2)
    local breaking_changes
    breaking_changes=$(printf '%s\n' "$cli_analysis" | grep "^breaking_changes=" | cut -d'=' -f2)
    local api_breaking
    api_breaking=$(printf '%s\n' "$cli_analysis" | grep "^api_breaking=" | cut -d'=' -f2)
    local security_keywords
    security_keywords=$(printf '%s\n' "$cli_analysis" | grep "^security_keywords=" | cut -d'=' -f2)
    local manual_cli_changes
    manual_cli_changes=$(printf '%s\n' "$cli_analysis" | grep "^manual_cli_changes=" | cut -d'=' -f2)
    local manual_added_long_count
    manual_added_long_count=$(printf '%s\n' "$cli_analysis" | grep "^manual_added_long_count=" | cut -d'=' -f2)
    local manual_removed_long_count
    manual_removed_long_count=$(printf '%s\n' "$cli_analysis" | grep "^manual_removed_long_count="| cut -d'=' -f2 | tr -d '\r')
    local removed_short_count
    removed_short_count=$(printf '%s\n' "$cli_analysis" | grep "^removed_short_count=" | cut -d'=' -f2)
    local added_short_count
    added_short_count=$(printf '%s\n' "$cli_analysis" | grep "^added_short_count=" | cut -d'=' -f2)
    local removed_long_count
    removed_long_count=$(printf '%s\n' "$cli_analysis" | grep "^removed_long_count=" | cut -d'=' -f2)
    local added_long_count
    added_long_count=$(printf '%s\n' "$cli_analysis" | grep "^added_long_count=" | cut -d'=' -f2)

    # Check for CLI changes by comparing option sets (normalize colons)
    local short_before_norm short_after_norm
    short_before_norm=$(printf '%s' "$short_before" | tr -d ':')
    short_after_norm=$(printf '%s' "$short_after" | tr -d ':')

    if [[ -n "$short_after" ]] && [[ "$short_after_norm" != "$short_before_norm" ]]; then
        cli_changes=true
        local removed_short
        removed_short=$(
            comm -23 <(printf '%s' "$short_before" | tr -d ':' | fold -w1 | sort -u) \
                     <(printf '%s' "$short_after"  | tr -d ':' | fold -w1 | sort -u) 2>/dev/null || printf ''
        )
        [[ -n "$removed_short" ]] && breaking_cli_changes=true
    fi

    if [[ -n "$long_after" ]] && [[ "$long_after" != "$long_before" ]]; then
        cli_changes=true
        local removed_long
        removed_long=$(
            comm -23 <(printf '%s' "$long_before" | tr ',' '\n' | sort -u) \
                     <(printf '%s' "$long_after"  | tr ',' '\n' | sort -u) 2>/dev/null || printf ''
        )
        [[ -n "$removed_long" ]] && breaking_cli_changes=true
    fi

    # Propagate other breaking signals
    if [[ "$breaking_changes" = "true" ]] || [[ "$api_breaking" = "true" ]]; then
        breaking_cli_changes=true
    fi

    # Get diff size using numstat (binary-safe)
    local diff_size
    if [[ "$IGNORE_WHITESPACE" = "true" ]]; then
        diff_size=$(sum_numstat git -c color.ui=false -c core.quotepath=false diff -M -C -w --numstat "$base_ref".."$target_ref")
    else
        diff_size=$(sum_numstat git -c color.ui=false -c core.quotepath=false diff -M -C    --numstat "$base_ref".."$target_ref")
    fi

    printf 'added_files=%s\n' "$added_files"
    printf 'modified_files=%s\n' "$modified_files"
    printf 'deleted_files=%s\n' "$deleted_files"
    printf 'new_source_files=%s\n' "$new_source_files"
    printf 'new_test_files=%s\n' "$new_test_files"
    printf 'new_doc_files=%s\n' "$new_doc_files"
    printf 'cli_changes=%s\n' "$cli_changes"
    printf 'breaking_cli_changes=%s\n' "$breaking_cli_changes"
    printf 'diff_size=%s\n' "$diff_size"
    printf 'api_breaking=%s\n' "$api_breaking"
    printf 'security_keywords=%s\n' "$security_keywords"
    printf 'manual_cli_changes=%s\n' "$manual_cli_changes"
    printf 'manual_added_long_count=%s\n' "$manual_added_long_count"
    printf 'manual_removed_long_count=%s\n' "$manual_removed_long_count"
    printf 'removed_short_count=%s\n' "$removed_short_count"
    printf 'added_short_count=%s\n' "$added_short_count"
    printf 'removed_long_count=%s\n' "$removed_long_count"
    printf 'added_long_count=%s\n' "$added_long_count"
}

# Calculate next version without external dependency
calculate_next_version() {
    local current_version="$1"
    local bump_type="$2"

    if [[ -z "$current_version" ]] || [[ "$current_version" = "0.0.0" ]]; then
        case "$bump_type" in
            major) printf '1.0.0' ;;
            minor) printf '0.1.0' ;;
            patch) printf '0.0.1' ;;
            *) printf '0.0.0' ;;
        esac
        return
    fi

    # FIXED: Validate VERSION format
    if [[ ! $current_version =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        current_version=0.0.0
    fi

    local major minor patch
    IFS='.' read -r major minor patch <<< "$current_version"

    case "$bump_type" in
        major)
            printf '%d.0.0' "$((major + 1))"
            ;;
        minor)
            printf '%d.%d.0' "$major" "$((minor + 1))"
            ;;
        patch)
            printf '%d.%d.%d' "$major" "$minor" "$((patch + 1))"
            ;;
        *)
            printf '%s' "$current_version"
            ;;
    esac
}

# Determine version bump suggestion based on improved rules
suggest_version_bump() {
    local added_files="$1"
    local modified_files="$2"
    local deleted_files="$3"
    local new_source_files="$4"
    local new_test_files="$5"
    local new_doc_files="$6"
    local cli_changes="$7"
    local breaking_cli_changes="$8"
    local diff_size="$9"
    local api_breaking="${10}"
    local security_keywords="${11}"
    local manual_cli_changes="${12}"

    # MAJOR: Breaking, security, or very large changes (if not requiring breaking)
    if [[ "$breaking_cli_changes" = "true" ]]; then printf 'major'; return; fi
    if [[ "$api_breaking" = "true"      ]]; then printf 'major'; return; fi
    if [[ "${security_keywords:-0}" -gt 0 ]]; then printf 'major'; return; fi
    if [[ "${diff_size:-0}" -gt "$MIN_MAJOR_DIFF_LINES" ]]; then
        if [[ "$REQ" != "true" && "$REQ" != "1" && "$REQ" != "yes" ]]; then
            printf 'major'; return
        fi
    fi

    # MINOR: New CLI or notable new content
    if [[ "$cli_changes" = "true" ]]; then printf 'minor'; return; fi
    if [[ "${manual_cli_changes:-false}" = "true" ]]; then printf 'minor'; return; fi
    if [[ "${new_source_files:-0}" -ge "$MIN_NEW_SOURCE_FILES" ]]; then printf 'minor'; return; fi
    if [[ "${new_test_files:-0}"  -ge "$MIN_NEW_TEST_FILES"  ]]; then printf 'minor'; return; fi
    if [[ "${new_doc_files:-0}"   -ge "$MIN_NEW_DOC_FILES"   ]]; then printf 'minor'; return; fi

    # PATCH: Significant modifications without new features
    if [[ "${modified_files:-0}" -ge "$MIN_PATCH_FILES" ]] && [[ "${diff_size:-0}" -gt "$MIN_PATCH_DIFF_LINES" ]]; then
        printf 'patch'; return
    fi

    printf 'none'
}

# Determine the reason for the version bump suggestion
get_bump_reason() {
    local added_files="$1"
    local modified_files="$2"
    local deleted_files="$3"
    local new_source_files="$4"
    local new_test_files="$5"
    local new_doc_files="$6"
    local cli_changes="$7"
    local breaking_cli_changes="$8"
    local diff_size="$9"
    local api_breaking="${10}"
    local security_keywords="${11}"
    local manual_cli_changes="${12}"

    # MAJOR reasons
    if [[ "$breaking_cli_changes" = "true" ]]; then printf 'breaking_cli'; return; fi
    if [[ "$api_breaking" = "true"      ]]; then printf 'api_break';    return; fi
    if [[ "${security_keywords:-0}" -gt 0 ]]; then printf 'security_keywords'; return; fi
    if [[ "${diff_size:-0}" -gt "$MIN_MAJOR_DIFF_LINES" ]]; then
        if [[ "$REQ" != "true" && "$REQ" != "1" && "$REQ" != "yes" ]]; then
            printf 'large_diff'; return
        fi
    fi

    # MINOR reasons
    if [[ "$cli_changes" = "true" ]]; then printf 'cli_added'; return; fi
    if [[ "${manual_cli_changes:-false}" = "true" ]]; then printf 'cli_added'; return; fi
    if [[ "${new_source_files:-0}" -ge "$MIN_NEW_SOURCE_FILES" ]]; then printf 'new_src';   return; fi
    if [[ "${new_test_files:-0}"  -ge "$MIN_NEW_TEST_FILES"  ]]; then printf 'new_tests'; return; fi
    if [[ "${new_doc_files:-0}"   -ge "$MIN_NEW_DOC_FILES"   ]]; then printf 'new_docs';  return; fi

    # PATCH reasons
    if [[ "${modified_files:-0}" -ge "$MIN_PATCH_FILES" ]] && [[ "${diff_size:-0}" -gt "$MIN_PATCH_DIFF_LINES" ]]; then
        printf 'mods_only'; return
    fi

    printf 'none'
}

# --- main ---------------------------------------------------------------------

# Main analysis
main() {
    local base_ref_info
    base_ref_info=$(get_base_reference)
    local base_ref ref_type
    IFS='|' read -r base_ref ref_type <<< "$base_ref_info"

    # Set target reference (default to HEAD)
    local target_ref="${TARGET_REF:-HEAD}"
    if [[ -n "$TARGET_REF" ]]; then
        verify_ref "$target_ref"
    fi

    # Check and normalize disjoint branches with merge-base
    local actual_base
    actual_base=$(git -c color.ui=false merge-base "$base_ref" "$target_ref" 2>/dev/null || printf '')
    if [[ -z "$actual_base" ]]; then
        printf 'Error: No common ancestor found between %s and %s. Exiting.\n' "$base_ref" "$target_ref" >&2
        exit 1
    fi
    if [[ "$actual_base" != "$base_ref" ]] && [[ "$NO_MERGE_BASE" != "true" ]]; then
        printf 'Info: Using merge-base %s instead of %s for disjoint branches\n' "$actual_base" "$base_ref" >&2
        base_ref="$actual_base"
    fi

    # Handle --print-base option
    if [[ "$PRINT_BASE" = "true" ]]; then
        printf '%s\n' "$base_ref"
        exit 0
    fi

    if ! check_commit_range "$base_ref" "$target_ref"; then
        printf 'Error: No commits found between %s and %s. Exiting.\n' "$base_ref" "$target_ref" >&2
        exit 1
    fi

    # Get current version with proper whitespace handling and validation
    local current_version
    current_version=$(tr -d '[:space:]' < VERSION 2>/dev/null || printf '0.0.0')
    [[ $current_version =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]] || current_version=0.0.0

    # Analyze changes
    local analysis
    analysis=$(analyze_changes "$base_ref" "$target_ref")

    # Extract fields
    local added_files modified_files deleted_files
    local new_source_files new_test_files new_doc_files
    local cli_changes breaking_cli_changes diff_size
    local api_breaking security_keywords
    local manual_cli_changes
    local removed_short_count added_short_count
    local removed_long_count added_long_count

    added_files=$(           printf '%s\n' "$analysis" | grep "^added_files="            | cut -d'=' -f2 | tr -d '\r')
    modified_files=$(        printf '%s\n' "$analysis" | grep "^modified_files="         | cut -d'=' -f2 | tr -d '\r')
    deleted_files=$(         printf '%s\n' "$analysis" | grep "^deleted_files="          | cut -d'=' -f2 | tr -d '\r')
    new_source_files=$(      printf '%s\n' "$analysis" | grep "^new_source_files="       | cut -d'=' -f2 | tr -d '\r')
    new_test_files=$(        printf '%s\n' "$analysis" | grep "^new_test_files="         | cut -d'=' -f2 | tr -d '\r')
    new_doc_files=$(         printf '%s\n' "$analysis" | grep "^new_doc_files="          | cut -d'=' -f2 | tr -d '\r')
    cli_changes=$(           printf '%s\n' "$analysis" | grep "^cli_changes="            | cut -d'=' -f2 | tr -d '\r')
    breaking_cli_changes=$(  printf '%s\n' "$analysis" | grep "^breaking_cli_changes="   | cut -d'=' -f2 | tr -d '\r')
    diff_size=$(             printf '%s\n' "$analysis" | grep "^diff_size="              | cut -d'=' -f2 | tr -d '\r')
    api_breaking=$(          printf '%s\n' "$analysis" | grep "^api_breaking="           | cut -d'=' -f2 | tr -d '\r')
    security_keywords=$(     printf '%s\n' "$analysis" | grep "^security_keywords="      | cut -d'=' -f2 | tr -d '\r')
    manual_cli_changes=$(    printf '%s\n' "$analysis" | grep "^manual_cli_changes="     | cut -d'=' -f2 | tr -d '\r')
    manual_added_long_count=$(printf '%s\n' "$analysis" | grep "^manual_added_long_count="| cut -d'=' -f2 | tr -d '\r')
    manual_removed_long_count=$(printf '%s\n' "$analysis"| grep "^manual_removed_long_count="| cut -d'=' -f2 | tr -d '\r')
    removed_short_count=$(   printf '%s\n' "$analysis" | grep "^removed_short_count="    | cut -d'=' -f2 | tr -d '\r')
    added_short_count=$(     printf '%s\n' "$analysis" | grep "^added_short_count="      | cut -d'=' -f2 | tr -d '\r')
    removed_long_count=$(    printf '%s\n' "$analysis" | grep "^removed_long_count="     | cut -d'=' -f2 | tr -d '\r')
    added_long_count=$(      printf '%s\n' "$analysis" | grep "^added_long_count="       | cut -d'=' -f2 | tr -d '\r')

    # Determine suggestion and reason
    local suggestion
    suggestion=$(suggest_version_bump "$added_files" "$modified_files" "$deleted_files" "$new_source_files" "$new_test_files" "$new_doc_files" "$cli_changes" "$breaking_cli_changes" "$diff_size" "$api_breaking" "$security_keywords" "$manual_cli_changes")

    local reason
    reason=$(get_bump_reason "$added_files" "$modified_files" "$deleted_files" "$new_source_files" "$new_test_files" "$new_doc_files" "$cli_changes" "$breaking_cli_changes" "$diff_size" "$api_breaking" "$security_keywords" "$manual_cli_changes")

    # Calculate next version
    local next_version
    next_version=$(calculate_next_version "$current_version" "$suggestion")

    # Output based on mode
    if [[ "$SUGGEST_ONLY" = "true" ]]; then
        # Output only the suggestion - FIXED: now runs analysis
        printf '%s\n' "$suggestion"
    elif [[ "$JSON_OUTPUT" = "true" ]]; then
        # JSON output for machine consumption
        local json_added_files="${added_files:-0}"
        local json_modified_files="${modified_files:-0}"
        local json_deleted_files="${deleted_files:-0}"
        local json_new_source_files="${new_source_files:-0}"
        local json_new_test_files="${new_test_files:-0}"
        local json_new_doc_files="${new_doc_files:-0}"
        local json_cli_changes="${cli_changes:-false}"
        local json_breaking_cli_changes="${breaking_cli_changes:-false}"
        local json_diff_size="${diff_size:-0}"
        local json_api_breaking="${api_breaking:-false}"
        local json_security_keywords="${security_keywords:-0}"
        local json_manual_cli_changes="${manual_cli_changes:-false}"
        local json_manual_added_long_count="${manual_added_long_count:-0}"
        local json_manual_removed_long_count="${manual_removed_long_count:-0}"
        local json_removed_short_count="${removed_short_count:-0}"
        local json_added_short_count="${added_short_count:-0}"
        local json_removed_long_count="${removed_long_count:-0}"
        local json_added_long_count="${added_long_count:-0}"

        printf '{\n'
        printf '  "suggestion": "%s",\n' "$suggestion"
        printf '  "reason": "%s",\n' "$reason"
        printf '  "current_version": "%s",\n' "$current_version"
        if [[ -n "$next_version" ]] && [[ "$suggestion" != "none" ]]; then
            printf '  "next_version": "%s",\n' "$next_version"
        fi
        printf '  "base_ref": "%s",\n' "$base_ref"
        printf '  "base_ref_type": "%s",\n' "$ref_type"
        printf '  "target_ref": "%s",\n' "$target_ref"
        printf '  "changes": {\n'
        printf '    "added_files": %s,\n' "$json_added_files"
        printf '    "modified_files": %s,\n' "$json_modified_files"
        printf '    "deleted_files": %s,\n' "$json_deleted_files"
        printf '    "new_source_files": %s,\n' "$json_new_source_files"
        printf '    "new_test_files": %s,\n' "$json_new_test_files"
        printf '    "new_doc_files": %s,\n' "$json_new_doc_files"
        printf '    "cli_changes": %s,\n' "$json_cli_changes"
        printf '    "breaking_cli_changes": %s,\n' "$json_breaking_cli_changes"
        printf '    "diff_size": %s,\n' "$json_diff_size"
        printf '    "api_breaking": %s,\n' "$json_api_breaking"
        printf '    "security_keywords": %s,\n' "$json_security_keywords"
        printf '    "manual_cli_changes": %s,\n' "$json_manual_cli_changes"
        printf '    "manual_added_long_count": %s,\n' "$json_manual_added_long_count"
        printf '    "manual_removed_long_count": %s,\n' "$json_manual_removed_long_count"
        printf '    "removed_short_count": %s,\n' "$json_removed_short_count"
        printf '    "added_short_count": %s,\n' "$json_added_short_count"
        printf '    "removed_long_count": %s,\n' "$json_removed_long_count"
        printf '    "added_long_count": %s\n' "$json_added_long_count"
        printf '  }\n'
        printf '}\n'
    elif [[ "$MACHINE_OUTPUT" = "true" ]]; then
        # Machine-readable key=value format - only SUGGESTION for --machine
        printf 'SUGGESTION=%s\n' "$suggestion"
    else
        # Human-readable output
        printf '=== Semantic Version Analysis ===\n'
        printf 'Analyzing changes: %s (%s) -> %s\n' "$base_ref" "$ref_type" "$target_ref"
        printf '\n'

        if [[ "$VERBOSE" = "true" ]]; then
            local base_commit_info
            base_commit_info=$(git -c color.ui=false log -1 --format="%H %s (%ad)" --date=short "$base_ref" 2>/dev/null || printf 'Unknown')
            printf 'Base reference: %s\n' "$base_commit_info"
            printf '\n'
        fi

        printf 'Current version: %s\n' "$current_version"
        printf '\n'

        if [[ "$VERBOSE" = "true" ]]; then
            printf '=== Detailed Analysis ===\n'
            printf 'File changes:\n'
            printf '  Added files: %s\n' "$added_files"
            printf '  Modified files: %s\n' "$modified_files"
            printf '  Deleted files: %s\n' "$deleted_files"
            printf '\n'
            printf 'New content:\n'
            printf '  New source files: %s\n' "$new_source_files"
            printf '  New test files: %s\n' "$new_test_files"
            printf '  New doc files: %s\n' "$new_doc_files"
            printf '\n'
            printf 'CLI changes:\n'
            printf '  CLI interface changes: %s\n' "$cli_changes"
            printf '  Breaking CLI changes: %s\n' "$breaking_cli_changes"
            printf '  Manual CLI changes: %s\n' "${manual_cli_changes:-false}"
            printf '  Removed short options: %s\n' "${removed_short_count:-0}"
            printf '  Added short options: %s\n' "${added_short_count:-0}"
            printf '  Removed long options: %s\n' "${removed_long_count:-0}"
            printf '  Added long options: %s\n' "${added_long_count:-0}"
            printf '\n'
            printf 'Change magnitude:\n'
            printf '  Diff size: %s lines\n' "$diff_size"
            printf '\n'
            printf 'Advanced analysis:\n'
            printf '  API breaking changes: %s\n' "${api_breaking:-false}"
            printf '  Security/crash keywords: %s\n' "${security_keywords:-0}"
            printf '\n'
            printf 'Thresholds:\n'
            printf '  Major: Breaking CLI changes or diff > %s lines (MAJOR_REQUIRE_BREAKING=%s)\n' "$MIN_MAJOR_DIFF_LINES" "$MAJOR_REQUIRE_BREAKING"
            printf '  Minor: CLI changes, new source files (â¥%s), new test files (â¥%s), new doc files (â¥%s)\n' "$MIN_NEW_SOURCE_FILES" "$MIN_NEW_TEST_FILES" "$MIN_NEW_DOC_FILES"
            printf '  Patch: Modified files (â¥%s) + diff > %s lines\n' "$MIN_PATCH_FILES" "$MIN_PATCH_DIFF_LINES"
            printf '\n'
            printf 'Recent commits:\n'
            if git -c color.ui=false rev-list "$base_ref".."$target_ref" >/dev/null 2>&1; then
                git -c color.ui=false log --oneline "$base_ref".."$target_ref" 2>/dev/null | head -20 || printf 'No commits found\n'
            else
                printf 'No commits in range\n'
            fi
            printf '\n'
        fi

        printf '=== Version Bump Suggestion ===\n'
        case "$suggestion" in
            major)
                printf 'Suggested bump: MAJOR version\n'
                if [[ "$breaking_cli_changes" = "true" ]]; then
                    printf 'Reason: Breaking CLI changes detected\n'
                elif [[ "$api_breaking" = "true" ]]; then
                    printf 'Reason: API breaking changes detected\n'
                elif [[ "${security_keywords:-0}" -gt 0 ]]; then
                    printf 'Reason: Security/crash-related changes detected (%s keywords)\n' "$security_keywords"
                else
                    printf 'Reason: Very large code changes (%s lines)\n' "$diff_size"
                fi
                printf 'Current: %s -> New: %s\n' "$current_version" "$next_version"
                ;;
            minor)
                printf 'Suggested bump: MINOR version\n'
                if [[ "$cli_changes" = "true" ]]; then
                    printf 'Reason: New CLI options added\n'
                elif [[ "${manual_cli_changes:-false}" = "true" ]]; then
                    printf 'Reason: Manual CLI changes detected\n'
                elif [[ "${new_source_files:-0}" -gt 0 ]]; then
                    printf 'Reason: New source files added (%s)\n' "$new_source_files"
                elif [[ "${new_test_files:-0}" -gt 0 ]]; then
                    printf 'Reason: New test files added (%s)\n' "$new_test_files"
                elif [[ "${new_doc_files:-0}" -gt 0 ]]; then
                    printf 'Reason: New documentation added (%s)\n' "$new_doc_files"
                else
                    printf 'Reason: New features or significant additions\n'
                fi
                printf 'Current: %s -> New: %s\n' "$current_version" "$next_version"
                ;;
            patch)
                printf 'Suggested bump: PATCH version\n'
                printf 'Reason: Significant modifications (%s files, %s lines)\n' "$modified_files" "$diff_size"
                printf 'Current: %s -> New: %s\n' "$current_version" "$next_version"
                ;;
            none)
                printf 'Suggested bump: NONE\n'
                printf 'Reason: No significant changes detected\n'
                ;;
        esac

        printf '\n'

        # Only show apply command if there's a suggestion and the script exists
        if [[ "$suggestion" != "none" ]]; then
            if [[ -x ./dev-bin/bump-version ]]; then
                printf 'To apply this suggestion:\n'
                printf '  ./dev-bin/bump-version %s --commit\n' "$suggestion"
                printf '\n'
                printf 'Or use GitHub Actions:\n'
                printf '  Go to Actions -> Auto Version Bump -> Run workflow -> Choose: %s\n' "$suggestion"
            else
                printf 'Note: bump-version script not found at ./dev-bin/bump-version\n'
                printf 'Preview unavailable - manual version update required\n'
            fi
        fi

        # Always include SUGGESTION= line in human/verbose output
        printf 'SUGGESTION=%s\n' "$suggestion"
    fi

    # Set exit code based on suggestion
    case "$suggestion" in
        major) exit 10 ;;
        minor) exit 11 ;;
        patch) exit 12 ;;
        none) exit 20 ;;
        *) exit 0 ;;
    esac
}

# Run main function
main "$@"
