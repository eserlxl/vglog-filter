#!/bin/bash
# Copyright Â© 2025 Eser KUBALI <lxldev.contact@gmail.com>
# SPDX-License-Identifier: GPL-3.0-or-later
#
# This file is part of vglog-filter and is licensed under
# the GNU General Public License v3.0 or later.
# See the LICENSE file in the project root for details.
#
# Semantic Version Analyzer v2 for vglog-filter
# Orchestrates modular components for version analysis

set -Eeuo pipefail
IFS=$'\n\t'
export LC_ALL=C

show_help() {
    cat << EOF
Semantic Version Analyzer v2 for vglog-filter

Usage: $(basename "$0") [options]

Options:
  --since <tag>            Analyze changes since specific tag (default: last tag)
  --since-tag <tag>        Alias for --since
  --since-commit <hash>    Analyze changes since specific commit
  --since-date <date>      Analyze changes since specific date (YYYY-MM-DD)
  --base <ref>             Set base reference for comparison (default: auto-detected)
  --target <ref>           Set target reference for comparison (default: HEAD)
  --repo-root <path>       Set repository root directory
  --no-merge-base          Disable automatic merge-base detection for disjoint branches
  --only-paths <globs>     Restrict analysis to comma-separated path globs
  --ignore-whitespace      Ignore whitespace changes in diff analysis
  --verbose                Show detailed analysis
  --machine                Output machine-readable key=value format (SUGGESTION only)
  --json                   Output machine-readable JSON
  --suggest-only           Output only the suggestion (major/minor/patch/none)
  --strict-status          Use strict exit codes even with --suggest-only
  --help, -h               Show this help

Examples:
  $(basename "$0") --since v1.1.0
  $(basename "$0") --since-date 2025-01-01
  $(basename "$0") --base HEAD~5 --target HEAD
  $(basename "$0") --base v1.0.0 --target v1.1.0
  $(basename "$0") --only-paths "src/**,include/**"
  $(basename "$0") --verbose
  $(basename "$0") --machine
  $(basename "$0") --json

Exit codes:
  10 = major version bump suggested
  11 = minor version bump suggested
  12 = patch version bump suggested
  20 = no version bump suggested
EOF
}

# Parse arguments
SINCE_TAG=""
SINCE_COMMIT=""
SINCE_DATE=""
BASE_REF=""
TARGET_REF=""
REPO_ROOT=""
NO_MERGE_BASE=false
ONLY_PATHS=""
IGNORE_WHITESPACE=false
VERBOSE=false
MACHINE_OUTPUT=false
JSON_OUTPUT=false
SUGGEST_ONLY=false
STRICT_STATUS=false

# Global variables for bonus calculation
TOTAL_BONUS=0

while [[ $# -gt 0 ]]; do
    case $1 in
        --since|--since-tag)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --since requires a value\n' >&2; exit 1; }
            SINCE_TAG="$2"; shift 2;;
        --since-commit)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --since-commit requires a value\n' >&2; exit 1; }
            SINCE_COMMIT="$2"; shift 2;;
        --since-date)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --since-date requires a value\n' >&2; exit 1; }
            SINCE_DATE="$2"; shift 2;;
        --base)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --base requires a value\n' >&2; exit 1; }
            BASE_REF="$2"; shift 2;;
        --target)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --target requires a value\n' >&2; exit 1; }
            TARGET_REF="$2"; shift 2;;
        --repo-root)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --repo-root requires a value\n' >&2; exit 1; }
            REPO_ROOT="$2"; shift 2;;
        --no-merge-base) NO_MERGE_BASE=true; shift;;
        --only-paths)
            [[ -n "${2-}" && "${2#-}" = "$2" ]] || { printf 'Error: --only-paths requires a comma-separated globs list\n' >&2; exit 1; }
            ONLY_PATHS="$2"; shift 2;;
        --ignore-whitespace) IGNORE_WHITESPACE=true; shift;;
        --verbose) VERBOSE=true; shift;;
        --machine) MACHINE_OUTPUT=true; shift;;
        --json) JSON_OUTPUT=true; shift;;
        --suggest-only) SUGGEST_ONLY=true; shift;;
        --strict-status) STRICT_STATUS=true; shift;;
        --help|-h) show_help; exit 0;;
        *) printf 'Error: Unknown option: %s\n' "$1" >&2; show_help; exit 1;;
    esac
done

# Check if required binaries exist
check_binary() {
    local binary="$1"
    if [[ ! -x "$binary" ]]; then
        printf 'Error: Required binary not found: %s\n' "$binary" >&2
        exit 1
    fi
}

check_binary "./dev-bin/ref-resolver"
check_binary "./dev-bin/version-config-loader"
check_binary "./dev-bin/file-change-analyzer"
check_binary "./dev-bin/cli-options-analyzer"
check_binary "./dev-bin/security-keyword-analyzer"
check_binary "./dev-bin/version-calculator"

# Build common arguments for all components
build_common_args() {
    local args=""
    [[ -n "$BASE_REF" ]] && args="$args --base '$BASE_REF'"
    [[ -n "$TARGET_REF" ]] && args="$args --target '$TARGET_REF'"
    [[ -n "$REPO_ROOT" ]] && args="$args --repo-root '$REPO_ROOT'"
    [[ -n "$ONLY_PATHS" ]] && args="$args --only-paths '$ONLY_PATHS'"
    [[ "$IGNORE_WHITESPACE" = "true" ]] && args="$args --ignore-whitespace"
    # Only pass --machine for internal component calls, not --json
    [[ "$MACHINE_OUTPUT" = "true" ]] && args="$args --machine"
    printf '%s' "$args"
}

# Build ref resolver arguments
build_ref_args() {
    local args=""
    [[ -n "$SINCE_TAG" ]] && args="$args --since '$SINCE_TAG'"
    [[ -n "$SINCE_COMMIT" ]] && args="$args --since-commit '$SINCE_COMMIT'"
    [[ -n "$SINCE_DATE" ]] && args="$args --since-date '$SINCE_DATE'"
    [[ -n "$BASE_REF" ]] && args="$args --base '$BASE_REF'"
    [[ -n "$TARGET_REF" ]] && args="$args --target '$TARGET_REF'"
    [[ -n "$REPO_ROOT" ]] && args="$args --repo-root '$REPO_ROOT'"
    [[ "$NO_MERGE_BASE" = "true" ]] && args="$args --no-merge-base"
    [[ "$MACHINE_OUTPUT" = "true" ]] && args="$args --machine"
    [[ "$JSON_OUTPUT" = "true" ]] && args="$args --json"
    printf '%s' "$args"
}

# Parse machine output into associative array
parse_machine_output() {
    local output="$1"
    local -A result
    while IFS='=' read -r key value; do
        [[ -n "$key" ]] && result["$key"]="$value"
    done <<< "$output"
    printf '%s' "$(declare -p result)"
}

# Main analysis function
main() {
    # Step 1: Resolve references
    [[ "$VERBOSE" = "true" ]] && printf 'Verbose: Resolving git references...\n' >&2
    local ref_args
    ref_args=$(build_ref_args)
    local ref_output
    ref_output=$(eval "./dev-bin/ref-resolver $ref_args")
    
    if [[ "$MACHINE_OUTPUT" = "true" ]]; then
        # Parse machine output
        local ref_data
        ref_data=$(parse_machine_output "$ref_output")
        eval "$ref_data"
        
        # Check if single commit repo
        if [[ "${result[SINGLE_COMMIT_REPO]:-false}" = "true" ]]; then
            printf 'SUGGESTION=none\n'
            exit 20
        fi
        
        # Check if no commits
        if [[ "${result[HAS_COMMITS]:-false}" = "false" ]]; then
            printf 'SUGGESTION=none\n'
            exit 20
        fi
        
        BASE_REF="${result[BASE_REF]}"
        TARGET_REF="${result[TARGET_REF]}"
    else
        # For non-machine output, extract base and target from JSON or parse output
        # This is a simplified version - in practice you'd parse JSON properly
        BASE_REF=$(printf '%s' "$ref_output" | grep -o '"base_ref":"[^"]*"' | cut -d'"' -f4 || echo "HEAD~1")
        TARGET_REF=$(printf '%s' "$ref_output" | grep -o '"target_ref":"[^"]*"' | cut -d'"' -f4 || echo "HEAD")
    fi
    
    # Step 2: Load configuration
    [[ "$VERBOSE" = "true" ]] && printf 'Verbose: Loading version configuration...\n' >&2
    local config_output
    config_output=$(./dev-bin/version-config-loader --machine)
    
    # Parse configuration output manually
    declare -A config_data
    while IFS='=' read -r key value; do
        [[ -n "$key" ]] && config_data["$key"]="$value"
    done <<< "$config_output"
    
    # Step 3: Analyze file changes
    [[ "$VERBOSE" = "true" ]] && printf 'Verbose: Analyzing file changes...\n' >&2
    local common_args
    common_args=$(build_common_args)
    # Force machine output for internal component calls
    local file_output
    file_output=$(eval "./dev-bin/file-change-analyzer $common_args --machine")
    
    # Step 4: Analyze CLI options
    [[ "$VERBOSE" = "true" ]] && printf 'Verbose: Analyzing CLI options...\n' >&2
    local cli_output
    cli_output=$(eval "./dev-bin/cli-options-analyzer $common_args --machine")
    
    # Step 5: Analyze security keywords
    [[ "$VERBOSE" = "true" ]] && printf 'Verbose: Analyzing security keywords...\n' >&2
    local security_output
    security_output=$(eval "./dev-bin/security-keyword-analyzer $common_args --machine")
    
    # Step 6: Analyze keywords for breaking changes and bonuses
    [[ "$VERBOSE" = "true" ]] && printf 'Verbose: Analyzing keywords...\n' >&2
    local keyword_output
    keyword_output=$(eval "./dev-bin/keyword-analyzer $common_args --machine")
    
    # Initialize result arrays with defaults
    declare -A file_result cli_result security_result keyword_result
    
    # Parse file analysis results directly
    while IFS='=' read -r key value; do
        [[ -n "$key" ]] && file_result["$key"]="$value"
    done <<< "$file_output"
    
    # Parse CLI analysis results directly
    while IFS='=' read -r key value; do
        [[ -n "$key" ]] && cli_result["$key"]="$value"
    done <<< "$cli_output"
    
    # Parse security analysis results directly
    while IFS='=' read -r key value; do
        [[ -n "$key" ]] && security_result["$key"]="$value"
    done <<< "$security_output"
    
    # Parse keyword analysis results directly
    while IFS='=' read -r key value; do
        [[ -n "$key" ]] && keyword_result["$key"]="$value"
    done <<< "$keyword_output"
    
    # Step 7: Calculate bonus points
    TOTAL_BONUS=0
    
    # Debug: Print keyword results
    if [[ "$VERBOSE" = "true" ]]; then
        printf 'Debug: Keyword results:\n' >&2
        printf '  HAS_CLI_BREAKING: %s\n' "${keyword_result[HAS_CLI_BREAKING]:-false}" >&2
        printf '  HAS_API_BREAKING: %s\n' "${keyword_result[HAS_API_BREAKING]:-false}" >&2
        printf '  TOTAL_SECURITY: %s\n' "${keyword_result[TOTAL_SECURITY]:-0}" >&2
    fi
    
    # Breaking changes from keyword analysis (takes precedence over CLI analysis)
    if [[ "${keyword_result[HAS_CLI_BREAKING]:-false}" = "true" ]]; then
        TOTAL_BONUS=$((TOTAL_BONUS + ${config_data[VERSION_BREAKING_CLI_BONUS]:-2}))
    elif [[ "${cli_result[BREAKING_CLI_CHANGES]:-false}" = "true" ]]; then
        TOTAL_BONUS=$((TOTAL_BONUS + ${config_data[VERSION_BREAKING_CLI_BONUS]:-2}))
    fi
    
    if [[ "${keyword_result[HAS_API_BREAKING]:-false}" = "true" ]]; then
        TOTAL_BONUS=$((TOTAL_BONUS + ${config_data[VERSION_API_BREAKING_BONUS]:-3}))
    elif [[ "${cli_result[API_BREAKING]:-false}" = "true" ]]; then
        TOTAL_BONUS=$((TOTAL_BONUS + ${config_data[VERSION_API_BREAKING_BONUS]:-3}))
    fi
    
    # Security keywords (combine both sources)
    local security_keywords="${security_result[SECURITY_KEYWORDS]:-0}"
    local keyword_security="${keyword_result[TOTAL_SECURITY]:-0}"
    local total_security=$((security_keywords + keyword_security))
    if [[ "$total_security" -gt 0 ]]; then
        TOTAL_BONUS=$((TOTAL_BONUS + total_security * ${config_data[VERSION_SECURITY_BONUS]:-2}))
    fi
    
    # Feature additions
    if [[ "${cli_result[CLI_CHANGES]:-false}" = "true" ]]; then
        TOTAL_BONUS=$((TOTAL_BONUS + ${config_data[VERSION_CLI_CHANGES_BONUS]:-2}))
    fi
    if [[ "${cli_result[MANUAL_CLI_CHANGES]:-false}" = "true" ]]; then
        TOTAL_BONUS=$((TOTAL_BONUS + ${config_data[VERSION_MANUAL_CLI_BONUS]:-1}))
    fi
    if [[ "${file_result[NEW_SOURCE_FILES]:-0}" -gt 0 ]]; then
        TOTAL_BONUS=$((TOTAL_BONUS + ${config_data[VERSION_NEW_SOURCE_BONUS]:-1}))
    fi
    if [[ "${file_result[NEW_TEST_FILES]:-0}" -gt 0 ]]; then
        TOTAL_BONUS=$((TOTAL_BONUS + ${config_data[VERSION_NEW_TEST_BONUS]:-1}))
    fi
    if [[ "${file_result[NEW_DOC_FILES]:-0}" -gt 0 ]]; then
        TOTAL_BONUS=$((TOTAL_BONUS + ${config_data[VERSION_NEW_DOC_BONUS]:-1}))
    fi
    
    # Removed features (combine both sources)
    local cli_removed=$(( ${cli_result[REMOVED_SHORT_COUNT]:-0} + ${cli_result[REMOVED_LONG_COUNT]:-0} ))
    local keyword_removed="${keyword_result[REMOVED_OPTIONS_KEYWORDS]:-0}"
    local total_removed=$((cli_removed + keyword_removed))
    if [[ "$total_removed" -gt 0 ]]; then
        TOTAL_BONUS=$((TOTAL_BONUS + ${config_data[VERSION_REMOVED_OPTION_BONUS]:-1}))
    fi
    
    # Debug: Print final bonus calculation
    if [[ "$VERBOSE" = "true" ]]; then
        printf 'Debug: Final TOTAL_BONUS: %s\n' "$TOTAL_BONUS" >&2
    fi
    
    # Step 8: Determine suggestion based on bonus thresholds
    local major_threshold="${config_data[MAJOR_BONUS_THRESHOLD]:-8}"
    local minor_threshold="${config_data[MINOR_BONUS_THRESHOLD]:-4}"
    local patch_threshold="${config_data[PATCH_BONUS_THRESHOLD]:-0}"
    
    # Use default values if not available from config
    major_threshold="${major_threshold:-8}"
    minor_threshold="${minor_threshold:-4}"
    patch_threshold="${patch_threshold:-0}"
    
    local suggestion="none"
    if [[ "$TOTAL_BONUS" -ge "$major_threshold" ]]; then
        suggestion="major"
    elif [[ "$TOTAL_BONUS" -ge "$minor_threshold" ]]; then
        suggestion="minor"
    elif [[ "$TOTAL_BONUS" -ge "$patch_threshold" ]]; then
        suggestion="patch"
    fi
    
    # Step 9: Get current version
    local current_version="0.0.0"
    if [[ -f "VERSION" ]]; then
        current_version=$(tr -d '[:space:]' < "VERSION" 2>/dev/null || printf '0.0.0')
        [[ $current_version =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]] || current_version=0.0.0
    fi
    
    # Step 10: Calculate next version if needed
    local next_version=""
    if [[ "$suggestion" != "none" ]]; then
        local calc_args="--current-version '$current_version' --bump-type '$suggestion' --loc '${file_result[DIFF_SIZE]:-0}' --bonus '$TOTAL_BONUS'"
        [[ "$MACHINE_OUTPUT" = "true" ]] && calc_args="$calc_args --machine"
        [[ "$JSON_OUTPUT" = "true" ]] && calc_args="$calc_args --json"
        
        local calc_output
        calc_output=$(eval "./dev-bin/version-calculator $calc_args")
        
        if [[ "$MACHINE_OUTPUT" = "true" ]]; then
            local calc_data
            calc_data=$(parse_machine_output "$calc_output")
            eval "$calc_data"
            next_version="${result[NEXT_VERSION]}"
        else
            next_version=$(printf '%s' "$calc_output" | grep -o '"next_version":"[^"]*"' | cut -d'"' -f4 || echo "")
        fi
    fi
    
    # Step 11: Output results
    if [[ "$SUGGEST_ONLY" = "true" ]]; then
        printf '%s\n' "$suggestion"
    elif [[ "$JSON_OUTPUT" = "true" ]]; then
        printf '{\n'
        printf '  "suggestion": "%s",\n' "$suggestion"
        printf '  "current_version": "%s",\n' "$current_version"
        if [[ -n "$next_version" ]]; then
            printf '  "next_version": "%s",\n' "$next_version"
        fi
        printf '  "total_bonus": %s,\n' "$TOTAL_BONUS"
        printf '  "base_ref": "%s",\n' "$BASE_REF"
        printf '  "target_ref": "%s",\n' "$TARGET_REF"
        # Calculate LOC deltas with bonus points
        local patch_delta_json
        patch_delta_json=$(./dev-bin/version-calculator --current-version "$current_version" --bump-type patch --loc "${file_result[DIFF_SIZE]:-0}" --bonus "$TOTAL_BONUS" --json 2>/dev/null || echo '{"total_delta": 1}')
        local minor_delta_json
        minor_delta_json=$(./dev-bin/version-calculator --current-version "$current_version" --bump-type minor --loc "${file_result[DIFF_SIZE]:-0}" --bonus "$TOTAL_BONUS" --json 2>/dev/null || echo '{"total_delta": 5}')
        local major_delta_json
        major_delta_json=$(./dev-bin/version-calculator --current-version "$current_version" --bump-type major --loc "${file_result[DIFF_SIZE]:-0}" --bonus "$TOTAL_BONUS" --json 2>/dev/null || echo '{"total_delta": 10}')
        
        local patch_delta
        patch_delta=$(printf '%s' "$patch_delta_json" | grep -o '"total_delta":[[:space:]]*[0-9]*' | cut -d: -f2 | tr -d ' ' || echo "1")
        local minor_delta
        minor_delta=$(printf '%s' "$minor_delta_json" | grep -o '"total_delta":[[:space:]]*[0-9]*' | cut -d: -f2 | tr -d ' ' || echo "5")
        local major_delta
        major_delta=$(printf '%s' "$major_delta_json" | grep -o '"total_delta":[[:space:]]*[0-9]*' | cut -d: -f2 | tr -d ' ' || echo "10")
        
        printf '  "loc_delta": {\n'
        printf '    "patch_delta": %s,\n' "$patch_delta"
        printf '    "minor_delta": %s,\n' "$minor_delta"
        printf '    "major_delta": %s\n' "$major_delta"
        printf '  }\n'
        printf '}\n'
    elif [[ "$MACHINE_OUTPUT" = "true" ]]; then
        printf 'SUGGESTION=%s\n' "$suggestion"
    else
        printf '=== Semantic Version Analysis v2 ===\n'
        printf 'Analyzing changes: %s -> %s\n' "$BASE_REF" "$TARGET_REF"
        printf '\nCurrent version: %s\n' "$current_version"
        printf 'Total bonus points: %s\n' "$TOTAL_BONUS"
        printf '\nSuggested bump: %s\n' "$(printf '%s' "$suggestion" | tr '[:lower:]' '[:upper:]')"
        if [[ -n "$next_version" ]]; then
            printf 'Next version: %s\n' "$next_version"
        fi
        printf '\nSUGGESTION=%s\n' "$suggestion"
    fi
    
    # Set exit code
    if [[ "$SUGGEST_ONLY" = "true" ]] && [[ "$STRICT_STATUS" != "true" ]]; then
        exit 0
    else
        case "$suggestion" in
            major) exit 10 ;;
            minor) exit 11 ;;
            patch) exit 12 ;;
            none) exit 20 ;;
            *) exit 0 ;;
        esac
    fi
}

# Run main function
main "$@" 