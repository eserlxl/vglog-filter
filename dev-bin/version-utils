#!/bin/bash
# Copyright Â© 2025 Eser KUBALI <lxldev.contact@gmail.com>
# SPDX-License-Identifier: GPL-3.0-or-later
#
# This file is part of vglog-filter and is licensed under
# the GNU General Public License v3.0 or later.
# See the LICENSE file in the project root for details.
#
# Version utilities for vglog-filter
# Common functions used across version management scripts

set -euo pipefail

# Ensure consistent locale and behavior
export LC_ALL=C

# Set predictable file permissions
umask 022

# --- Color utilities ----------------------------------------------------------
init_colors() {
    local no_color="${1:-false}"
    if [[ "$no_color" != "true" && -t 2 ]]; then
        RED=$'\033[0;31m'
        GREEN=$'\033[0;32m'
        YELLOW=$'\033[1;33m'
        CYAN=$'\033[0;36m'
        RESET=$'\033[0m'
    else
        RED='' ; GREEN='' ; YELLOW='' ; CYAN='' ; RESET=''
    fi
}

# --- Path resolution ----------------------------------------------------------
resolve_script_paths() {
    local script_path="$1"
    local repo_root="${2:-}"
    
    SCRIPT_DIR="$(dirname "$(realpath "$script_path")")"
    PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
    VERSION_FILE="$PROJECT_ROOT/VERSION"
    
    if [[ -n "$repo_root" ]]; then
        [[ -d "$repo_root" ]] || { printf '%s\n' "${RED}Error: Repository root '$repo_root' does not exist${RESET}" >&2; exit 1; }
        PROJECT_ROOT="$repo_root"
        VERSION_FILE="$PROJECT_ROOT/VERSION"
        cd "$PROJECT_ROOT"
        printf '%s\n' "${CYAN}Using repository root: $PROJECT_ROOT${RESET}" >&2
    else
        cd "$PROJECT_ROOT"
    fi
}

# --- Dependency helpers -------------------------------------------------------
_hash_file() {
    if command -v sha1sum >/dev/null 2>&1; then
        sha1sum "$1" | awk '{print $1}'
    elif command -v shasum >/dev/null 2>&1; then
        shasum -a 1 "$1" | awk '{print $1}'
    else
        # Last-resort: no hashing available; return empty (features using it will behave gracefully)
        printf ''
    fi
}

require_cmd() {
    local missing=()
    for c in git realpath sed grep awk; do
        command -v "$c" >/dev/null 2>&1 || missing+=("$c")
    done
    if ((${#missing[@]} > 0)); then
        printf 'Error: Missing required tools: %s\n' "${missing[*]}" >&2
        exit 1
    fi
}

# --- Cleanup utilities --------------------------------------------------------
setup_cleanup() {
    local tmp_file_var="$1"
    eval "$tmp_file_var=\"\""
    
    cleanup() {
        if [[ -n "${TMP_FILE:-}" ]]; then
            rm -f "${TMP_FILE}" 2>/dev/null || true
        fi
    }
    trap cleanup INT TERM EXIT
}

# --- File operations ----------------------------------------------------------
safe_write_file() {
    local target_file="$1"
    local content="$2"
    local tmp_file="${target_file}.tmp.$$"
    
    printf '%s\n' "$content" > "$tmp_file"
    
    # Best-effort durability
    sync -f "$tmp_file" 2>/dev/null || sync "$tmp_file" 2>/dev/null || sync || true
    mv -f "$tmp_file" "$target_file"
    
    # Update the tmp file variable for cleanup
    TMP_FILE="$tmp_file"
    
    sync -f "$target_file" 2>/dev/null || sync -f "$(dirname "$target_file")" 2>/dev/null || sync || true
}

# --- Git utilities -----------------------------------------------------------
check_git_repo() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        printf '%s\n' "${RED}Error: Not in a git repository${RESET}" >&2
        exit 1
    fi
}

check_git_branch() {
    if ! git symbolic-ref -q HEAD >/dev/null; then
        printf '%s\n' "${RED}Error: Detached HEAD; checkout a branch before committing/tagging${RESET}" >&2
        exit 1
    fi
}

check_git_identity() {
    git config --get user.name >/dev/null || printf '%s\n' "${YELLOW}Warning: git user.name is not set${RESET}" >&2
    git config --get user.email >/dev/null || printf '%s\n' "${YELLOW}Warning: git user.email is not set${RESET}" >&2
}

# --- Version file utilities ---------------------------------------------------
read_version_file() {
    local version_file="$1"
    if [[ -f "$version_file" ]]; then
        tr -d '[:space:]' < "$version_file" 2>/dev/null || printf ''
    else
        printf ''
    fi
}

validate_version_file_path() {
    local version_file="$1"
    local project_root="$2"
    
    local version_real
    version_real="$(realpath -e "$version_file" 2>/dev/null || printf '')"
    if [[ -z "$version_real" ]]; then
        printf '%s\n' "${RED}Error: VERSION path is a broken symlink${RESET}" >&2
        exit 1
    fi
    case "$version_real" in
        "$project_root"/*) : ;;
        *) printf '%s\n' "${RED}Error: VERSION resolves outside repo${RESET}" >&2; exit 1 ;;
    esac
}

# --- CMake utilities ---------------------------------------------------------
has_cmake_version_field() {
    local cmake="$1"
    [[ -f "$cmake" ]] || return 1
    if grep -Eq '^[[:space:]]*project\([^)]*VERSION[[:space:]]+\$\{[^}]+\}' "$cmake"; then
        return 0
    elif grep -Eq '^[[:space:]]*project\([^)]*VERSION[[:space:]]+[0-9]+\.[0-9]+\.[0-9]+' "$cmake"; then
        return 0
    elif grep -Eq '^[[:space:]]*set[[:space:]]*\([[:space:]]*PROJECT_VERSION[[:space:]]+"?[0-9]+\.[0-9]+\.[0-9]+' "$cmake"; then
        return 0
    fi
    return 1
}

# --- Tag utilities -----------------------------------------------------------
sanitize_tag_prefix() {
    local p="$1"
    p="${p//\\/\\\\}"   # \  -> \\
    p="${p//\*/\\*}"    # *  -> \*
    p="${p//\?/\\?}"    # ?  -> \?
    p="${p//\[/\\[}"    # [  -> \[
    p="${p//\]/\\]}"    # ]  -> \]
    printf '%s' "$p"
}

last_tag_for_prefix() {
    local tag_prefix="$1"
    local sanitized_prefix
    sanitized_prefix=$(sanitize_tag_prefix "$tag_prefix")
    local pattern="${sanitized_prefix}[0-9]*.[0-9]*.[0-9]*"
    local t=""
    t=$(git tag --list "$pattern" --sort=-version:refname | head -n1 || true)
    if [[ -z "$t" ]]; then
        t=$(git tag --list "$pattern" --sort=-v:refname | head -n1 || true)
    fi
    printf '%s' "$t"
}

# --- Standalone usage --------------------------------------------------------
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    # Initialize colors
    init_colors "${NO_COLOR:-false}"
    
    case "${1:-}" in
        "last-tag")
            if [[ $# -lt 2 ]]; then
                die "Usage: $0 last-tag <tag_prefix>"
            fi
            last_tag_for_prefix "$2"
            ;;
        "hash-file")
            if [[ $# -lt 2 ]]; then
                die "Usage: $0 hash-file <file_path>"
            fi
            _hash_file "$2"
            ;;
        "read-version")
            if [[ $# -lt 2 ]]; then
                die "Usage: $0 read-version <version_file>"
            fi
            read_version_file "$2"
            ;;
        *)
            cat << EOF
Usage: $0 <command> [args...]

Commands:
  last-tag <tag_prefix>              Get last tag for prefix
  hash-file <file_path>              Hash a file
  read-version <version_file>        Read version from file

Examples:
  $0 last-tag v
  $0 hash-file CMakeLists.txt
  $0 read-version VERSION
EOF
            exit 1
            ;;
    esac
fi

# --- Error handling ----------------------------------------------------------
die() {
    printf '%s\n' "${RED}Error: $1${RESET}" >&2
    exit 1
}

warn() {
    printf '%s\n' "${YELLOW}Warning: $1${RESET}" >&2
}

info() {
    printf '%s\n' "${CYAN}$1${RESET}" >&2
}

success() {
    printf '%s\n' "${GREEN}$1${RESET}" >&2
}

# --- Validation utilities ----------------------------------------------------
is_uint() {
    [[ "$1" =~ ^[0-9]+$ ]]
}

is_semver() {
    [[ "$1" =~ ^(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)$ ]]
}

is_semver_with_prerelease() {
    [[ "$1" =~ ^(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)(-[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?$ ]]
} 