#!/bin/bash
# Copyright Â© 2025 Eser KUBALI <lxldev.contact@gmail.com>
# SPDX-License-Identifier: GPL-3.0-or-later
#
# Version utilities for vglog-filter
# Common functions used across version management scripts

set -Eeuo pipefail
umask 022
export LC_ALL=C

# ------------------- error & messaging -------------------
# Print to stderr to keep stdout clean for machine output.
_die()   { printf '%s\n' "${RED:-}Error:${RESET:-} $*">&2; exit 1; }
_warn()  { printf '%s\n' "${YELLOW:-}Warning:${RESET:-} $*">&2; }
_info()  { printf '%s\n' "${CYAN:-}$*${RESET:-}">&2; }
_ok()    { printf '%s\n' "${GREEN:-}$*${RESET:-}">&2; }

# Trap to show failing line for unexpected errors.
trap 'rc=$?; [[ $rc -ne 0 ]] && printf "Error on line %s: %s (exit %s)\n" "$LINENO" "$BASH_COMMAND" "$rc" >&2' ERR

# ------------------- color utilities -------------------
init_colors() {
  # honor NO_COLOR spec (https://no-color.org/)
  local no_color="${1:-${NO_COLOR:-false}}"
  if [[ "$no_color" != "true" && -t 2 ]]; then
    RED=$'\033[0;31m'
    GREEN=$'\033[0;32m'
    YELLOW=$'\033[1;33m'
    CYAN=$'\033[0;36m'
    RESET=$'\033[0m'
  else
    RED= GREEN= YELLOW= CYAN= RESET=
  fi
}

# ------------------- command requirements -------------------
require_cmd() {
  local need=("$@")
  # Default baseline if none provided
  if ((${#need[@]} == 0)); then
    need=(git realpath sed grep awk)
  fi
  local missing=()
  for c in "${need[@]}"; do
    command -v "$c" >/dev/null 2>&1 || missing+=("$c")
  done
  ((${#missing[@]}==0)) || _die "Missing required tools: ${missing[*]}"
}

# ------------------- path resolution -------------------
# Exports: PROJECT_ROOT, VERSION_FILE
resolve_script_paths() {
  local script_path="$1"
  local repo_root="${2:-}"

  local script_dir project_root version_file try_git_root
  script_dir="$(dirname "$(realpath "$script_path")")"

  if [[ -n "$repo_root" ]]; then
    [[ -d "$repo_root" ]] || _die "Repository root '$repo_root' does not exist"
    project_root="$(realpath "$repo_root")"
  else
    # Prefer git repo root if available
    if command -v git >/dev/null 2>&1 && try_git_root="$(git -C "$script_dir" rev-parse --show-toplevel 2>/dev/null || true)"; then
      if [[ -n "$try_git_root" && -d "$try_git_root" ]]; then
        project_root="$try_git_root"
      else
        project_root="$(dirname "$script_dir")"
      fi
    else
      project_root="$(dirname "$script_dir")"
    fi
  fi

  version_file="$project_root/VERSION"
  cd "$project_root" || _die "Cannot cd to $project_root"

  export PROJECT_ROOT="$project_root"
  export VERSION_FILE="$version_file"
}

# ------------------- cleanup helpers -------------------
# Usage: setup_cleanup "TMP_FILE_VAR"
setup_cleanup() {
  local tmp_var="$1"
  # shellcheck disable=SC2034
  eval "$tmp_var=''"
  cleanup() {
    local f="${TMP_FILE:-}"
    if [[ -n "$f" && -e "$f" ]]; then rm -f -- "$f" 2>/dev/null || true; fi
  }
  trap cleanup INT TERM EXIT
}

# ------------------- file operations -------------------
# Atomic write: write to temp in same directory, then mv.
safe_write_file() {
  local target_file="$1"; shift
  local content="${1-}"
  local dir base tmp

  dir="$(dirname -- "$target_file")"
  base="$(basename -- "$target_file")"
  tmp="$(mktemp --tmpdir="$dir" ".${base}.XXXXXX")" || _die "mktemp failed for $target_file"

  # Expose for trap in case we die before mv
  TMP_FILE="$tmp"

  printf '%s\n' "$content" > "$tmp" || _die "Cannot write temp file"
  # Best-effort durability without relying on non-portable `sync -f`
  if command -v python3 >/dev/null 2>&1; then
    # fsync via tiny python (works on most CI images)
    python3 - <<'PY' "$tmp"
import os, sys
p=sys.argv[1]
fd=os.open(p, os.O_RDONLY)
try:
    os.fsync(fd)
finally:
    os.close(fd)
PY
  fi

  mv -f -- "$tmp" "$target_file" || _die "Cannot move temp file into place"
  # Clear TMP_FILE (temp is gone after mv)
  TMP_FILE=""
}

# ------------------- hashing -------------------
# Prefer sha256; fall back gracefully.
_hash_file() {
  local f="$1"
  if command -v sha256sum >/dev/null 2>&1; then
    sha256sum "$f" | awk '{print $1}'
  elif command -v shasum >/dev/null 2>&1; then
    shasum -a 256 "$f" | awk '{print $1}'
  elif command -v sha1sum >/dev/null 2>&1; then
    sha1sum "$f" | awk '{print $1}'
  elif command -v md5sum >/dev/null 2>&1; then
    md5sum "$f" | awk '{print $1}'
  else
    printf ''  # no hasher; callers should tolerate empty
  fi
}

# ------------------- git utilities -------------------
check_git_repo() {
  git rev-parse --git-dir >/dev/null 2>&1 || _die "Not in a git repository"
}

check_git_branch() {
  git symbolic-ref -q HEAD >/dev/null || _die "Detached HEAD; checkout a branch before committing/tagging"
}

check_git_identity() {
  local n e
  n="$(git config --get user.name || true)"
  e="$(git config --get user.email || true)"
  [[ -n "$n" ]] || _warn "git user.name is not set"
  [[ -n "$e" ]] || _warn "git user.email is not set"
}

# ------------------- version file utilities -------------------
read_version_file() {
  local vf="$1"
  [[ -f "$vf" ]] || { printf ''; return 0; }
  tr -d '[:space:]' < "$vf" 2>/dev/null || printf ''
}

validate_version_file_path() {
  local version_file="$1"
  local project_root="$2"
  local resolved
  resolved="$(realpath -e -- "$version_file" 2>/dev/null || true)"
  [[ -n "$resolved" ]] || _die "VERSION path is a broken symlink"
  case "$resolved" in
    "$project_root"/*) : ;;
    *) _die "VERSION resolves outside repo" ;;
  esac
}

# ------------------- CMake utilities -------------------
has_cmake_version_field() {
  local cmake="$1"
  [[ -f "$cmake" ]] || return 1
  # project(... VERSION X.Y.Z) or project(... VERSION ${VAR})
  grep -Ei '^[[:space:]]*project[[:space:]]*\([^)]*version[[:space:]]+([0-9]+\.[0-9]+\.[0-9]+|\$\{[^}]+\})' "$cmake" >/dev/null && return 0
  # set(PROJECT_VERSION "X.Y.Z")
  grep -Ei '^[[:space:]]*set[[:space:]]*\([[:space:]]*project_version[[:space:]]+"?[0-9]+\.[0-9]+\.[0-9]+' "$cmake" >/dev/null && return 0
  return 1
}

# ------------------- tag utilities -------------------
# Escape only glob specials for `git tag --list` (fnmatch), not regex.
sanitize_tag_prefix() {
  local p="$1"
  p="${p//\\/\\\\}"  # \ -> \\
  p="${p//\*/\\*}"   # * -> \*
  p="${p//\?/\\?}"   # ? -> \?
  p="${p//\[/\\[}"   # [ -> \[
  p="${p//\]/\\]}"   # ] -> \]
  printf '%s' "$p"
}

last_tag_for_prefix() {
  local tag_prefix="$1"
  local sanitized
  sanitized="$(sanitize_tag_prefix "$tag_prefix")"
  local pattern="${sanitized}[0-9]*.[0-9]*.[0-9]*"
  local t=""
  t="$(git tag --list "$pattern" --sort=-version:refname | head -n1 || true)"
  [[ -n "$t" ]] || t="$(git tag --list "$pattern" --sort=-v:refname | head -n1 || true)"
  printf '%s' "$t"
}

# ------------------- validation utilities -------------------
is_uint() { [[ "$1" =~ ^[0-9]+$ ]]; }

# Strict semver core X.Y.Z (no leading zeros)
_is_semver_core() {
  [[ "$1" =~ ^(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)$ ]]
}

# Semver with optional -prerelease
_is_semver_with_prerelease() {
  [[ "$1" =~ ^(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)(-[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?$ ]]
}

# Semver with optional -prerelease and +build metadata
_is_semver_full() {
  [[ "$1" =~ ^(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)(-[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?(\+[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?$ ]]
}

validate_version_format() {
  local version="$1"
  local allow_prerelease="${2:-false}"
  local allow_build="${3:-false}"

  if [[ "$allow_build" == "true" ]]; then
    _is_semver_full "$version" && return 0
    printf "%s\n" "${YELLOW}Expected: MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD] (e.g., 1.2.3-rc.1+001)${RESET}" >&2
    _die "Invalid version format: $version"
  elif [[ "$allow_prerelease" == "true" ]]; then
    _is_semver_with_prerelease "$version" && return 0
    printf "%s\n" "${YELLOW}Expected: MAJOR.MINOR.PATCH or MAJOR.MINOR.PATCH-PRERELEASE (e.g., 1.2.3 or 1.2.3-rc.1)${RESET}" >&2
    _die "Invalid version format: $version"
  else
    _is_semver_core "$version" && return 0
    printf "%s\n" "${YELLOW}Expected: MAJOR.MINOR.PATCH (e.g., 1.2.3)${RESET}" >&2
    printf "%s\n" "${YELLOW}Note: Pre-releases require enablement; build metadata is not allowed${RESET}" >&2
    _die "Invalid version format: $version"
  fi
}

# ------------------- standalone CLI -------------------
_usage() {
  cat <<EOF
Usage: $(basename "$0") <command> [args...]

Commands:
  last-tag <tag_prefix>              Get last tag for a prefix (e.g., "v")
  hash-file <file_path>              Print file hash (sha256 preferred)
  read-version <version_file>        Read version, stripped of whitespace

Env:
  NO_COLOR=true                      Disable ANSI colors

Examples:
  $(basename "$0") last-tag v
  $(basename "$0") hash-file CMakeLists.txt
  $(basename "$0") read-version VERSION
EOF
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  init_colors "${NO_COLOR:-false}"
  case "${1:-}" in
    last-tag)
      shift
      [[ $# -ge 1 ]] || _die "last-tag requires <tag_prefix>"
      last_tag_for_prefix "$1"
      ;;
    hash-file)
      shift
      [[ $# -ge 1 ]] || _die "hash-file requires <file_path>"
      _hash_file "$1"
      ;;
    read-version)
      shift
      [[ $# -ge 1 ]] || _die "read-version requires <version_file>"
      read_version_file "$1"
      ;;
    -h|--help|'')
      _usage; [[ -n "${1:-}" ]] || exit 0
      ;;
    *)
      _usage; exit 1 ;;
  esac
fi
