#!/bin/bash
# Copyright © 2025 Eser KUBALI <lxldev.contact@gmail.com>
# SPDX-License-Identifier: GPL-3.0-or-later
#
# This file is part of vglog-filter and is licensed under
# the GNU General Public License v3.0 or later.
# See the LICENSE file in the project root for details.
#
# Semantic Version Analyzer - Improved Design
# Implements LOC-capped versioning with proper classification and rollover logic
# Addresses feedback: explosive growth, decision tree, radix, multipliers, LOC measurement

set -euo pipefail

# Configuration
VERSION_PATCH_DELTA=1
VERSION_MINOR_DELTA=5
VERSION_MAJOR_DELTA=10
LOC_CAP=10000
RADIX=100

# Bonus definitions
declare -A BONUS_RULES=(
    # Breaking Changes (High Impact)
    ["api_breaking"]=3
    ["cli_breaking"]=2
    ["removed_features"]=2
    ["database_schema"]=4
    ["config_format"]=3
    ["plugin_api"]=3
    ["deprecated_removal"]=1
    
    # Security & Stability (Critical)
    ["security_vuln"]=5
    ["cve"]=2
    ["memory_safety"]=4
    ["race_condition"]=3
    ["resource_leak"]=2
    ["crash_fix"]=3
    ["data_corruption"]=4
    
    # Performance & Optimization
    ["perf_50_plus"]=3
    ["perf_20_50"]=2
    ["memory_reduction_30"]=2
    ["build_time_50"]=1
    ["runtime_opt"]=1
    
    # Feature Additions (Medium Impact)
    ["new_cli_command"]=2
    ["new_config_option"]=1
    ["new_file_format"]=3
    ["new_api_endpoint"]=2
    ["new_plugin_system"]=4
    ["new_output_format"]=2
    
    # Code Quality & Maintenance
    ["major_refactor"]=2
    ["coverage_10_plus"]=1
    ["static_analysis"]=2
    ["new_test_suite"]=1
    ["doc_overhaul"]=1
    ["code_style"]=1
    
    # Infrastructure & Tooling
    ["cicd_changes"]=1
    ["build_overhaul"]=2
    ["major_deps"]=1
    ["new_platform"]=2
    ["containerization"]=2
    ["cloud_integration"]=3
    
    # User Experience
    ["ui_ux_improvement"]=2
    ["accessibility"]=2
    ["i18n"]=3
    ["error_messages"]=1
    ["user_docs"]=1
)

# Multiplier definitions
declare -A MULTIPLIERS=(
    ["zero_day"]=2.0
    ["production_outage"]=2.0
    ["compliance"]=1.5
    ["customer_request"]=1.2
    ["cross_platform"]=1.3
    ["backward_compat"]=1.2
    ["migration_tools"]=1.1
)

# Penalty definitions
declare -A PENALTIES=(
    ["no_migration_path"]=-2
    ["incomplete_docs"]=-1
    ["missing_tests"]=-1
    ["perf_regression"]=-2
)

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

# Help function
show_help() {
    cat << EOF
Semantic Version Analyzer - Improved Design

Usage: $0 [OPTIONS] [COMMIT_RANGE]

Options:
    -h, --help              Show this help message
    -v, --verbose           Enable verbose output
    -d, --dry-run           Show calculations without updating VERSION file
    -f, --force             Force version update even if no changes detected
    --current-version VER   Use specified version instead of reading from VERSION file
    --commit-range RANGE    Git commit range to analyze (default: HEAD~1..HEAD)

Examples:
    $0                           # Analyze last commit
    $0 HEAD~5..HEAD             # Analyze last 5 commits
    $0 --dry-run HEAD~1..HEAD   # Show calculations without updating
    $0 --current-version 1.2.3  # Start from specific version

EOF
}

# Parse command line arguments
VERBOSE=false
DRY_RUN=false
FORCE=false
CURRENT_VERSION=""
COMMIT_RANGE="HEAD~1..HEAD"

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -d|--dry-run)
            DRY_RUN=true
            shift
            ;;
        -f|--force)
            FORCE=true
            shift
            ;;
        --current-version)
            CURRENT_VERSION="$2"
            shift 2
            ;;
        --commit-range)
            COMMIT_RANGE="$2"
            shift 2
            ;;
        -*)
            log_error "Unknown option: $1"
            show_help
            exit 1
            ;;
        *)
            COMMIT_RANGE="$1"
            shift
            ;;
    esac
done

# Validate git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
    log_error "Not in a git repository"
    exit 1
fi

# Validate commit range
if ! git rev-parse --verify "$(echo "$COMMIT_RANGE" | cut -d'.' -f1)" > /dev/null 2>&1; then
    log_error "Invalid commit range: $COMMIT_RANGE"
    exit 1
fi

# Get current version
if [[ -z "$CURRENT_VERSION" ]]; then
    if [[ -f "VERSION" ]]; then
        CURRENT_VERSION=$(cat VERSION | tr -d '\n\r')
    else
        log_error "VERSION file not found and --current-version not specified"
        exit 1
    fi
fi

# Validate version format
if ! [[ "$CURRENT_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    log_error "Invalid version format: $CURRENT_VERSION (expected x.y.z)"
    exit 1
fi

# Parse current version
IFS='.' read -r x y z <<< "$CURRENT_VERSION"

log_info "Current version: $CURRENT_VERSION"
log_info "Analyzing commit range: $COMMIT_RANGE"

# Function to measure clean LOC changes (FIXED: 2.6)
measure_loc() {
    local commit_range="$1"
    
    # Get clean LOC changes, excluding generated/vendor files
    local loc=$(git diff --ignore-all-space --ignore-blank-lines \
        -- . ':!**/vendor/**' ':!**/generated/**' ':!**/node_modules/**' \
        ':!**/build/**' ':!**/dist/**' ':!**/target/**' ':!**/bin/**' \
        ':!**/obj/**' ':!**/third_party/**' \
        --stat=1000 "$commit_range" | \
        grep -E '^ [0-9]+' | \
        awk '{sum += $1} END {print sum+0}')
    
    echo "$loc"
}

# Function to detect change characteristics from commit messages
detect_changes() {
    local commit_range="$1"
    local total_bonus=0
    local multipliers=()
    local penalties=()
    local change_flags=()
    
    # Get commit messages
    local messages=$(git log --pretty=format:"%s%n%b" "$commit_range")
    
    # Convert to lowercase for case-insensitive matching
    local messages_lower=$(echo "$messages" | tr '[:upper:]' '[:lower:]')
    
    # Check for breaking changes
    if echo "$messages_lower" | grep -q -E "(breaking|breaking change|api break|incompatible)"; then
        change_flags+=("api_breaking")
        total_bonus=$((total_bonus + ${BONUS_RULES["api_breaking"]}))
    fi
    
    if echo "$messages_lower" | grep -q -E "(cli break|command.*removed|option.*removed)"; then
        change_flags+=("cli_breaking")
        total_bonus=$((total_bonus + ${BONUS_RULES["cli_breaking"]}))
    fi
    
    # Check for security issues
    if echo "$messages_lower" | grep -q -E "(security|vulnerability|cve|cve-[0-9]{4}-[0-9]+)"; then
        change_flags+=("security_vuln")
        total_bonus=$((total_bonus + ${BONUS_RULES["security_vuln"]}))
        
        # Count CVEs
        local cve_count=$(echo "$messages_lower" | grep -o "cve-[0-9]{4}-[0-9]+" | wc -l)
        if [[ $cve_count -gt 0 ]]; then
            total_bonus=$((total_bonus + cve_count * ${BONUS_RULES["cve"]}))
        fi
        
        # Check for zero-day
        if echo "$messages_lower" | grep -q -E "(zero.?day|0.?day)"; then
            multipliers+=("zero_day")
        fi
    fi
    
    # Check for performance improvements
    if echo "$messages_lower" | grep -q -E "(performance|perf|optimization|faster)"; then
        if echo "$messages_lower" | grep -q -E "(50%|fifty percent|doubled|2x)"; then
            change_flags+=("perf_50_plus")
            total_bonus=$((total_bonus + ${BONUS_RULES["perf_50_plus"]}))
        else
            change_flags+=("perf_20_50")
            total_bonus=$((total_bonus + ${BONUS_RULES["perf_20_50"]}))
        fi
    fi
    
    # Check for new features
    if echo "$messages_lower" | grep -q -E "(new feature|add.*feature|implement.*feature)"; then
        change_flags+=("new_feature")
    fi
    
    # Check for new CLI commands
    local cli_commands=$(echo "$messages_lower" | grep -o "add.*command\|new.*command" | wc -l)
    if [[ $cli_commands -gt 0 ]]; then
        total_bonus=$((total_bonus + cli_commands * ${BONUS_RULES["new_cli_command"]}))
    fi
    
    # Check for refactoring
    if echo "$messages_lower" | grep -q -E "(refactor|restructure|reorganize)"; then
        change_flags+=("major_refactor")
        total_bonus=$((total_bonus + ${BONUS_RULES["major_refactor"]}))
    fi
    
    # Check for documentation
    if echo "$messages_lower" | grep -q -E "(documentation|docs|readme)"; then
        change_flags+=("doc_overhaul")
        total_bonus=$((total_bonus + ${BONUS_RULES["doc_overhaul"]}))
    fi
    
    # Check for tests
    if echo "$messages_lower" | grep -q -E "(test|spec|unit test|integration test)"; then
        change_flags+=("new_test_suite")
        total_bonus=$((total_bonus + ${BONUS_RULES["new_test_suite"]}))
    fi
    
    # Check for production outage fixes
    if echo "$messages_lower" | grep -q -E "(outage|downtime|production.*down)"; then
        multipliers+=("production_outage")
    fi
    
    # Check for compliance
    if echo "$messages_lower" | grep -q -E "(compliance|gdpr|hipaa|sox)"; then
        multipliers+=("compliance")
    fi
    
    # Check for customer requests
    if echo "$messages_lower" | grep -q -E "(customer.*request|user.*request|feature.*request)"; then
        multipliers+=("customer_request")
    fi
    
    # Check for missing tests penalty
    if echo "$messages_lower" | grep -q -E "(new feature|add.*feature)" && \
       ! echo "$messages_lower" | grep -q -E "(test|spec)"; then
        penalties+=("missing_tests")
        total_bonus=$((total_bonus + ${PENALTIES["missing_tests"]}))
    fi
    
    echo "$total_bonus:${multipliers[*]}:${penalties[*]}:${change_flags[*]}"
}

# Function to classify change type (FIXED: 2.2 - Codified decision tree)
classify_change() {
    local total_bonus="$1"
    local change_flags="$2"
    
    # MAJOR triggers (any of these)
    if echo "$change_flags" | grep -q "api_breaking\|cli_breaking\|database_schema" || \
       [[ $total_bonus -ge 8 ]]; then
        echo "MAJOR"
        return
    fi
    
    # MINOR triggers (any of these)
    if echo "$change_flags" | grep -q "new_feature\|perf_50_plus\|new_plugin_system" || \
       [[ $total_bonus -ge 4 ]]; then
        echo "MINOR"
        return
    fi
    
    # Default to PATCH
    echo "PATCH"
}

# Function to calculate version delta (FIXED: 2.1, 2.4 - Cap LOC factor, apply multipliers after classification)
calculate_delta() {
    local change_type="$1"
    local base_delta="$2"
    local total_bonus="$3"
    local loc="$4"
    local multipliers="$5"
    
    # FIXED: Apply LOC cap to prevent explosive growth
    local capped_loc=$((loc > LOC_CAP ? LOC_CAP : loc))
    
    # Get LOC divisor based on change type
    local loc_divisor
    case "$change_type" in
        "MAJOR") loc_divisor=1000 ;;
        "MINOR") loc_divisor=500 ;;
        "PATCH") loc_divisor=250 ;;
        *) loc_divisor=250 ;;
    esac
    
    # Calculate LOC factor with cap
    local loc_factor=$(echo "scale=3; $capped_loc / $loc_divisor" | bc -l)
    
    # FIXED: Apply multipliers AFTER classification (within the same field)
    local multiplier_product=1.0
    for multiplier in $multipliers; do
        if [[ -n "$multiplier" ]]; then
            multiplier_product=$(echo "scale=3; $multiplier_product * ${MULTIPLIERS[$multiplier]}" | bc -l)
        fi
    done
    
    # Calculate base delta with LOC factor
    local final_delta=$(echo "scale=3; ($base_delta + $total_bonus) * (1 + $loc_factor) * $multiplier_product" | bc -l)
    
    # Round to integer
    echo "$final_delta" | awk '{printf "%.0f", $1}'
}

# Function to apply rollover logic (FIXED: 2.3 - Reduce radix to 100)
apply_rollover() {
    local x="$1"
    local y="$2"
    local z="$3"
    local delta_z="$4"
    local delta_y="$5"
    
    # Calculate new z with rollover (radix = 100)
    local z_new=$((z + delta_z))
    local final_z=$((z_new % RADIX))
    local y_carry=$((z_new / RADIX))
    
    # Add y carry to delta_y
    delta_y=$((delta_y + y_carry))
    
    # Calculate new y with rollover (radix = 100)
    local y_new=$((y + delta_y))
    local final_y=$((y_new % RADIX))
    local x_carry=$((y_new / RADIX))
    
    # Calculate new x
    local final_x=$((x + x_carry))
    
    echo "$final_x.$final_y.$final_z"
}

# Main analysis
log_info "Measuring LOC changes..."
LOC=$(measure_loc "$COMMIT_RANGE")
log_info "LOC changes: $LOC (capped at $LOC_CAP)"

log_info "Detecting change characteristics..."
change_analysis=$(detect_changes "$COMMIT_RANGE")
IFS=':' read -r total_bonus multipliers penalties change_flags <<< "$change_analysis"

log_info "Total bonus: $total_bonus"
if [[ -n "$multipliers" ]]; then
    log_info "Multipliers: $multipliers"
fi
if [[ -n "$penalties" ]]; then
    log_info "Penalties: $penalties"
fi
if [[ -n "$change_flags" ]]; then
    log_info "Change flags: $change_flags"
fi

log_info "Classifying change type..."
change_type=$(classify_change "$total_bonus" "$change_flags")
log_info "Change type: $change_type"

# Get base delta for change type
case "$change_type" in
    "MAJOR") base_delta=$VERSION_MAJOR_DELTA ;;
    "MINOR") base_delta=$VERSION_MINOR_DELTA ;;
    "PATCH") base_delta=$VERSION_PATCH_DELTA ;;
    *) base_delta=$VERSION_PATCH_DELTA ;;
esac

log_info "Calculating version delta..."
delta_z=$(calculate_delta "$change_type" "$base_delta" "$total_bonus" "$LOC" "$multipliers")
delta_y=0

log_info "Base delta: $base_delta"
log_info "Final delta: $delta_z"

# Apply rollover logic
new_version=$(apply_rollover "$x" "$y" "$z" "$delta_z" "$delta_y")

log_info "Current version: $CURRENT_VERSION"
log_info "New version: $new_version"

# Check if version actually changed
if [[ "$CURRENT_VERSION" == "$new_version" && "$FORCE" != "true" ]]; then
    log_warn "No version change detected"
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "Dry run completed - no changes would be made"
    else
        log_info "No changes needed"
    fi
    exit 0
fi

# Update VERSION file
if [[ "$DRY_RUN" == "true" ]]; then
    log_info "DRY RUN: Would update VERSION from $CURRENT_VERSION to $new_version"
    log_info "DRY RUN: Change type: $change_type"
    log_info "DRY RUN: LOC: $LOC, Bonus: $total_bonus, Delta: $delta_z"
else
    echo "$new_version" > VERSION
    log_success "Updated VERSION from $CURRENT_VERSION to $new_version"
    log_info "Change type: $change_type"
    log_info "LOC: $LOC, Bonus: $total_bonus, Delta: $delta_z"
fi

# Verbose output
if [[ "$VERBOSE" == "true" ]]; then
    echo
    echo "=== Detailed Analysis ==="
    echo "Commit range: $COMMIT_RANGE"
    echo "LOC changes: $LOC (capped at $LOC_CAP)"
    echo "Change type: $change_type"
    echo "Base delta: $base_delta"
    echo "Total bonus: $total_bonus"
    echo "Multipliers: $multipliers"
    echo "Penalties: $penalties"
    echo "Change flags: $change_flags"
    echo "Final delta: $delta_z"
    echo "Rollover: z=$z + $delta_z = $((z + delta_z)) → z_new=$((z + delta_z)) % $RADIX = $((z + delta_z)) % $RADIX"
    echo "Version: $CURRENT_VERSION → $new_version"
fi

exit 0 