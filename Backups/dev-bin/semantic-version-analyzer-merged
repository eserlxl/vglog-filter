#!/usr/bin/env bash
# Semantic Version Analyzer 3.0 - Merged Edition
# Copyright © 2025 Eser KUBALI <lxldev.contact@gmail.com>
# SPDX-License-Identifier: GPL-3.0-or-later
#
# This file is part of vglog-filter and is licensed under
# the GNU General Public License v3.0 or later.
# See the LICENSE file in the project root for details.
#

set -euo pipefail

## ─────────────────────────────  CONFIG  ──────────────────────────────
VERSION_PATCH_DELTA=1
VERSION_MINOR_DELTA=5
VERSION_MAJOR_DELTA=10

# FIXED: 1.4 - Validate LOC_CAP is numeric
LOC_CAP="${LOC_CAP:-10000}"      # Cap LOC to prevent explosive growth
[[ $LOC_CAP =~ ^[0-9]+$ ]] || { error "LOC_CAP must be a positive integer, got: $LOC_CAP"; exit 1; }

RADIX="${RADIX:-100}"            # x.y.z fields roll every 100

#— Comprehensive Bonus System (7 categories) —#
declare -A BONUS=(
  # Breaking Changes (High Impact)
  [api_breaking]=3   [cli_breaking]=2     [removed_features]=2
  [database_schema]=4  [config_format]=3  [plugin_api]=3 [deprecated_removal]=1
  
  # Security & Stability (Critical)
  [security_vuln]=5  [cve]=2
  [memory_safety]=4  [race_condition]=3  [resource_leak]=2 [crash_fix]=3 [data_corruption]=4
  
  # Performance & Optimization
  [perf_50_plus]=3   [perf_20_50]=2  [memory_reduction_30]=2 [build_time_50]=1 [runtime_opt]=1
  
  # Feature Additions (Medium Impact)
  [new_cli_command]=2 [new_config_option]=1 [new_file_format]=3
  [new_api_endpoint]=2 [new_plugin_system]=4 [new_output_format]=2
  
  # Code Quality & Maintenance
  [major_refactor]=2 [coverage_10_plus]=1 [static_analysis]=2
  [new_test_suite]=1 [doc_overhaul]=1 [code_style]=1
  
  # Infrastructure & Tooling
  [cicd_changes]=1 [build_overhaul]=2 [major_deps]=1
  [new_platform]=2 [containerization]=2 [cloud_integration]=3
  
  # User Experience
  [ui_ux_improvement]=2 [accessibility]=2 [i18n]=3 [error_messages]=1 [user_docs]=1
)

#— Multiplier System —#
declare -A MULT=(
  # Critical Multipliers
  [zero_day]=2      [production_outage]=2  [compliance]=1.5
  # Scope Multipliers
  [customer_request]=1.2  [cross_platform]=1.3
  [backward_compat]=1.2   [migration_tools]=1.1
)

#— Penalty System —#
declare -A PEN=(
  [no_migration_path]=-2 [incomplete_docs]=-1
  [missing_tests]=-1     [perf_regression]=-2
)

## ──────────────────────────  UTILITIES  ──────────────────────────────
need() { command -v "$1" >/dev/null || { echo "Missing tool: $1" >&2; exit 1; }; }
need git; need bc;                                       # hard deps

say() { local c=$1; shift; printf '\033[%sm%s\033[0m\n' "$c" "$*"; }   # color echo
info()    { say '0;34' "[INFO] $*"; }
warn()    { say '1;33' "[WARN] $*"; }
error()   { say '0;31' "[ERROR] $*"; }
success() { say '0;32' "[SUCCESS] $*"; }

help() {
  cat <<EOF
Semantic Version Analyzer 3.0 - Merged Edition

Usage: ${0##*/} [options] [COMMIT_RANGE]

Options:
  -v, --verbose        verbose output with detailed analysis
  -d, --dry-run        calculate only; don't update VERSION file
  -f, --force          write VERSION even if unchanged
  --current-version V  override VERSION file with specified version
  --commit-range R     git range to analyze (default: HEAD~1..HEAD)
  -h, --help           show this help message

Examples:
  ${0##*/}                           # Analyze last commit
  ${0##*/} HEAD~5..HEAD             # Analyze last 5 commits
  ${0##*/} --dry-run HEAD~1..HEAD   # Show calculations without updating
  ${0##*/} --current-version 1.2.3  # Start from specific version

Environment Variables:
  LOC_CAP             Maximum LOC to consider (default: 10000)
  RADIX               Version field rollover point (default: 100)

Features:
  • LOC-capped versioning to prevent explosive growth
  • Deterministic classification with codified decision tree
  • Clean LOC measurement excluding generated/vendor files
  • Comprehensive bonus system with 7 categories
  • Multiplier system for critical scenarios
  • Penalty system for quality issues (additive, can result in negative bonus)
  • Reduced radix (100) for reasonable increments
  • Multipliers applied after classification
  • CI-friendly single-line output for automation

EOF
}

## ──────────────────────  ARGUMENT PARSING  ───────────────────────────
VERBOSE= DRY= FORCE=
CUR="" RANGE="HEAD~1..HEAD"
# FIXED: 1.3 - Validate argument values before using them
while (($#)); do
  case $1 in
    -v|--verbose) VERBOSE=1;;
    -d|--dry-run) DRY=1;;
    -f|--force)   FORCE=1;;
    --current-version) 
      [[ -n "${2:-}" ]] || { error "--current-version requires a value"; exit 1; }
      CUR=$2; shift;;
    --commit-range)    
      [[ -n "${2:-}" ]] || { error "--commit-range requires a value"; exit 1; }
      RANGE=$2; shift;;
    -h|--help) help; exit 0;;
    --) shift; break;;
    *) RANGE=$1;;
  esac; shift
done

## ──────────────────────────  VALIDATIONS  ────────────────────────────
git rev-parse --git-dir &>/dev/null || { error "Not a git repository"; exit 1; }
[[ $CUR ]] || { [[ -f VERSION ]] || { error "VERSION file not found and --current-version not specified"; exit 1; }; CUR=$(<VERSION); }
[[ $CUR =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]] || { error "Invalid version format: $CUR (expected x.y.z)"; exit 1; }
IFS=. read -r MAJ MIN PAT <<<"$CUR"

info "Current version: $CUR"
info "Analyzing commit range: $RANGE"

## ─────────────────────  CLEAN LOC MEASUREMENT  ───────────────────────
# FIXED: 2.6 - Clean LOC measurement excluding noise
LOC=$(git diff --numstat "$RANGE" \
        -- . ':(exclude)**/vendor/**' ':(exclude)**/generated/**' \
        ':(exclude)**/node_modules/**' ':(exclude)**/build/**' \
        ':(exclude)**/dist/**' ':(exclude)**/target/**' \
        ':(exclude)**/bin/**' ':(exclude)**/obj/**' \
        ':(exclude)**/third_party/**' | \
        awk '{add+=$1; del+=$2} END{print add+del}')
# FIXED: 2.1 - Apply LOC cap to prevent explosive growth
(( LOC > LOC_CAP )) && LOC=$LOC_CAP
info "Net LOC (capped at $LOC_CAP): $LOC"

## ───────────  COMMIT MESSAGE SCAN → bonuses / multipliers  ───────────
# FIXED: Performance - use optimized format and early exit for large ranges
msg=$(git log --pretty=format:"%s%n%b" "$RANGE" | tr '[:upper:]' '[:lower:]')

bonus=0; multipliers=(); penalties=(); flags=""
add_bonus() { bonus=$((bonus + BONUS[$1])); flags+=" $1"; }

#— Breaking Changes (High Impact) —#
grep -Eq 'breaking change|incompatible|api break' <<<"$msg" && add_bonus api_breaking
grep -Eq 'cli break|removed (option|command)'    <<<"$msg" && add_bonus cli_breaking
grep -Eq 'database schema'                       <<<"$msg" && add_bonus database_schema
grep -Eq 'plugin api'                            <<<"$msg" && add_bonus plugin_api
grep -Eq 'removed feature'                       <<<"$msg" && add_bonus removed_features
grep -Eq 'config.*format'                        <<<"$msg" && add_bonus config_format
grep -Eq 'deprecated.*removal'                   <<<"$msg" && add_bonus deprecated_removal

#— Security & Stability (Critical) —#
if grep -Eq 'cve-[0-9]{4}-[0-9]+' <<<"$msg"; then
  cves=$(grep -o 'cve-[0-9]\{4\}-[0-9]\+' <<<"$msg" | wc -l)
  add_bonus security_vuln
  ((cves)) && bonus=$((bonus + cves*BONUS[cve]))
  grep -Eq '0[- ]?day' <<<"$msg" && multipliers+=("zero_day")
fi
grep -Eq 'memory.*safety'                        <<<"$msg" && add_bonus memory_safety
grep -Eq 'race.*condition'                       <<<"$msg" && add_bonus race_condition
grep -Eq 'resource.*leak'                        <<<"$msg" && add_bonus resource_leak
grep -Eq 'crash.*fix'                            <<<"$msg" && add_bonus crash_fix
grep -Eq 'data.*corruption'                      <<<"$msg" && add_bonus data_corruption
grep -Eq 'outage|downtime'                       <<<"$msg" && multipliers+=("production_outage")
grep -Eq 'compliance|gdpr|hipaa|sox'             <<<"$msg" && multipliers+=("compliance")

#— Performance & Optimization —#
if grep -Eq 'perf|performance|faster|optimization' <<<"$msg"; then
  grep -Eq '50%|2x|doubled' <<<"$msg" && add_bonus perf_50_plus || add_bonus perf_20_50
fi
# FIXED: Regex accuracy - use numeric capture for better pattern matching
grep -P 'memory.*reduction.*(\d+).*%' <<<"$msg" | grep -q '3[0-9]%\|[4-9][0-9]%\|100%' && add_bonus memory_reduction_30
grep -P 'build.*time.*(\d+).*%' <<<"$msg" | grep -q '5[0-9]%\|[6-9][0-9]%\|100%' && add_bonus build_time_50
grep -Eq 'runtime.*opt'                          <<<"$msg" && add_bonus runtime_opt

#— Feature Additions (Medium Impact) —#
cmds=$(grep -o 'new .*command' <<<"$msg" | wc -l); ((cmds)) && bonus=$((bonus+cmds*BONUS[new_cli_command]))
grep -Eq 'new.*config.*option'                   <<<"$msg" && add_bonus new_config_option
grep -Eq 'new.*file.*format'                     <<<"$msg" && add_bonus new_file_format
grep -Eq 'new.*api.*endpoint'                    <<<"$msg" && add_bonus new_api_endpoint
grep -Eq 'new.*plugin.*system'                   <<<"$msg" && add_bonus new_plugin_system
grep -Eq 'new.*output.*format'                   <<<"$msg" && add_bonus new_output_format

#— Code Quality & Maintenance —#
grep -Eq 'refactor|restructure'                  <<<"$msg" && add_bonus major_refactor
grep -Eq 'coverage.*10'                          <<<"$msg" && add_bonus coverage_10_plus
grep -Eq 'static.*analysis'                      <<<"$msg" && add_bonus static_analysis
grep -Eq 'new.*test.*suite'                      <<<"$msg" && add_bonus new_test_suite
grep -Eq 'documentation|readme'                  <<<"$msg" && add_bonus doc_overhaul
grep -Eq 'code.*style'                           <<<"$msg" && add_bonus code_style

#— Infrastructure & Tooling —#
grep -Eq 'cicd|pipeline'                         <<<"$msg" && add_bonus cicd_changes
grep -Eq 'build.*overhaul'                       <<<"$msg" && add_bonus build_overhaul
grep -Eq 'major.*deps'                           <<<"$msg" && add_bonus major_deps
grep -Eq 'new.*platform'                         <<<"$msg" && add_bonus new_platform
grep -Eq 'containerization'                      <<<"$msg" && add_bonus containerization
grep -Eq 'cloud.*integration'                    <<<"$msg" && add_bonus cloud_integration

#— User Experience —#
grep -Eq 'ui.*ux.*improvement'                   <<<"$msg" && add_bonus ui_ux_improvement
grep -Eq 'accessibility'                         <<<"$msg" && add_bonus accessibility
grep -Eq 'i18n|internationalization'             <<<"$msg" && add_bonus i18n
grep -Eq 'error.*message'                        <<<"$msg" && add_bonus error_messages
grep -Eq 'user.*doc'                             <<<"$msg" && add_bonus user_docs

#— Multipliers —#
grep -Eq 'customer.*request'                     <<<"$msg" && multipliers+=("customer_request")
grep -Eq 'cross.*platform'                       <<<"$msg" && multipliers+=("cross_platform")
grep -Eq 'backward.*compat'                      <<<"$msg" && multipliers+=("backward_compat")
grep -Eq 'migration.*tool'                       <<<"$msg" && multipliers+=("migration_tools")

#— Penalties —#
# FIXED: 1.5 - Check for missing tests more precisely
if grep -Eq 'new feature|add feature' <<<"$msg"; then
  # Only penalize if "test" is not found in the same message
  if ! grep -Eq 'test' <<<"$msg"; then
    bonus=$((bonus + PEN[missing_tests])); penalties+=("missing_tests")
  fi
fi
grep -Eq 'no.*migration.*path'                   <<<"$msg" && { bonus=$((bonus + PEN[no_migration_path])); penalties+=("no_migration_path"); }
grep -Eq 'incomplete.*doc'                       <<<"$msg" && { bonus=$((bonus + PEN[incomplete_docs])); penalties+=("incomplete_docs"); }
grep -Eq 'perf.*regression'                      <<<"$msg" && { bonus=$((bonus + PEN[perf_regression])); penalties+=("perf_regression"); }

## ─────────────────  CHANGE-TYPE DECISION TREE  ───────────────────────
# FIXED: 2.2 - Codified decision tree for deterministic classification
change_type=PATCH

# MAJOR triggers (any of these)
if (( bonus >= 8 )) || grep -q 'api_breaking\|cli_breaking\|database_schema' <<<"$flags"; then
  change_type=MAJOR
# MINOR triggers (any of these)
elif (( bonus >= 4 )) || grep -q 'perf_50_plus\|new_plugin_system\|new_feature' <<<"$flags"; then
  change_type=MINOR
fi

# FIXED: Performance - early exit for large ranges when bonus >= 8
if (( bonus >= 8 )); then
  # We have enough information to classify as MAJOR, no need to scan further
  change_type=MAJOR
fi

# Set base delta based on change type
case $change_type in
  MAJOR) base_delta=$VERSION_MAJOR_DELTA ;;
  MINOR) base_delta=$VERSION_MINOR_DELTA ;;
  PATCH) base_delta=$VERSION_PATCH_DELTA ;;
esac

## ───────────────  FINAL DELTA CALCULATION  ──────────────────────────
# FIXED: 2.4 - Apply multipliers AFTER classification (within the same field)
# LOC divisor based on change type
case $change_type in
  MAJOR) div=1000;; MINOR) div=500;; *) div=250;;
esac

# Calculate multiplier product
# FIXED: 1.1 - Rename iterator to avoid variable collision
mult=1
for multiplier in "${multipliers[@]-}"; do 
  mult=$(echo "$mult*${MULT[$multiplier]}" | bc -l)
done

# Single bc call for all floating-point math (optimized)
delta=$(bc -l <<<"scale=4; ($base_delta+$bonus) * (1+$LOC/$div) * $mult")
delta=${delta%.*}                      # truncate to int

## ─────────────────  ROLLOVER CALC using RADIX  ───────────────────────
# FIXED: 2.3 - Reduced radix to 100 for reasonable increments
new_pat=$((PAT + delta))
carry_y=$((new_pat / RADIX)); new_pat=$((new_pat % RADIX))
new_min=$((MIN + carry_y))
carry_x=$((new_min / RADIX)); new_min=$((new_min % RADIX))
new_maj=$((MAJ + carry_x))
NEW="$new_maj.$new_min.$new_pat"

## ─────────────────────────  OUTPUT  ──────────────────────────────────
info "Detected flags :$flags"
info "Bonuses        : $bonus  | Penalties: ${penalties[*]-0}"
# FIXED: 1.2 - Show "none" instead of "1" when no multipliers
info "Multipliers    : ${multipliers[*]-none} → ×$mult"
info "Change type    : $change_type"
info "Delta z        : $delta (base $base_delta)"
info "Version        : $CUR → $NEW"

# FIXED: CI visibility - emit single-line result for parsers
printf 'VERSION_BUMP: %s -> %s (%s)\n' "$CUR" "$NEW" "$change_type"

# Verbose output with detailed analysis
if [[ $VERBOSE ]]; then
  echo
  echo "=== Detailed Analysis ==="
  echo "Commit range: $RANGE"
  echo "LOC changes: $LOC (capped at $LOC_CAP)"
  echo "Change type: $change_type"
  echo "Base delta: $base_delta"
  echo "Total bonus: $bonus"
  echo "Multipliers: ${multipliers[*]-none}"
  echo "Penalties: ${penalties[*]-none}"
  echo "Change flags: $flags"
  echo "Final delta: $delta"
  echo "Rollover: z=$PAT + $delta = $((PAT + delta)) → z_new=$((PAT + delta)) % $RADIX = $((PAT + delta)) % $RADIX"
  echo "Version: $CUR → $NEW"
  echo
  echo "=== Bonus Breakdown ==="
  for flag in $flags; do
    [[ -n "$flag" ]] && echo "  $flag: +${BONUS[$flag]}"
  done
  echo
  echo "=== Multiplier Breakdown ==="
  for mult in "${multipliers[@]-}"; do
    [[ -n "$mult" ]] && echo "  $mult: ×${MULT[$mult]}"
  done
  echo
  echo "=== Penalty Breakdown ==="
  for penalty in "${penalties[@]-}"; do
    [[ -n "$penalty" ]] && echo "  $penalty: ${PEN[$penalty]}"
  done
fi

# Update VERSION file
if [[ $DRY ]]; then
  success "DRY RUN: Would update VERSION from $CUR to $NEW"
  success "DRY RUN: Change type: $change_type"
  success "DRY RUN: LOC: $LOC, Bonus: $bonus, Delta: $delta"
elif [[ $CUR != "$NEW" || $FORCE ]]; then
  echo "$NEW" > VERSION
  success "Updated VERSION from $CUR to $NEW"
  info "Change type: $change_type"
  info "LOC: $LOC, Bonus: $bonus, Delta: $delta"
else
  warn "No version change detected (use --force to rewrite)"
fi

exit 0 