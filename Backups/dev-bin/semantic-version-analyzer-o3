#!/usr/bin/env bash
# Semantic Version Analyzer 2.0
# Copyright © 2025 Eser KUBALI
# SPDX-License-Identifier: GPL-3.0-or-later
#
# – Key improvements –
#   • uses `git diff --numstat` for precise LOC totals
#   • guards against missing tools (`git`, `bc`)
#   • separates bonus vs. penalty math for readability
#   • fixes “missing_tests” penalty logic
#   • adds more patterns (db schema, plugin-API, etc.)
#   • folds all floating-point math into one bc invocation
#   • makes RADIX and LOC_CAP easy to override via env

set -euo pipefail

## ─────────────────────────────  CONFIG  ──────────────────────────────
VERSION_PATCH_DELTA=1
VERSION_MINOR_DELTA=5
VERSION_MAJOR_DELTA=10

LOC_CAP="${LOC_CAP:-10000}"
RADIX="${RADIX:-100}"            # x.y.z fields roll every 100

#— Bonus, multiplier & penalty tables —#
declare -A BONUS=(
  # Breaking Changes
  [api_breaking]=3   [cli_breaking]=2     [removed_features]=2
  [database_schema]=4  [config_format]=3  [plugin_api]=3 [deprecated_removal]=1
  # Security
  [security_vuln]=5  [cve]=2
  [memory_safety]=4  [race_condition]=3  [resource_leak]=2 [crash_fix]=3 [data_corruption]=4
  # Performance
  [perf_50_plus]=3   [perf_20_50]=2  [memory_reduction_30]=2 [build_time_50]=1 [runtime_opt]=1
  # Features
  [new_cli_command]=2 [new_config_option]=1 [new_file_format]=3
  [new_api_endpoint]=2 [new_plugin_system]=4 [new_output_format]=2
  # Code quality
  [major_refactor]=2 [coverage_10_plus]=1 [static_analysis]=2
  [new_test_suite]=1 [doc_overhaul]=1 [code_style]=1
  # Infra
  [cicd_changes]=1 [build_overhaul]=2 [major_deps]=1
  [new_platform]=2 [containerization]=2 [cloud_integration]=3
  # UX
  [ui_ux_improvement]=2 [accessibility]=2 [i18n]=3 [error_messages]=1 [user_docs]=1
)
declare -A MULT=(
  [zero_day]=2      [production_outage]=2  [compliance]=1.5
  [customer_request]=1.2  [cross_platform]=1.3
  [backward_compat]=1.2   [migration_tools]=1.1
)
declare -A PEN=(
  [no_migration_path]=-2 [incomplete_docs]=-1
  [missing_tests]=-1     [perf_regression]=-2
)

## ──────────────────────────  UTILITIES  ──────────────────────────────
need() { command -v "$1" >/dev/null || { echo "Missing tool: $1" >&2; exit 1; }; }
need git; need bc;                                       # hard deps

say() { local c=$1; shift; printf '\033[%sm%s\033[0m\n' "$c" "$*"; }   # color echo
info()    { say '0;34' "[INFO] $*"; }
warn()    { say '1;33' "[WARN] $*"; }
error()   { say '0;31' "[ERROR] $*"; }
success() { say '0;32' "[OK] $*"; }

help() {
  cat <<EOF
Usage: ${0##*/} [options] [COMMIT_RANGE]
Options:
  -v, --verbose        verbose output
  -d, --dry-run        calculate only; don't update VERSION
  -f, --force          write VERSION even if unchanged
  --current-version V  override VERSION file
  --commit-range R     git range (default HEAD~1..HEAD)
  -h, --help           this help
EOF
}

## ──────────────────────  ARGUMENT PARSING  ───────────────────────────
VERBOSE= DRY= FORCE=
CUR="" RANGE="HEAD~1..HEAD"
while (($#)); do
  case $1 in
    -v|--verbose) VERBOSE=1;;
    -d|--dry-run) DRY=1;;
    -f|--force)   FORCE=1;;
    --current-version) CUR=$2; shift;;
    --commit-range)    RANGE=$2; shift;;
    -h|--help) help; exit 0;;
    --) shift; break;;
    *) RANGE=$1;;
  esac; shift
done

## ──────────────────────────  VALIDATIONS  ────────────────────────────
git rev-parse --git-dir &>/dev/null || { error "Not a git repo"; exit 1; }
[[ $CUR ]] || { [[ -f VERSION ]] || { error "VERSION file missing"; exit 1; }; CUR=$(<VERSION); }
[[ $CUR =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]] || { error "Bad version $CUR"; exit 1; }
IFS=. read -r MAJ MIN PAT <<<"$CUR"

## ─────────────────────  LOC (added+removed)  ─────────────────────────
LOC=$(git diff --numstat "$RANGE" \
        -- . ':(exclude)**/vendor/**' ':(exclude)**/generated/**' \
        ':(exclude)**/node_modules/**' | awk '{add+=$1; del+=$2} END{print add+del}')
(( LOC > LOC_CAP )) && LOC=$LOC_CAP
info "Net LOC (capped): $LOC"

## ───────────  COMMIT MESSAGE SCAN → bonuses / multipliers  ───────────
msg=$(git log --pretty=format:%B "$RANGE" | tr '[:upper:]' '[:lower:]')

bonus=0; multipliers=(); penalties=()
add_bonus() { bonus=$((bonus + BONUS[$1])); flags+=" $1"; }

#— Breaking changes —#
grep -Eq 'breaking change|incompatible|api break' <<<"$msg" && add_bonus api_breaking
grep -Eq 'cli break|removed (option|command)'    <<<"$msg" && add_bonus cli_breaking
grep -Eq 'database schema'                       <<<"$msg" && add_bonus database_schema
grep -Eq 'plugin api'                            <<<"$msg" && add_bonus plugin_api
grep -Eq 'removed feature'                       <<<"$msg" && add_bonus removed_features

#— Security —#
if grep -Eq 'cve-[0-9]{4}-[0-9]+' <<<"$msg"; then
  cves=$(grep -o 'cve-[0-9]\{4\}-[0-9]\+' <<<"$msg" | wc -l)
  add_bonus security_vuln
  ((cves)) && bonus=$((bonus + cves*BONUS[cve]))
  grep -Eq '0[- ]?day' <<<"$msg" && multipliers+=("zero_day")
fi
grep -Eq 'outage|downtime'  <<<"$msg" && multipliers+=("production_outage")
grep -Eq 'compliance|gdpr|hipaa|sox' <<<"$msg" && multipliers+=("compliance")

#— Performance —#
if grep -Eq 'perf|performance|faster|optimization' <<<"$msg"; then
  grep -Eq '50%|2x|doubled' <<<"$msg" && add_bonus perf_50_plus || add_bonus perf_20_50
fi

#— Features / misc —#
cmds=$(grep -o 'new .*command' <<<"$msg" | wc -l); ((cmds)) && bonus=$((bonus+cmds*BONUS[new_cli_command]))
grep -Eq 'refactor|restructure' <<<"$msg" && add_bonus major_refactor
grep -Eq 'documentation|readme' <<<"$msg" && add_bonus doc_overhaul

#— Missing-test penalty —#
if grep -Eq 'new feature|add feature' <<<"$msg" && ! grep -Eq 'test' <<<"$msg"; then
  bonus=$((bonus + PEN[missing_tests])); penalties+=("missing_tests")
fi

[[ ${multipliers[*]-} =~ customer ]] || grep -Eq 'customer request' <<<"$msg" && multipliers+=("customer_request")

## ─────────────────  CHANGE-TYPE DECISION TREE  ───────────────────────
change_type=PATCH
(( bonus >= 8 )) && change_type=MAJOR
grep -q 'api_breaking\|cli_breaking\|database_schema' <<<"$flags" && change_type=MAJOR
if [[ $change_type == PATCH && ( bonus -ge 4 || $flags =~ perf_50_plus|new_plugin_system ) ]]; then
  change_type=MINOR
fi

base_delta=$VERSION_PATCH_DELTA
[[ $change_type == MINOR ]] && base_delta=$VERSION_MINOR_DELTA
[[ $change_type == MAJOR ]] && base_delta=$VERSION_MAJOR_DELTA

## ───────────────  FINAL DELTA (single bc call)  ──────────────────────
# LOC divisor table
case $change_type in
  MAJOR) div=1000;; MINOR) div=500;; *) div=250;;
esac
mult=1
for m in "${multipliers[@]-}"; do mult=$(echo "$mult*${MULT[$m]}" | bc -l); done

delta=$(bc -l <<<"scale=4; ($base_delta+$bonus) * (1+$LOC/$div) * $mult")
delta=${delta%.*}                      # truncate to int

## ─────────────────  ROLLOVER CALC using RADIX  ───────────────────────
new_pat=$((PAT + delta))
carry_y=$((new_pat / RADIX)); new_pat=$((new_pat % RADIX))
new_min=$((MIN + carry_y))
carry_x=$((new_min / RADIX)); new_min=$((new_min % RADIX))
new_maj=$((MAJ + carry_x))
NEW="$new_maj.$new_min.$new_pat"

## ─────────────────────────  OUTPUT  ──────────────────────────────────
info  "Detected flags :$flags"
info  "Bonuses        : $bonus  | Penalties: ${penalties[*]-0}"
info  "Multipliers    : ${multipliers[*]-1} → ×$mult"
info  "Change type    : $change_type"
info  "Delta z        : $delta (base $base_delta)"
info  "Version        : $CUR → $NEW"

if [[ $DRY ]]; then
  success "Dry-run; VERSION not modified."
elif [[ $CUR != "$NEW" || $FORCE ]]; then
  echo "$NEW" > VERSION
  success "VERSION updated to $NEW"
else
  warn "No change detected (use --force to rewrite)."
fi

[[ $VERBOSE ]] && printf '\nVerbose flags: %s\n' "$flags"

exit 0
